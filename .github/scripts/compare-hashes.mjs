#!/usr/bin/env node

// @ts-check

/**
 * This script compares bytecode hashes across the platforms detected in the
 * provided hash files to verify that resolc generated identical bytecode
 * for each provided optimization level.
 *
 * ```
 * Usage: node compare-hashes.mjs <hashes-dir> <file-pattern> <opt-levels>
 *
 *   hashes-dir:   Directory containing hash files to compare
 *   file-pattern: Glob pattern for finding hash files (e.g., "*", "*.json", or "hashes-*.json")
 *   opt-levels:   Comma-separated optimization levels (e.g., "0,3,z")
 * ```
 *
 * Expected hash file structure:
 * - Can be generated by compile-and-hash.mjs
 * - The file paths used as keys are expected to be normalized across the platforms
 * - Any extra fields are ignored
 *
 * ```json
 * {
 *   "platform": "linux-musl",
 *   "hashes": {
 *     "0": {
 *       "solidity/simple/loop/array/simple.sol": {
 *         "ContractA": "<sha256>",
 *         "ContractB": "<sha256>"
 *       },
 *       "yul/instructions/byte.yul": {
 *         "ContractA": "<sha256>",
 *         "ContractB": "<sha256>"
 *       },
 *     },
 *     "3": { ... },
 *     "z": { ... }
 *   }
 * }
 * ```
 */

import fs from "node:fs";
import path from "node:path";
import process from "node:process";

const VALID_OPT_LEVELS = ["0", "1", "2", "3", "s", "z"];

/**
 * @typedef {{[contractName: string]: string}} HashEntry
 */

/**
 * @typedef {Object} HashData
 * @property {string} platform - The platform (e.g., "linux", "macos").
 * @property {{[optLevel: string]: {[path: string]: HashEntry}}} hashes - The hashes for each path keyed by optimization level.
 */

/**
 * @typedef {Object} Mismatch
 * @property {string} path - The normalized file path.
 * @property {string} contract - The contract name.
 * @property {string | null} referenceHash - The hash from the reference platform, or null if missing.
 * @property {string | null} otherHash - The hash from the other platform, or null if missing.
 */

/**
 * @typedef {Object} ComparisonResult
 * @property {boolean} success - Whether the comparison completed without any mismatches.
 * @property {string[]} platforms - The platforms compared.
 * @property {string} referencePlatform - The reference platform used.
 * @property {{[optLevel: string]: {[otherPlatform: string]: Mismatch[]}}} mismatches - The mismatches found in each compared platform keyed by optimization level.
 */

/**
 * Custom error for invalid usage or hash files.
 */
class ValidationError extends Error {
    /** @type {boolean} */
    showUsage;

    /**
     * @param {string} message - The error message.
     * @param {{ filePath?: string, showUsage?: boolean }} [options] - The optional path to the invalid file and whether to show usage information.
     */
    constructor(message, { filePath, showUsage = false } = {}) {
        super(filePath
            ? `Error in ${filePath}:\n${message}`
            : `Error: ${message}`
        );
        this.name = "ValidationError";
        this.showUsage = showUsage;
    }
}

/**
 * @returns {string} The usage for the script.
 */
function getUsage() {
    return [
        "Usage: node compare-hashes.mjs <hashes-dir> <file-pattern> <opt-levels>",
        "",
        "  hashes-dir:   Directory containing hash files to compare",
        "  file-pattern: Glob pattern for finding which hash files to compare. Examples:",
        '                  "*"                    All top-level files',
        '                  "**/*"                 All files in the directory and its subdirectories',
        '                  "*.json"               All top-level JSON files',
        '                  "**/*.json"            All JSON files in the directory and its subdirectories',
        '                  "**/hashes.json"       All files named "hashes.json" in the directory and its subdirectories',
        '                  "hashes/hashes-*.json" All JSON files prefixed with "hashes-" in the "hashes" subdirectory',
        '  opt-levels:   Comma-separated optimization levels (e.g., "0,3,z")',
    ].join("\n");
}

/**
 * Finds all files in `directory` matching the glob `pattern`.
 * @param {string} directory - The directory to search in.
 * @param {string} pattern - The glob pattern to match (e.g., "*.json").
 * @returns {Promise<string[]>} Normalized file paths in platform-specific format.
 */
async function findFiles(directory, pattern) {
    const files = [];
    for await (const entry of fs.promises.glob(pattern, { cwd: directory, withFileTypes: true })) {
        if (entry.isFile()) {
            files.push(path.join(entry.parentPath, entry.name));
        }
    }

    return files;
}

/**
 * Reads and parses a file and validates the expected fields.
 * @param {string} filePath - The path to the hash file.
 * @returns {Promise<HashData>} The parsed hash file.
 * @throws {ValidationError} If the file cannot be parsed as JSON or expected fields are of invalid types.
 */
async function tryParseFile(filePath) {
    let parsed = null;
    try {
        const content = await fs.promises.readFile(filePath, "utf-8");
        parsed = JSON.parse(content);
    } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        throw new ValidationError(message, { filePath });
    }

    /** @type {(value: unknown) => boolean} */
    const isPlainObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value);

    if (!isPlainObject(parsed)) {
        throw new ValidationError(`Expected the content to be JSON object, found: ${parsed}`, { filePath });
    }

    if (!parsed.platform || typeof parsed.platform !== "string") {
        throw new ValidationError(`Expected "platform" to be a non-empty string, found: ${parsed.platform}`, { filePath });
    }

    if (!isPlainObject(parsed.hashes)) {
        throw new ValidationError(`Expected "hashes" to be an object, found: ${parsed.hashes}`, { filePath });
    }

    for (const [optLevel, hashesAtOptLevel] of Object.entries(parsed.hashes)) {
        if (!isPlainObject(hashesAtOptLevel)) {
            throw new ValidationError(`Expected "hashes.${optLevel}" to be an object, found: ${hashesAtOptLevel}`, { filePath });
        }

        for (const [pathId, contracts] of Object.entries(hashesAtOptLevel)) {
            if (!isPlainObject(contracts)) {
                throw new ValidationError(`Expected "hashes.${optLevel}["${pathId}"]" to be an object, found: ${contracts}`, { filePath });
            }

            for (const [contract, hash] of Object.entries(contracts)) {
                if (typeof hash !== "string") {
                    throw new ValidationError(`Expected "hashes.${optLevel}["${pathId}"].${contract}" to be a string, found: ${hash}`, { filePath });
                }
            }
        }
    }

    return {
        platform: parsed.platform,
        hashes: parsed.hashes,
    };
}

/**
 * Counts the total number of hashes found in `hashes`.
 * @param {{[path: string]: HashEntry}} hashes - The hashes for each path to count.
 * @returns {number} The total number of hashes.
 */
function countHashes(hashes) {
    return Object.values(hashes).reduce(
        (sum, hashesAtPath) => sum + Object.keys(hashesAtPath).length,
        0
    );
}

/**
 * Compares two sets of hashes.
 * @param {{[path: string]: HashEntry}} referenceHashes - The hashes for each path from the reference platform used.
 * @param {{[path: string]: HashEntry}} otherHashes - The hashes for each path from the other platform being compared.
 * @returns {Mismatch[]} A list of mismatches found.
 */
function compare(referenceHashes, otherHashes) {
    /** @type {Mismatch[]} */
    const mismatches = [];
    const paths = new Set([...Object.keys(referenceHashes), ...Object.keys(otherHashes)]);

    for (const pathId of paths) {
        const referenceHashesAtPath = referenceHashes[pathId] ?? {};
        const otherHashesAtPath = otherHashes[pathId] ?? {};
        const contracts = new Set([...Object.keys(referenceHashesAtPath), ...Object.keys(otherHashesAtPath)]);

        for (const contract of contracts) {
            const referenceHash = referenceHashesAtPath[contract] ?? null;
            const otherHash = otherHashesAtPath[contract] ?? null;

            if (otherHash !== referenceHash) {
                mismatches.push({
                    path: pathId,
                    contract,
                    referenceHash,
                    otherHash,
                });
            }
        }
    }

    return mismatches;
}

/**
 * Compares all platforms' hashes found in `files` across all `optLevels`.
 * @param {string[]} files - The hash files for each platform to compare.
 * @param {string[]} optLevels - The optimization levels for which hashes will be compared.
 * @returns {Promise<ComparisonResult>} The result of the comparison.
 * @throws {ValidationError} If too few files or duplicate platform labels are used.
 */
async function compareAll(files, optLevels) {
    const parsedFiles = await Promise.all(files.map(tryParseFile));
    if (parsedFiles.length < 2) {
        throw new ValidationError(`Expected at least two files, got ${parsedFiles.length}`);
    }

    // Detect duplicate platform labels _before_ sorting (to report correct file path on error).
    /** @type {string[]} */
    let platforms = [];
    for (let i = 0; i < parsedFiles.length; i++) {
        const platform = parsedFiles[i].platform;
        if (platforms.includes(platform)) {
            throw new ValidationError(`Duplicate platform label found: ${platform}`, { filePath: files[i] });
        }
        platforms.push(platform);
    }

    // Sort the files by platform name (byte-order, not `localCompare()`) for deterministic reference selection.
    parsedFiles.sort((a, b) => Number(a.platform > b.platform) - Number(a.platform < b.platform));
    platforms = parsedFiles.map(({ platform }) => platform);

    // Use the first file as the reference file.
    const [referenceData, ...otherData] = parsedFiles;
    const { platform: referencePlatform, hashes: referenceHashes } = referenceData;

    /** @type {ComparisonResult} */
    const result = {
        success: true,
        platforms,
        referencePlatform,
        mismatches: {},
    };

    for (const optLevel of optLevels) {
        console.log();
        console.log(`=== Comparing hashes from optimization level ${optLevel} ===`);
        console.log();

        const referenceHashesAtOptLevel = referenceHashes[optLevel] ?? {};
        console.log(`- ${referencePlatform}: ${countHashes(referenceHashesAtOptLevel)} hashes (used as the reference platform)`);

        result.mismatches[optLevel] = {};

        // Compare each platform's hash file against the reference.
        for (const { platform: otherPlatform, hashes: otherHashes } of otherData) {
            const otherHashesAtOptLevel = otherHashes[optLevel] ?? {};

            const mismatches = compare(referenceHashesAtOptLevel, otherHashesAtOptLevel);
            result.mismatches[optLevel][otherPlatform] = mismatches;

            const numOtherHashes = countHashes(otherHashesAtOptLevel);
            if (mismatches.length === 0) {
                console.log(`- ${otherPlatform}: ✅ All ${numOtherHashes} hashes match`);
            } else {
                console.log(`- ${otherPlatform}: ❌ ${numOtherHashes} hashes, ${mismatches.length} contracts have mismatched hashes`);
                result.success = false;
            }
        }
    }

    return result;
}

/**
 * Builds a final report from the comparison result.
 * @param {ComparisonResult} result - The result of the comparison.
 * @returns {string} The report.
 *
 * @example
 * ```
 * ===========================================
 * SUMMARY
 * ===========================================
 *
 * Optimization level 0:
 * ---------------------
 *
 *     linux vs. macos:
 *         Total mismatches: 0 ✅
 *
 *     linux vs. windows:
 *         Total mismatches: 0 ✅
 *
 * Optimization level 3:
 * ---------------------
 *
 *     linux vs. macos:
 *         Total mismatches: 0 ✅
 *
 *     linux vs. windows:
 *         Total mismatches: 2 ❌
 *
 *         - path: solidity/simple/contract.sol
 *           contract: ContractA
 *           linux: 6ef95b3bac1cd204ab235bc4bbe4f6807d420612853ebcb64962e7a49db446b6
 *           windows: 7af95b3bac1cd204ab235bc4bbe4f6807d420612853ebcb64962e7a49db446b7
 *
 *         - path: solidity/simple/contract.sol
 *           contract: ContractB
 *           linux: 8bf95b3bac1cd204ab235bc4bbe4f6807d420612853ebcb64962e7a49db446b8
 *           windows: MISSING
 *
 * Optimization level z:
 * ---------------------
 *
 *     linux vs. macos:
 *         Total mismatches: 0 ✅
 *
 *     linux vs. windows:
 *         Total mismatches: 0 ✅
 *
 * Platforms compared: linux, macos, windows
 *
 * Total mismatches: 2
 *
 * ❌ FAILURE: Reproducible build verification failed!
 *
 * ===========================================
 * ```
 */
function buildReport(result) {
    /** @type {string[]} */
    const reportPerOptLevel = [];
    let totalMismatches = 0;

    for (const [optLevel, mismatchesAtOptLevel] of Object.entries(result.mismatches)) {
        reportPerOptLevel.push(
            "",
            `Optimization level ${optLevel}:`,
            "---------------------",
        );

        for (const [otherPlatform, mismatches] of Object.entries(mismatchesAtOptLevel)) {
            reportPerOptLevel.push(
                "",
                `    ${result.referencePlatform} vs. ${otherPlatform}:`,
                `        Total mismatches: ${mismatches.length} ${mismatches.length > 0 ? "❌" : "✅"}`,
            );

            for (const mismatch of mismatches) {
                reportPerOptLevel.push(
                    "",
                    `        - path: ${mismatch.path}`,
                    `          contract: ${mismatch.contract}`,
                    `          ${result.referencePlatform}: ${mismatch.referenceHash ?? "MISSING"}`,
                    `          ${otherPlatform}: ${mismatch.otherHash ?? "MISSING"}`,
                );
            }

            totalMismatches += mismatches.length;
        }
    }

    const statusMessage = totalMismatches === 0
        ? "✅ SUCCESS: All platform builds are reproducible!"
        : "❌ FAILURE: Reproducible build verification failed!";

    const report = [
        "",
        "===========================================",
        "SUMMARY",
        "===========================================",
        ...reportPerOptLevel,
        "",
        `Platforms compared: ${result.platforms.join(", ")}`,
        "",
        `Total mismatches: ${totalMismatches}`,
        "",
        statusMessage,
        "",
        "===========================================",
    ];

    return report.join("\n");
}

/**
 * The main entry point.
 * Parses and validates arguments and initiates file parsing, comparison, and final reporting.
 * @returns {Promise<void>}
 */
async function main() {
    // Node.js 22.0.0+ is required for `fs.promises.glob` support.
    const [major] = process.versions.node.split(".").map(Number);
    if (major < 22) {
        throw new ValidationError(`Node.js 22.0.0+ required, found ${process.versions.node}`);
    }

    const args = process.argv.slice(2);

    if (args.includes("--help") || args.includes("-h")) {
        console.log(getUsage());
        process.exit(0);
    }

    if (args.length !== 3) {
        throw new ValidationError(`Received an invalid number of arguments, got ${args.length}`, { showUsage: true });
    }

    const hashesDir = path.resolve(args[0]);
    const filePattern = args[1];
    const optLevels = [...new Set(args[2].split(",").map((s) => s.trim()))];

    if (!fs.existsSync(hashesDir)) {
        throw new ValidationError(`Hashes directory not found: ${hashesDir}`);
    }

    if (filePattern === "") {
        throw new ValidationError("A file pattern must be provided", { showUsage: true });
    }

    for (const optLevel of optLevels) {
        if (!VALID_OPT_LEVELS.includes(optLevel)) {
            const errorPrefix = optLevel === ""
                ? "Please provide an optimization level"
                : `Invalid optimization level "${optLevel}"`;
            throw new ValidationError(`${errorPrefix}. Valid levels are: ${VALID_OPT_LEVELS.join(", ")}`, { showUsage: true });
        }
    }

    const files = await findFiles(hashesDir, filePattern);

    if (files.length === 0) {
        throw new ValidationError(`No hash files found matching pattern "${filePattern}" in ${hashesDir}`, { showUsage: true });
    }

    if (files.length < 2) {
        throw new ValidationError(
            `Only one hash file found matching pattern "${filePattern}" in ${hashesDir}. At least 2 hash files are required for comparison`,
            { showUsage: true }
        );
    }

    const result = await compareAll(files, optLevels);
    const report = buildReport(result);

    if (result.success) {
        console.log(report);
    } else {
        console.error(report);
        process.exit(1);
    }
}

main().catch((error) => {
    if (error instanceof ValidationError) {
        console.error(error.message);
        if (error.showUsage) {
            console.error();
            console.error(getUsage());
        }
    } else {
        // Include the full stack trace for unexpected exceptions.
        console.error(error);
    }
    process.exit(1);
});
