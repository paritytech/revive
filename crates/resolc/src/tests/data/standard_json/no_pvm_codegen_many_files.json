{
  "language": "Solidity",
  "sources": {
    "lib/forge-std/src/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {StdStorage} from \"./StdStorage.sol\";\nimport {Vm, VmSafe} from \"./Vm.sol\";\n\nabstract contract CommonBase {\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\"hevm cheat code\"))));\n    // console.sol and console2.sol work by executing a staticcall to this address.\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\"foundry default caller\"))));\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\n    // Deterministic deployment address of the Multicall3 contract.\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\n    // The order of the secp256k1 curve.\n    uint256 internal constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    Vm internal constant vm = Vm(VM_ADDRESS);\n    StdStorage internal stdstore;\n}\n\nabstract contract TestBase is CommonBase {}\n\nabstract contract ScriptBase is CommonBase {\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\n}\n"
    },
    "lib/forge-std/src/Script.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n// ðŸ’¬ ABOUT\n// Forge Std's default Script.\n\n// ðŸ§© MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheatsSafe} from \"./StdCheats.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorageSafe} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\n// ðŸ“¦ BOILERPLATE\nimport {ScriptBase} from \"./Base.sol\";\n\n// â­ï¸ SCRIPT\nabstract contract Script is ScriptBase, StdChains, StdCheatsSafe, StdUtils {\n    // Note: IS_SCRIPT() must return true.\n    bool public IS_SCRIPT = true;\n}\n"
    },
    "lib/forge-std/src/StdAssertions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdAssertions {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    event log(string);\n    event logs(bytes);\n\n    event log_address(address);\n    event log_bytes32(bytes32);\n    event log_int(int256);\n    event log_uint(uint256);\n    event log_bytes(bytes);\n    event log_string(string);\n\n    event log_named_address(string key, address val);\n    event log_named_bytes32(string key, bytes32 val);\n    event log_named_decimal_int(string key, int256 val, uint256 decimals);\n    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);\n    event log_named_int(string key, int256 val);\n    event log_named_uint(string key, uint256 val);\n    event log_named_bytes(string key, bytes val);\n    event log_named_string(string key, string val);\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    bool private _failed;\n\n    function failed() public view returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            return vm.load(address(vm), bytes32(\"failed\")) != bytes32(0);\n        }\n    }\n\n    function fail() internal virtual {\n        vm.store(address(vm), bytes32(\"failed\"), bytes32(uint256(1)));\n        _failed = true;\n    }\n\n    function assertTrue(bool data) internal pure virtual {\n        vm.assertTrue(data);\n    }\n\n    function assertTrue(bool data, string memory err) internal pure virtual {\n        vm.assertTrue(data, err);\n    }\n\n    function assertFalse(bool data) internal pure virtual {\n        vm.assertFalse(data);\n    }\n\n    function assertFalse(bool data, string memory err) internal pure virtual {\n        vm.assertFalse(data, err);\n    }\n\n    function assertEq(bool left, bool right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool left, bool right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256 left, uint256 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(int256 left, int256 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals);\n    }\n\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertEqDecimal(left, right, decimals, err);\n    }\n\n    function assertEq(address left, address right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address left, address right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32 left, bytes32 right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertEq(string memory left, string memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertEq(left, right);\n    }\n\n    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertEq(left, right, err);\n    }\n\n    // Legacy helper\n    function assertEqUint(uint256 left, uint256 right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256 left, uint256 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(int256 left, int256 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals);\n    }\n\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertNotEqDecimal(left, right, decimals, err);\n    }\n\n    function assertNotEq(address left, address right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address left, address right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string memory left, string memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {\n        vm.assertNotEq(left, right);\n    }\n\n    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {\n        vm.assertNotEq(left, right, err);\n    }\n\n    function assertLt(uint256 left, uint256 right) internal pure virtual {\n        vm.assertLt(left, right);\n    }\n\n    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertLt(left, right, err);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertLt(int256 left, int256 right) internal pure virtual {\n        vm.assertLt(left, right);\n    }\n\n    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertLt(left, right, err);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals);\n    }\n\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(uint256 left, uint256 right) internal pure virtual {\n        vm.assertGt(left, right);\n    }\n\n    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertGt(left, right, err);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertGt(int256 left, int256 right) internal pure virtual {\n        vm.assertGt(left, right);\n    }\n\n    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertGt(left, right, err);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals);\n    }\n\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGtDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(uint256 left, uint256 right) internal pure virtual {\n        vm.assertLe(left, right);\n    }\n\n    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertLe(left, right, err);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertLe(int256 left, int256 right) internal pure virtual {\n        vm.assertLe(left, right);\n    }\n\n    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertLe(left, right, err);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals);\n    }\n\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertLeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(uint256 left, uint256 right) internal pure virtual {\n        vm.assertGe(left, right);\n    }\n\n    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {\n        vm.assertGe(left, right, err);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertGe(int256 left, int256 right) internal pure virtual {\n        vm.assertGe(left, right);\n    }\n\n    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {\n        vm.assertGe(left, right, err);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals);\n    }\n\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {\n        vm.assertGeDecimal(left, right, decimals, err);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta);\n    }\n\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {\n        vm.assertApproxEqAbs(left, right, maxDelta, err);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);\n    }\n\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)\n        internal\n        pure\n        virtual\n    {\n        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta);\n    }\n\n    function assertApproxEqRel(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRel(left, right, maxPercentDelta, err);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);\n    }\n\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        uint256 decimals,\n        string memory err\n    ) internal pure virtual {\n        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);\n    }\n\n    // Inherited from DSTest, not used but kept for backwards-compatibility\n    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {\n        return keccak256(left) == keccak256(right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertEq(left, right);\n    }\n\n    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertEq(left, right, err);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {\n        assertNotEq(left, right);\n    }\n\n    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {\n        assertNotEq(left, right, err);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\n        assertEqCall(target, callDataA, target, callDataB, true);\n    }\n\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\n        internal\n        virtual\n    {\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\n    }\n\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\n        internal\n        virtual\n    {\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\n    }\n\n    function assertEqCall(\n        address targetA,\n        bytes memory callDataA,\n        address targetB,\n        bytes memory callDataB,\n        bool strictRevertData\n    ) internal virtual {\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\n\n        if (successA && successB) {\n            assertEq(returnDataA, returnDataB, \"Call return data does not match\");\n        }\n\n        if (!successA && !successB && strictRevertData) {\n            assertEq(returnDataA, returnDataB, \"Call revert data does not match\");\n        }\n\n        if (!successA && successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call revert data\", returnDataA);\n            emit log_named_bytes(\" Right call return data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n\n        if (successA && !successB) {\n            emit log(\"Error: Calls were not equal\");\n            emit log_named_bytes(\"  Left call return data\", returnDataA);\n            emit log_named_bytes(\" Right call revert data\", returnDataB);\n            revert(\"assertion failed\");\n        }\n    }\n}\n"
    },
    "lib/forge-std/src/StdChains.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n/**\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\n * alias used in this contract, which can be found as the first argument to the\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\n *\n * There are two main ways to use this contract:\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\n *      `setChain(string memory chainAlias, Chain memory chain)`\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\n *\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\n * `defaultRpcUrls`.\n *\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\n *\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\n * we want to retrieve the RPC URL for `mainnet`:\n *   - If you have specified data with `setChain`, it will return that.\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\n *   - If neither of the above conditions is met, the default data is returned.\n *\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\n */\nabstract contract StdChains {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    bool private stdChainsInitialized;\n\n    struct ChainData {\n        string name;\n        uint256 chainId;\n        string rpcUrl;\n    }\n\n    struct Chain {\n        // The chain name.\n        string name;\n        // The chain's Chain ID.\n        uint256 chainId;\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\n        string chainAlias;\n        // A default RPC endpoint for this chain.\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\n        string rpcUrl;\n    }\n\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\n    mapping(string => Chain) private chains;\n    // Maps from the chain's alias to it's default RPC URL.\n    mapping(string => string) private defaultRpcUrls;\n    // Maps from a chain ID to it's alias.\n    mapping(uint256 => string) private idToAlias;\n\n    bool private fallbackToDefaultRpcUrls = true;\n\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\n        require(bytes(chainAlias).length != 0, \"StdChains getChain(string): Chain alias cannot be the empty string.\");\n\n        initializeStdChains();\n        chain = chains[chainAlias];\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(string): Chain with alias \\\"\", chainAlias, \"\\\" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\n        require(chainId != 0, \"StdChains getChain(uint256): Chain ID cannot be 0.\");\n        initializeStdChains();\n        string memory chainAlias = idToAlias[chainId];\n\n        chain = chains[chainAlias];\n\n        require(\n            chain.chainId != 0,\n            string(abi.encodePacked(\"StdChains getChain(uint256): Chain with ID \", vm.toString(chainId), \" not found.\"))\n        );\n\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\n        require(\n            bytes(chainAlias).length != 0,\n            \"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\"\n        );\n\n        require(chain.chainId != 0, \"StdChains setChain(string,ChainData): Chain ID cannot be 0.\");\n\n        initializeStdChains();\n        string memory foundAlias = idToAlias[chain.chainId];\n\n        require(\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\n            string(\n                abi.encodePacked(\n                    \"StdChains setChain(string,ChainData): Chain ID \",\n                    vm.toString(chain.chainId),\n                    \" already used by \\\"\",\n                    foundAlias,\n                    \"\\\".\"\n                )\n            )\n        );\n\n        uint256 oldChainId = chains[chainAlias].chainId;\n        delete idToAlias[oldChainId];\n\n        chains[chainAlias] =\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\n        idToAlias[chain.chainId] = chainAlias;\n    }\n\n    // set chain info, with priority to argument's rpcUrl field.\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\n    }\n\n    function _toUpper(string memory str) private pure returns (string memory) {\n        bytes memory strb = bytes(str);\n        bytes memory copy = new bytes(strb.length);\n        for (uint256 i = 0; i < strb.length; i++) {\n            bytes1 b = strb[i];\n            if (b >= 0x61 && b <= 0x7A) {\n                copy[i] = bytes1(uint8(b) - 32);\n            } else {\n                copy[i] = b;\n            }\n        }\n        return string(copy);\n    }\n\n    // lookup rpcUrl, in descending order of priority:\n    // current -> config (foundry.toml) -> environment variable -> default\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)\n        private\n        view\n        returns (Chain memory)\n    {\n        if (bytes(chain.rpcUrl).length == 0) {\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\n                chain.rpcUrl = configRpcUrl;\n            } catch (bytes memory err) {\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \"_RPC_URL\"));\n                if (fallbackToDefaultRpcUrls) {\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\n                } else {\n                    chain.rpcUrl = vm.envString(envName);\n                }\n                // Distinguish 'not found' from 'cannot read'\n                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions\n                bytes memory oldNotFoundError =\n                    abi.encodeWithSignature(\"CheatCodeError\", string(abi.encodePacked(\"invalid rpc url \", chainAlias)));\n                bytes memory newNotFoundError = abi.encodeWithSignature(\n                    \"CheatcodeError(string)\", string(abi.encodePacked(\"invalid rpc url: \", chainAlias))\n                );\n                bytes32 errHash = keccak256(err);\n                if (\n                    (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))\n                        || bytes(chain.rpcUrl).length == 0\n                ) {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, err), mload(err))\n                    }\n                }\n            }\n        }\n        return chain;\n    }\n\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\n        fallbackToDefaultRpcUrls = useDefault;\n    }\n\n    function initializeStdChains() private {\n        if (stdChainsInitialized) return;\n\n        stdChainsInitialized = true;\n\n        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`\n        setChainWithDefaultRpcUrl(\"anvil\", ChainData(\"Anvil\", 31337, \"http://127.0.0.1:8545\"));\n        setChainWithDefaultRpcUrl(\n            \"mainnet\", ChainData(\"Mainnet\", 1, \"https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"sepolia\", ChainData(\"Sepolia\", 11155111, \"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\")\n        );\n        setChainWithDefaultRpcUrl(\"holesky\", ChainData(\"Holesky\", 17000, \"https://rpc.holesky.ethpandaops.io\"));\n        setChainWithDefaultRpcUrl(\"optimism\", ChainData(\"Optimism\", 10, \"https://mainnet.optimism.io\"));\n        setChainWithDefaultRpcUrl(\n            \"optimism_sepolia\", ChainData(\"Optimism Sepolia\", 11155420, \"https://sepolia.optimism.io\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_one\", ChainData(\"Arbitrum One\", 42161, \"https://arb1.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"arbitrum_one_sepolia\", ChainData(\"Arbitrum One Sepolia\", 421614, \"https://sepolia-rollup.arbitrum.io/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\"arbitrum_nova\", ChainData(\"Arbitrum Nova\", 42170, \"https://nova.arbitrum.io/rpc\"));\n        setChainWithDefaultRpcUrl(\"polygon\", ChainData(\"Polygon\", 137, \"https://polygon-rpc.com\"));\n        setChainWithDefaultRpcUrl(\n            \"polygon_amoy\", ChainData(\"Polygon Amoy\", 80002, \"https://rpc-amoy.polygon.technology\")\n        );\n        setChainWithDefaultRpcUrl(\"avalanche\", ChainData(\"Avalanche\", 43114, \"https://api.avax.network/ext/bc/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"avalanche_fuji\", ChainData(\"Avalanche Fuji\", 43113, \"https://api.avax-test.network/ext/bc/C/rpc\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain\", ChainData(\"BNB Smart Chain\", 56, \"https://bsc-dataseed1.binance.org\")\n        );\n        setChainWithDefaultRpcUrl(\n            \"bnb_smart_chain_testnet\",\n            ChainData(\"BNB Smart Chain Testnet\", 97, \"https://rpc.ankr.com/bsc_testnet_chapel\")\n        );\n        setChainWithDefaultRpcUrl(\"gnosis_chain\", ChainData(\"Gnosis Chain\", 100, \"https://rpc.gnosischain.com\"));\n        setChainWithDefaultRpcUrl(\"moonbeam\", ChainData(\"Moonbeam\", 1284, \"https://rpc.api.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\n            \"moonriver\", ChainData(\"Moonriver\", 1285, \"https://rpc.api.moonriver.moonbeam.network\")\n        );\n        setChainWithDefaultRpcUrl(\"moonbase\", ChainData(\"Moonbase\", 1287, \"https://rpc.testnet.moonbeam.network\"));\n        setChainWithDefaultRpcUrl(\"base_sepolia\", ChainData(\"Base Sepolia\", 84532, \"https://sepolia.base.org\"));\n        setChainWithDefaultRpcUrl(\"base\", ChainData(\"Base\", 8453, \"https://mainnet.base.org\"));\n        setChainWithDefaultRpcUrl(\"blast_sepolia\", ChainData(\"Blast Sepolia\", 168587773, \"https://sepolia.blast.io\"));\n        setChainWithDefaultRpcUrl(\"blast\", ChainData(\"Blast\", 81457, \"https://rpc.blast.io\"));\n        setChainWithDefaultRpcUrl(\"fantom_opera\", ChainData(\"Fantom Opera\", 250, \"https://rpc.ankr.com/fantom/\"));\n        setChainWithDefaultRpcUrl(\n            \"fantom_opera_testnet\", ChainData(\"Fantom Opera Testnet\", 4002, \"https://rpc.ankr.com/fantom_testnet/\")\n        );\n        setChainWithDefaultRpcUrl(\"fraxtal\", ChainData(\"Fraxtal\", 252, \"https://rpc.frax.com\"));\n        setChainWithDefaultRpcUrl(\"fraxtal_testnet\", ChainData(\"Fraxtal Testnet\", 2522, \"https://rpc.testnet.frax.com\"));\n        setChainWithDefaultRpcUrl(\n            \"berachain_bartio_testnet\", ChainData(\"Berachain bArtio Testnet\", 80084, \"https://bartio.rpc.berachain.com\")\n        );\n        setChainWithDefaultRpcUrl(\"flare\", ChainData(\"Flare\", 14, \"https://flare-api.flare.network/ext/C/rpc\"));\n        setChainWithDefaultRpcUrl(\n            \"flare_coston2\", ChainData(\"Flare Coston2\", 114, \"https://coston2-api.flare.network/ext/C/rpc\")\n        );\n    }\n\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\n        string memory rpcUrl = chain.rpcUrl;\n        defaultRpcUrls[chainAlias] = rpcUrl;\n        chain.rpcUrl = \"\";\n        setChain(chainAlias, chain);\n        chain.rpcUrl = rpcUrl; // restore argument\n    }\n}\n"
    },
    "lib/forge-std/src/StdCheats.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {console2} from \"./console2.sol\";\nimport {Vm} from \"./Vm.sol\";\n\nabstract contract StdCheatsSafe {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    bool private gasMeteringOff;\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawTx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        // json value name = function\n        string functionSig;\n        bytes32 hash;\n        // json value name = tx\n        RawTx1559Detail txDetail;\n        // json value name = type\n        string opcode;\n    }\n\n    struct RawTx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        bytes gas;\n        bytes nonce;\n        address to;\n        bytes txType;\n        bytes value;\n    }\n\n    struct Tx1559 {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        bytes32 hash;\n        Tx1559Detail txDetail;\n        string opcode;\n    }\n\n    struct Tx1559Detail {\n        AccessList[] accessList;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 nonce;\n        address to;\n        uint256 txType;\n        uint256 value;\n    }\n\n    // Data structures to parse Transaction objects from the broadcast artifact\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct TxLegacy {\n        string[] arguments;\n        address contractAddress;\n        string contractName;\n        string functionSig;\n        string hash;\n        string opcode;\n        TxDetailLegacy transaction;\n    }\n\n    struct TxDetailLegacy {\n        AccessList[] accessList;\n        uint256 chainId;\n        bytes data;\n        address from;\n        uint256 gas;\n        uint256 gasPrice;\n        bytes32 hash;\n        uint256 nonce;\n        bytes1 opcode;\n        bytes32 r;\n        bytes32 s;\n        uint256 txType;\n        address to;\n        uint8 v;\n        uint256 value;\n    }\n\n    struct AccessList {\n        address accessAddress;\n        bytes32[] storageKeys;\n    }\n\n    // Data structures to parse Receipt objects from the broadcast artifact.\n    // The Raw structs is what is parsed from the JSON\n    // and then converted to the one that is used by the user for better UX.\n\n    struct RawReceipt {\n        bytes32 blockHash;\n        bytes blockNumber;\n        address contractAddress;\n        bytes cumulativeGasUsed;\n        bytes effectiveGasPrice;\n        address from;\n        bytes gasUsed;\n        RawReceiptLog[] logs;\n        bytes logsBloom;\n        bytes status;\n        address to;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n    }\n\n    struct Receipt {\n        bytes32 blockHash;\n        uint256 blockNumber;\n        address contractAddress;\n        uint256 cumulativeGasUsed;\n        uint256 effectiveGasPrice;\n        address from;\n        uint256 gasUsed;\n        ReceiptLog[] logs;\n        bytes logsBloom;\n        uint256 status;\n        address to;\n        bytes32 transactionHash;\n        uint256 transactionIndex;\n    }\n\n    // Data structures to parse the entire broadcast artifact, assuming the\n    // transactions conform to EIP1559.\n\n    struct EIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        Receipt[] receipts;\n        uint256 timestamp;\n        Tx1559[] transactions;\n        TxReturn[] txReturns;\n    }\n\n    struct RawEIP1559ScriptArtifact {\n        string[] libraries;\n        string path;\n        string[] pending;\n        RawReceipt[] receipts;\n        TxReturn[] txReturns;\n        uint256 timestamp;\n        RawTx1559[] transactions;\n    }\n\n    struct RawReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        bytes blockNumber;\n        bytes data;\n        bytes logIndex;\n        bool removed;\n        bytes32[] topics;\n        bytes32 transactionHash;\n        bytes transactionIndex;\n        bytes transactionLogIndex;\n    }\n\n    struct ReceiptLog {\n        // json value = address\n        address logAddress;\n        bytes32 blockHash;\n        uint256 blockNumber;\n        bytes data;\n        uint256 logIndex;\n        bytes32[] topics;\n        uint256 transactionIndex;\n        uint256 transactionLogIndex;\n        bool removed;\n    }\n\n    struct TxReturn {\n        string internalType;\n        string value;\n    }\n\n    struct Account {\n        address addr;\n        uint256 key;\n    }\n\n    enum AddressType {\n        Payable,\n        NonPayable,\n        ZeroAddress,\n        Precompile,\n        ForgeAddress\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\n        // Nothing to check if `token` is not a contract.\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\");\n\n        bool success;\n        bytes memory returnData;\n\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\n    }\n\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\n    // backwards compatibility, since this name was used in the original PR which already has\n    // a release. This function can be removed in a future release once we want a breaking change.\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\n        assumeNotBlacklisted(token, addr);\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\n        if (addressType == AddressType.Payable) {\n            assumeNotPayable(addr);\n        } else if (addressType == AddressType.NonPayable) {\n            assumePayable(addr);\n        } else if (addressType == AddressType.ZeroAddress) {\n            assumeNotZeroAddress(addr);\n        } else if (addressType == AddressType.Precompile) {\n            assumeNotPrecompile(addr);\n        } else if (addressType == AddressType.ForgeAddress) {\n            assumeNotForgeAddress(addr);\n        }\n    }\n\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n    }\n\n    function assumeAddressIsNot(\n        address addr,\n        AddressType addressType1,\n        AddressType addressType2,\n        AddressType addressType3,\n        AddressType addressType4\n    ) internal virtual {\n        assumeAddressIsNot(addr, addressType1);\n        assumeAddressIsNot(addr, addressType2);\n        assumeAddressIsNot(addr, addressType3);\n        assumeAddressIsNot(addr, addressType4);\n    }\n\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\n    // `addr` and checking the `success` return value.\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used.\n    function _isPayable(address addr) private returns (bool) {\n        require(\n            addr.balance < UINT256_MAX,\n            \"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\"\n        );\n        uint256 origBalanceTest = address(this).balance;\n        uint256 origBalanceAddr = address(addr).balance;\n\n        vm.deal(address(this), 1);\n        (bool success,) = payable(addr).call{value: 1}(\"\");\n\n        // reset balances\n        vm.deal(address(this), origBalanceTest);\n        vm.deal(addr, origBalanceAddr);\n\n        return success;\n    }\n\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\n    // implemented by `addr`, which should be taken into account when this function is used. See the\n    // `_isPayable` method for more information.\n    function assumePayable(address addr) internal virtual {\n        vm.assume(_isPayable(addr));\n    }\n\n    function assumeNotPayable(address addr) internal virtual {\n        vm.assume(!_isPayable(addr));\n    }\n\n    function assumeNotZeroAddress(address addr) internal pure virtual {\n        vm.assume(addr != address(0));\n    }\n\n    function assumeNotPrecompile(address addr) internal pure virtual {\n        assumeNotPrecompile(addr, _pureChainId());\n    }\n\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\n        // address), but the same rationale for excluding them applies so we include those too.\n\n        // These are reserved by Ethereum and may be on all EVM-compatible chains.\n        vm.assume(addr < address(0x1) || addr > address(0xff));\n\n        // forgefmt: disable-start\n        if (chainId == 10 || chainId == 420) {\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\n        } else if (chainId == 42161 || chainId == 421613) {\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\n        } else if (chainId == 43114 || chainId == 43113) {\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\n        }\n        // forgefmt: disable-end\n    }\n\n    function assumeNotForgeAddress(address addr) internal pure virtual {\n        // vm, console, and Create2Deployer addresses\n        vm.assume(\n            addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67\n                && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C\n        );\n    }\n\n    function readEIP1559ScriptArtifact(string memory path)\n        internal\n        view\n        virtual\n        returns (EIP1559ScriptArtifact memory)\n    {\n        string memory data = vm.readFile(path);\n        bytes memory parsedData = vm.parseJson(data);\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\n        EIP1559ScriptArtifact memory artifact;\n        artifact.libraries = rawArtifact.libraries;\n        artifact.path = rawArtifact.path;\n        artifact.timestamp = rawArtifact.timestamp;\n        artifact.pending = rawArtifact.pending;\n        artifact.txReturns = rawArtifact.txReturns;\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\n        return artifact;\n    }\n\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\n        for (uint256 i; i < rawTxs.length; i++) {\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\n        }\n        return txs;\n    }\n\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\n        Tx1559 memory transaction;\n        transaction.arguments = rawTx.arguments;\n        transaction.contractName = rawTx.contractName;\n        transaction.functionSig = rawTx.functionSig;\n        transaction.hash = rawTx.hash;\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\n        transaction.opcode = rawTx.opcode;\n        return transaction;\n    }\n\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\n        internal\n        pure\n        virtual\n        returns (Tx1559Detail memory)\n    {\n        Tx1559Detail memory txDetail;\n        txDetail.data = rawDetail.data;\n        txDetail.from = rawDetail.from;\n        txDetail.to = rawDetail.to;\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\n        txDetail.txType = _bytesToUint(rawDetail.txType);\n        txDetail.value = _bytesToUint(rawDetail.value);\n        txDetail.gas = _bytesToUint(rawDetail.gas);\n        txDetail.accessList = rawDetail.accessList;\n        return txDetail;\n    }\n\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".transactions\");\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\n        return rawToConvertedEIPTx1559s(rawTxs);\n    }\n\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".transactions[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\n        return rawToConvertedEIPTx1559(rawTx);\n    }\n\n    // Analogous to readTransactions, but for receipts.\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\n        string memory deployData = vm.readFile(path);\n        bytes memory parsedDeployData = vm.parseJson(deployData, \".receipts\");\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\n        return rawToConvertedReceipts(rawReceipts);\n    }\n\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\n        string memory deployData = vm.readFile(path);\n        string memory key = string(abi.encodePacked(\".receipts[\", vm.toString(index), \"]\"));\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\n        return rawToConvertedReceipt(rawReceipt);\n    }\n\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\n        for (uint256 i; i < rawReceipts.length; i++) {\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\n        }\n        return receipts;\n    }\n\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\n        Receipt memory receipt;\n        receipt.blockHash = rawReceipt.blockHash;\n        receipt.to = rawReceipt.to;\n        receipt.from = rawReceipt.from;\n        receipt.contractAddress = rawReceipt.contractAddress;\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\n        receipt.status = _bytesToUint(rawReceipt.status);\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\n        receipt.logsBloom = rawReceipt.logsBloom;\n        receipt.transactionHash = rawReceipt.transactionHash;\n        return receipt;\n    }\n\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\n        internal\n        pure\n        virtual\n        returns (ReceiptLog[] memory)\n    {\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\n        for (uint256 i; i < rawLogs.length; i++) {\n            logs[i].logAddress = rawLogs[i].logAddress;\n            logs[i].blockHash = rawLogs[i].blockHash;\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\n            logs[i].data = rawLogs[i].data;\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\n            logs[i].topics = rawLogs[i].topics;\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\n            logs[i].removed = rawLogs[i].removed;\n        }\n        return logs;\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes): Deployment failed.\");\n    }\n\n    function deployCode(string memory what) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string): Deployment failed.\");\n    }\n\n    /// @dev deploy contract with value on construction\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,bytes,uint256): Deployment failed.\");\n    }\n\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(addr != address(0), \"StdCheats deployCode(string,uint256): Deployment failed.\");\n    }\n\n    // creates a labeled address and the corresponding private key\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\n        addr = vm.addr(privateKey);\n        vm.label(addr, name);\n    }\n\n    // creates a labeled address\n    function makeAddr(string memory name) internal virtual returns (address addr) {\n        (addr,) = makeAddrAndKey(name);\n    }\n\n    // Destroys an account immediately, sending the balance to beneficiary.\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\n    // only after tx ends, this will run immediately.\n    function destroyAccount(address who, address beneficiary) internal virtual {\n        uint256 currBalance = who.balance;\n        vm.etch(who, abi.encode());\n        vm.deal(who, 0);\n        vm.resetNonce(who);\n\n        uint256 beneficiaryBalance = beneficiary.balance;\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\n    }\n\n    // creates a struct containing both a labeled address and the corresponding private key\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\n        (account.addr, account.key) = makeAddrAndKey(name);\n    }\n\n    function deriveRememberKey(string memory mnemonic, uint32 index)\n        internal\n        virtual\n        returns (address who, uint256 privateKey)\n    {\n        privateKey = vm.deriveKey(mnemonic, index);\n        who = vm.rememberKey(privateKey);\n    }\n\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\n        require(b.length <= 32, \"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    function isFork() internal view virtual returns (bool status) {\n        try vm.activeFork() {\n            status = true;\n        } catch (bytes memory) {}\n    }\n\n    modifier skipWhenForking() {\n        if (!isFork()) {\n            _;\n        }\n    }\n\n    modifier skipWhenNotForking() {\n        if (isFork()) {\n            _;\n        }\n    }\n\n    modifier noGasMetering() {\n        vm.pauseGasMetering();\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\n        // it back on until we exit the top level function that used the modifier\n        //\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\n        // so we only turn metering back on at the end of the funcA\n        bool gasStartedOff = gasMeteringOff;\n        gasMeteringOff = true;\n\n        _;\n\n        // if gas metering was on when this modifier was called, turn it back on at the end\n        if (!gasStartedOff) {\n            gasMeteringOff = false;\n            vm.resumeGasMetering();\n        }\n    }\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n\n// Wrappers around cheatcodes to avoid footguns\nabstract contract StdCheats is StdCheatsSafe {\n    using stdStorage for StdStorage;\n\n    StdStorage private stdstore;\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) internal virtual {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) internal virtual {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender);\n    }\n\n    function hoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.prank(msgSender, origin);\n    }\n\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.prank(msgSender, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address msgSender) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender);\n    }\n\n    function startHoax(address msgSender, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address msgSender, address origin) internal virtual {\n        vm.deal(msgSender, 1 << 128);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\n        vm.deal(msgSender, give);\n        vm.startPrank(msgSender, origin);\n    }\n\n    function changePrank(address msgSender) internal virtual {\n        console2_log_StdCheats(\"changePrank is deprecated. Please use vm.startPrank instead.\");\n        vm.stopPrank();\n        vm.startPrank(msgSender);\n    }\n\n    function changePrank(address msgSender, address txOrigin) internal virtual {\n        vm.stopPrank();\n        vm.startPrank(msgSender, txOrigin);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) internal virtual {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) internal virtual {\n        deal(token, to, give, false);\n    }\n\n    // Set the balance of an account for any ERC1155 token\n    // Use the alternative signature to update `totalSupply`\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\n        dealERC1155(token, to, id, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\n        }\n    }\n\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\n        // get current balance\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\n\n        // update total supply\n        if (adjust) {\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\n            require(\n                totSupData.length != 0,\n                \"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\"\n            );\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if (give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\n        }\n    }\n\n    function dealERC721(address token, address to, uint256 id) internal virtual {\n        // check if token id is already minted and the actual owner.\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\n        require(successMinted, \"StdCheats deal(address,address,uint,bool): id not minted.\");\n\n        // get owner current balance\n        (, bytes memory fromBalData) =\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\n\n        // get new user current balance\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\n\n        // update balances\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\n\n        // update owner\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\n    }\n\n    function deployCodeTo(string memory what, address where) internal virtual {\n        deployCodeTo(what, \"\", 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\n        deployCodeTo(what, args, 0, where);\n    }\n\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\n        bytes memory creationCode = vm.getCode(what);\n        vm.etch(where, abi.encodePacked(creationCode, args));\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\"\");\n        require(success, \"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\");\n        vm.etch(where, runtimeBytecode);\n    }\n\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\n    function console2_log_StdCheats(string memory p0) private view {\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\"log(string)\", p0));\n        status;\n    }\n}\n"
    },
    "lib/forge-std/src/StdError.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n}\n"
    },
    "lib/forge-std/src/StdInvariant.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nabstract contract StdInvariant {\n    struct FuzzSelector {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    struct FuzzArtifactSelector {\n        string artifact;\n        bytes4[] selectors;\n    }\n\n    struct FuzzInterface {\n        address addr;\n        string[] artifacts;\n    }\n\n    address[] private _excludedContracts;\n    address[] private _excludedSenders;\n    address[] private _targetedContracts;\n    address[] private _targetedSenders;\n\n    string[] private _excludedArtifacts;\n    string[] private _targetedArtifacts;\n\n    FuzzArtifactSelector[] private _targetedArtifactSelectors;\n\n    FuzzSelector[] private _excludedSelectors;\n    FuzzSelector[] private _targetedSelectors;\n\n    FuzzInterface[] private _targetedInterfaces;\n\n    // Functions for users:\n    // These are intended to be called in tests.\n\n    function excludeContract(address newExcludedContract_) internal {\n        _excludedContracts.push(newExcludedContract_);\n    }\n\n    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {\n        _excludedSelectors.push(newExcludedSelector_);\n    }\n\n    function excludeSender(address newExcludedSender_) internal {\n        _excludedSenders.push(newExcludedSender_);\n    }\n\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\n        _excludedArtifacts.push(newExcludedArtifact_);\n    }\n\n    function targetArtifact(string memory newTargetedArtifact_) internal {\n        _targetedArtifacts.push(newTargetedArtifact_);\n    }\n\n    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\n    }\n\n    function targetContract(address newTargetedContract_) internal {\n        _targetedContracts.push(newTargetedContract_);\n    }\n\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\n        _targetedSelectors.push(newTargetedSelector_);\n    }\n\n    function targetSender(address newTargetedSender_) internal {\n        _targetedSenders.push(newTargetedSender_);\n    }\n\n    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {\n        _targetedInterfaces.push(newTargetedInterface_);\n    }\n\n    // Functions for forge:\n    // These are called by forge to run invariant tests and don't need to be called in tests.\n\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\n        excludedArtifacts_ = _excludedArtifacts;\n    }\n\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\n        excludedContracts_ = _excludedContracts;\n    }\n\n    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {\n        excludedSelectors_ = _excludedSelectors;\n    }\n\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\n        excludedSenders_ = _excludedSenders;\n    }\n\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\n        targetedArtifacts_ = _targetedArtifacts;\n    }\n\n    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\n    }\n\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\n        targetedContracts_ = _targetedContracts;\n    }\n\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\n        targetedSelectors_ = _targetedSelectors;\n    }\n\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\n        targetedSenders_ = _targetedSenders;\n    }\n\n    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {\n        targetedInterfaces_ = _targetedInterfaces;\n    }\n}\n"
    },
    "lib/forge-std/src/StdJson.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing JSON files\n// To parse:\n// ```\n// using stdJson for string;\n// string memory json = vm.readFile(\"<some_path>\");\n// json.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdJson for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdJson {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory json, string memory key) internal view returns (bool) {\n        return vm.keyExistsJson(json, key);\n    }\n\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJson(json, key);\n    }\n\n    function readUint(string memory json, string memory key) internal pure returns (uint256) {\n        return vm.parseJsonUint(json, key);\n    }\n\n    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseJsonUintArray(json, key);\n    }\n\n    function readInt(string memory json, string memory key) internal pure returns (int256) {\n        return vm.parseJsonInt(json, key);\n    }\n\n    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseJsonIntArray(json, key);\n    }\n\n    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {\n        return vm.parseJsonBytes32(json, key);\n    }\n\n    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseJsonBytes32Array(json, key);\n    }\n\n    function readString(string memory json, string memory key) internal pure returns (string memory) {\n        return vm.parseJsonString(json, key);\n    }\n\n    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {\n        return vm.parseJsonStringArray(json, key);\n    }\n\n    function readAddress(string memory json, string memory key) internal pure returns (address) {\n        return vm.parseJsonAddress(json, key);\n    }\n\n    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {\n        return vm.parseJsonAddressArray(json, key);\n    }\n\n    function readBool(string memory json, string memory key) internal pure returns (bool) {\n        return vm.parseJsonBool(json, key);\n    }\n\n    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseJsonBoolArray(json, key);\n    }\n\n    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {\n        return vm.parseJsonBytes(json, key);\n    }\n\n    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseJsonBytesArray(json, key);\n    }\n\n    function readUintOr(string memory json, string memory key, uint256 defaultValue) internal view returns (uint256) {\n        return keyExists(json, key) ? readUint(json, key) : defaultValue;\n    }\n\n    function readUintArrayOr(string memory json, string memory key, uint256[] memory defaultValue)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return keyExists(json, key) ? readUintArray(json, key) : defaultValue;\n    }\n\n    function readIntOr(string memory json, string memory key, int256 defaultValue) internal view returns (int256) {\n        return keyExists(json, key) ? readInt(json, key) : defaultValue;\n    }\n\n    function readIntArrayOr(string memory json, string memory key, int256[] memory defaultValue)\n        internal\n        view\n        returns (int256[] memory)\n    {\n        return keyExists(json, key) ? readIntArray(json, key) : defaultValue;\n    }\n\n    function readBytes32Or(string memory json, string memory key, bytes32 defaultValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keyExists(json, key) ? readBytes32(json, key) : defaultValue;\n    }\n\n    function readBytes32ArrayOr(string memory json, string memory key, bytes32[] memory defaultValue)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return keyExists(json, key) ? readBytes32Array(json, key) : defaultValue;\n    }\n\n    function readStringOr(string memory json, string memory key, string memory defaultValue)\n        internal\n        view\n        returns (string memory)\n    {\n        return keyExists(json, key) ? readString(json, key) : defaultValue;\n    }\n\n    function readStringArrayOr(string memory json, string memory key, string[] memory defaultValue)\n        internal\n        view\n        returns (string[] memory)\n    {\n        return keyExists(json, key) ? readStringArray(json, key) : defaultValue;\n    }\n\n    function readAddressOr(string memory json, string memory key, address defaultValue)\n        internal\n        view\n        returns (address)\n    {\n        return keyExists(json, key) ? readAddress(json, key) : defaultValue;\n    }\n\n    function readAddressArrayOr(string memory json, string memory key, address[] memory defaultValue)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return keyExists(json, key) ? readAddressArray(json, key) : defaultValue;\n    }\n\n    function readBoolOr(string memory json, string memory key, bool defaultValue) internal view returns (bool) {\n        return keyExists(json, key) ? readBool(json, key) : defaultValue;\n    }\n\n    function readBoolArrayOr(string memory json, string memory key, bool[] memory defaultValue)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        return keyExists(json, key) ? readBoolArray(json, key) : defaultValue;\n    }\n\n    function readBytesOr(string memory json, string memory key, bytes memory defaultValue)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return keyExists(json, key) ? readBytes(json, key) : defaultValue;\n    }\n\n    function readBytesArrayOr(string memory json, string memory key, bytes[] memory defaultValue)\n        internal\n        view\n        returns (bytes[] memory)\n    {\n        return keyExists(json, key) ? readBytesArray(json, key) : defaultValue;\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeJson(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeJson(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "lib/forge-std/src/StdMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN) {\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n        }\n\n        return uint256(a > 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        // this works thanks to two's complement, the left-most bit is the sign bit\n        if ((a ^ b) > -1) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "lib/forge-std/src/StdStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {Vm} from \"./Vm.sol\";\n\nstruct FindData {\n    uint256 slot;\n    uint256 offsetLeft;\n    uint256 offsetRight;\n    bool found;\n}\n\nstruct StdStorage {\n    mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n    bool _enable_packed_slots;\n    bytes _calldata;\n}\n\nlibrary stdStorageSafe {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\n    event WARNING_UninitedSlot(address who, uint256 slot);\n\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {\n        if (self._calldata.length == 0) {\n            return flatten(self._keys);\n        } else {\n            return self._calldata;\n        }\n    }\n\n    // Calls target contract with configured parameters\n    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {\n        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));\n        (bool success, bytes memory rdat) = self._target.staticcall(cald);\n        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);\n\n        return (success, result);\n    }\n\n    // Tries mutating slot value to determine if the targeted value is stored in it.\n    // If current value is 0, then we are setting slot value to type(uint256).max\n    // Otherwise, we set it to 0. That way, return value should always be affected.\n    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n        (bool success, bytes32 prevReturnValue) = callTarget(self);\n\n        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);\n        vm.store(self._target, slot, testVal);\n\n        (, bytes32 newReturnValue) = callTarget(self);\n\n        vm.store(self._target, slot, prevSlotValue);\n\n        return (success && (prevReturnValue != newReturnValue));\n    }\n\n    // Tries setting one of the bits in slot to 1 until return value changes.\n    // Index of resulted bit is an offset packed slot has from left/right side\n    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {\n        for (uint256 offset = 0; offset < 256; offset++) {\n            uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);\n            vm.store(self._target, slot, bytes32(valueToPut));\n\n            (bool success, bytes32 data) = callTarget(self);\n\n            if (success && (uint256(data) > 0)) {\n                return (true, offset);\n            }\n        }\n        return (false, 0);\n    }\n\n    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {\n        bytes32 prevSlotValue = vm.load(self._target, slot);\n\n        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);\n        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);\n\n        // `findOffset` may mutate slot value, so we are setting it to initial value\n        vm.store(self._target, slot, prevSlotValue);\n        return (foundLeft && foundRight, offsetLeft, offsetRight);\n    }\n\n    function find(StdStorage storage self) internal returns (FindData storage) {\n        return find(self, true);\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = getCallParams(self);\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            if (_clear) {\n                clear(self);\n            }\n            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        }\n        vm.record();\n        (, bytes32 callResult) = callTarget(self);\n        (bytes32[] memory reads,) = vm.accesses(address(who));\n\n        if (reads.length == 0) {\n            revert(\"stdStorage find(StdStorage): No storage use detected for target.\");\n        } else {\n            for (uint256 i = reads.length; --i >= 0;) {\n                bytes32 prev = vm.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n\n                if (!checkSlotMutatesCall(self, reads[i])) {\n                    continue;\n                }\n\n                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);\n\n                if (self._enable_packed_slots) {\n                    bool found;\n                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);\n                    if (!found) {\n                        continue;\n                    }\n                }\n\n                // Check that value between found offsets is equal to the current call result\n                uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;\n\n                if (uint256(callResult) != curVal) {\n                    continue;\n                }\n\n                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));\n                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =\n                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);\n                break;\n            }\n        }\n\n        require(\n            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,\n            \"stdStorage find(StdStorage): Slot(s) not found.\"\n        );\n\n        if (_clear) {\n            clear(self);\n        }\n        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        self._calldata = _calldata;\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        self._enable_packed_slots = true;\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        FindData storage data = find(self, false);\n        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);\n        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;\n        clear(self);\n        return abi.encode(value);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        return (uint256(parent_slot), key);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        address who = self._target;\n        uint256 field_depth = self._depth;\n        vm.startMappingRecording();\n        uint256 child = find(self, true).slot - field_depth;\n        bool found;\n        bytes32 root_slot;\n        bytes32 parent_slot;\n        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));\n        if (!found) {\n            revert(\n                \"stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.\"\n            );\n        }\n        while (found) {\n            root_slot = parent_slot;\n            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));\n        }\n        return uint256(root_slot);\n    }\n\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint256 i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n\n    function clear(StdStorage storage self) internal {\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n        delete self._enable_packed_slots;\n        delete self._calldata;\n    }\n\n    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`\n    // (slotValue & mask) >> offsetRight will be the value of the given packed variable\n    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {\n        // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;\n        // using assembly because (1 << 256) causes overflow\n        assembly {\n            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))\n        }\n    }\n\n    // Returns slot value with updated packed variable.\n    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)\n        internal\n        pure\n        returns (bytes32 newValue)\n    {\n        return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));\n    }\n}\n\nlibrary stdStorage {\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\n        return stdStorageSafe.sigs(sigStr);\n    }\n\n    function find(StdStorage storage self) internal returns (uint256) {\n        return find(self, true);\n    }\n\n    function find(StdStorage storage self, bool _clear) internal returns (uint256) {\n        return stdStorageSafe.find(self, _clear).slot;\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        return stdStorageSafe.target(self, _target);\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        return stdStorageSafe.sig(self, _sig);\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, who);\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, amt);\n    }\n\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_key(self, key);\n    }\n\n    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {\n        return stdStorageSafe.with_calldata(self, _calldata);\n    }\n\n    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {\n        return stdStorageSafe.enable_packed_slots(self);\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        return stdStorageSafe.depth(self, _depth);\n    }\n\n    function clear(StdStorage storage self) internal {\n        stdStorageSafe.clear(self);\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write_int(StdStorage storage self, int256 val) internal {\n        checked_write(self, bytes32(uint256(val)));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(StdStorage storage self, bytes32 set) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes memory params = stdStorageSafe.getCallParams(self);\n\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {\n            find(self, false);\n        }\n        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];\n        if ((data.offsetLeft + data.offsetRight) > 0) {\n            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));\n            require(\n                uint256(set) < maxVal,\n                string(\n                    abi.encodePacked(\n                        \"stdStorage find(StdStorage): Packed slot. We can't fit value greater than \",\n                        vm.toString(maxVal)\n                    )\n                )\n            );\n        }\n        bytes32 curVal = vm.load(who, bytes32(data.slot));\n        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);\n\n        vm.store(who, bytes32(data.slot), valToSet);\n\n        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);\n\n        if (!success || callResult != set) {\n            vm.store(who, bytes32(data.slot), curVal);\n            revert(\"stdStorage find(StdStorage): Failed to write value.\");\n        }\n        clear(self);\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return stdStorageSafe.read_bytes32(self);\n    }\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return stdStorageSafe.read_bool(self);\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return stdStorageSafe.read_address(self);\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.read_uint(self);\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return stdStorageSafe.read_int(self);\n    }\n\n    function parent(StdStorage storage self) internal returns (uint256, bytes32) {\n        return stdStorageSafe.parent(self);\n    }\n\n    function root(StdStorage storage self) internal returns (uint256) {\n        return stdStorageSafe.root(self);\n    }\n}\n"
    },
    "lib/forge-std/src/StdStyle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {VmSafe} from \"./Vm.sol\";\n\nlibrary StdStyle {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    string constant RED = \"\\u001b[91m\";\n    string constant GREEN = \"\\u001b[92m\";\n    string constant YELLOW = \"\\u001b[93m\";\n    string constant BLUE = \"\\u001b[94m\";\n    string constant MAGENTA = \"\\u001b[95m\";\n    string constant CYAN = \"\\u001b[96m\";\n    string constant BOLD = \"\\u001b[1m\";\n    string constant DIM = \"\\u001b[2m\";\n    string constant ITALIC = \"\\u001b[3m\";\n    string constant UNDERLINE = \"\\u001b[4m\";\n    string constant INVERSE = \"\\u001b[7m\";\n    string constant RESET = \"\\u001b[0m\";\n\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\n        return string(abi.encodePacked(style, self, RESET));\n    }\n\n    function red(string memory self) internal pure returns (string memory) {\n        return styleConcat(RED, self);\n    }\n\n    function red(uint256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(int256 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(address self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function red(bool self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes(bytes memory self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\n        return red(vm.toString(self));\n    }\n\n    function green(string memory self) internal pure returns (string memory) {\n        return styleConcat(GREEN, self);\n    }\n\n    function green(uint256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(int256 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(address self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function green(bool self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\n        return green(vm.toString(self));\n    }\n\n    function yellow(string memory self) internal pure returns (string memory) {\n        return styleConcat(YELLOW, self);\n    }\n\n    function yellow(uint256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(int256 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(address self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellow(bool self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\n        return yellow(vm.toString(self));\n    }\n\n    function blue(string memory self) internal pure returns (string memory) {\n        return styleConcat(BLUE, self);\n    }\n\n    function blue(uint256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(int256 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(address self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blue(bool self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\n        return blue(vm.toString(self));\n    }\n\n    function magenta(string memory self) internal pure returns (string memory) {\n        return styleConcat(MAGENTA, self);\n    }\n\n    function magenta(uint256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(int256 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(address self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magenta(bool self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\n        return magenta(vm.toString(self));\n    }\n\n    function cyan(string memory self) internal pure returns (string memory) {\n        return styleConcat(CYAN, self);\n    }\n\n    function cyan(uint256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(int256 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(address self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyan(bool self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\n        return cyan(vm.toString(self));\n    }\n\n    function bold(string memory self) internal pure returns (string memory) {\n        return styleConcat(BOLD, self);\n    }\n\n    function bold(uint256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(int256 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(address self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function bold(bool self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\n        return bold(vm.toString(self));\n    }\n\n    function dim(string memory self) internal pure returns (string memory) {\n        return styleConcat(DIM, self);\n    }\n\n    function dim(uint256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(int256 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(address self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dim(bool self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\n        return dim(vm.toString(self));\n    }\n\n    function italic(string memory self) internal pure returns (string memory) {\n        return styleConcat(ITALIC, self);\n    }\n\n    function italic(uint256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(int256 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(address self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italic(bool self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\n        return italic(vm.toString(self));\n    }\n\n    function underline(string memory self) internal pure returns (string memory) {\n        return styleConcat(UNDERLINE, self);\n    }\n\n    function underline(uint256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(int256 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(address self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underline(bool self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\n        return underline(vm.toString(self));\n    }\n\n    function inverse(string memory self) internal pure returns (string memory) {\n        return styleConcat(INVERSE, self);\n    }\n\n    function inverse(uint256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(int256 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(address self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverse(bool self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\n        return inverse(vm.toString(self));\n    }\n}\n"
    },
    "lib/forge-std/src/StdToml.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {VmSafe} from \"./Vm.sol\";\n\n// Helpers for parsing and writing TOML files\n// To parse:\n// ```\n// using stdToml for string;\n// string memory toml = vm.readFile(\"<some_path>\");\n// toml.readUint(\"<json_path>\");\n// ```\n// To write:\n// ```\n// using stdToml for string;\n// string memory json = \"json\";\n// json.serialize(\"a\", uint256(123));\n// string memory semiFinal = json.serialize(\"b\", string(\"test\"));\n// string memory finalJson = json.serialize(\"c\", semiFinal);\n// finalJson.write(\"<some_path>\");\n// ```\n\nlibrary stdToml {\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n\n    function keyExists(string memory toml, string memory key) internal view returns (bool) {\n        return vm.keyExistsToml(toml, key);\n    }\n\n    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseToml(toml, key);\n    }\n\n    function readUint(string memory toml, string memory key) internal pure returns (uint256) {\n        return vm.parseTomlUint(toml, key);\n    }\n\n    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {\n        return vm.parseTomlUintArray(toml, key);\n    }\n\n    function readInt(string memory toml, string memory key) internal pure returns (int256) {\n        return vm.parseTomlInt(toml, key);\n    }\n\n    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {\n        return vm.parseTomlIntArray(toml, key);\n    }\n\n    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {\n        return vm.parseTomlBytes32(toml, key);\n    }\n\n    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {\n        return vm.parseTomlBytes32Array(toml, key);\n    }\n\n    function readString(string memory toml, string memory key) internal pure returns (string memory) {\n        return vm.parseTomlString(toml, key);\n    }\n\n    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {\n        return vm.parseTomlStringArray(toml, key);\n    }\n\n    function readAddress(string memory toml, string memory key) internal pure returns (address) {\n        return vm.parseTomlAddress(toml, key);\n    }\n\n    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {\n        return vm.parseTomlAddressArray(toml, key);\n    }\n\n    function readBool(string memory toml, string memory key) internal pure returns (bool) {\n        return vm.parseTomlBool(toml, key);\n    }\n\n    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {\n        return vm.parseTomlBoolArray(toml, key);\n    }\n\n    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {\n        return vm.parseTomlBytes(toml, key);\n    }\n\n    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {\n        return vm.parseTomlBytesArray(toml, key);\n    }\n\n    function readUintOr(string memory toml, string memory key, uint256 defaultValue) internal view returns (uint256) {\n        return keyExists(toml, key) ? readUint(toml, key) : defaultValue;\n    }\n\n    function readUintArrayOr(string memory toml, string memory key, uint256[] memory defaultValue)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        return keyExists(toml, key) ? readUintArray(toml, key) : defaultValue;\n    }\n\n    function readIntOr(string memory toml, string memory key, int256 defaultValue) internal view returns (int256) {\n        return keyExists(toml, key) ? readInt(toml, key) : defaultValue;\n    }\n\n    function readIntArrayOr(string memory toml, string memory key, int256[] memory defaultValue)\n        internal\n        view\n        returns (int256[] memory)\n    {\n        return keyExists(toml, key) ? readIntArray(toml, key) : defaultValue;\n    }\n\n    function readBytes32Or(string memory toml, string memory key, bytes32 defaultValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keyExists(toml, key) ? readBytes32(toml, key) : defaultValue;\n    }\n\n    function readBytes32ArrayOr(string memory toml, string memory key, bytes32[] memory defaultValue)\n        internal\n        view\n        returns (bytes32[] memory)\n    {\n        return keyExists(toml, key) ? readBytes32Array(toml, key) : defaultValue;\n    }\n\n    function readStringOr(string memory toml, string memory key, string memory defaultValue)\n        internal\n        view\n        returns (string memory)\n    {\n        return keyExists(toml, key) ? readString(toml, key) : defaultValue;\n    }\n\n    function readStringArrayOr(string memory toml, string memory key, string[] memory defaultValue)\n        internal\n        view\n        returns (string[] memory)\n    {\n        return keyExists(toml, key) ? readStringArray(toml, key) : defaultValue;\n    }\n\n    function readAddressOr(string memory toml, string memory key, address defaultValue)\n        internal\n        view\n        returns (address)\n    {\n        return keyExists(toml, key) ? readAddress(toml, key) : defaultValue;\n    }\n\n    function readAddressArrayOr(string memory toml, string memory key, address[] memory defaultValue)\n        internal\n        view\n        returns (address[] memory)\n    {\n        return keyExists(toml, key) ? readAddressArray(toml, key) : defaultValue;\n    }\n\n    function readBoolOr(string memory toml, string memory key, bool defaultValue) internal view returns (bool) {\n        return keyExists(toml, key) ? readBool(toml, key) : defaultValue;\n    }\n\n    function readBoolArrayOr(string memory toml, string memory key, bool[] memory defaultValue)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        return keyExists(toml, key) ? readBoolArray(toml, key) : defaultValue;\n    }\n\n    function readBytesOr(string memory toml, string memory key, bytes memory defaultValue)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return keyExists(toml, key) ? readBytes(toml, key) : defaultValue;\n    }\n\n    function readBytesArrayOr(string memory toml, string memory key, bytes[] memory defaultValue)\n        internal\n        view\n        returns (bytes[] memory)\n    {\n        return keyExists(toml, key) ? readBytesArray(toml, key) : defaultValue;\n    }\n\n    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {\n        return vm.serializeJson(jsonKey, rootObject);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBool(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeUint(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeInt(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeAddress(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes32(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeBytes(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\n        internal\n        returns (string memory)\n    {\n        return vm.serializeString(jsonKey, key, value);\n    }\n\n    function write(string memory jsonKey, string memory path) internal {\n        vm.writeToml(jsonKey, path);\n    }\n\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\n        vm.writeToml(jsonKey, path, valueKey);\n    }\n}\n"
    },
    "lib/forge-std/src/StdUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IMulticall3} from \"./interfaces/IMulticall3.sol\";\nimport {MockERC20} from \"./mocks/MockERC20.sol\";\nimport {MockERC721} from \"./mocks/MockERC721.sol\";\nimport {VmSafe} from \"./Vm.sol\";\n\nabstract contract StdUtils {\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTANTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\n    uint256 private constant INT256_MIN_ABS =\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\n    uint256 private constant SECP256K1_ORDER =\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\n    uint256 private constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        require(min <= max, \"StdUtils bound(uint256,uint256,uint256): Max is less than min.\");\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\n        if (x >= min && x <= max) return x;\n\n        uint256 size = max - min + 1;\n\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\n        // This helps ensure coverage of the min/max values.\n        if (x <= 3 && size > x) return min + x;\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\n\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\n        if (x > max) {\n            uint256 diff = x - max;\n            uint256 rem = diff % size;\n            if (rem == 0) return max;\n            result = min + rem - 1;\n        } else if (x < min) {\n            uint256 diff = min - x;\n            uint256 rem = diff % size;\n            if (rem == 0) return min;\n            result = max - rem + 1;\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", result);\n    }\n\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        require(min <= max, \"StdUtils bound(int256,int256,int256): Max is less than min.\");\n\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\n        // int256 : -(2**255) ~ (2**255 - 1)\n        // uint256:     0     ~ (2**256 - 1)\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\n        //\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\n        // So, use `~uint256(x) + 1` instead.\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\n\n        uint256 y = _bound(_x, _min, _max);\n\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\n    }\n\n    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\n        result = _bound(x, min, max);\n        console2_log_StdUtils(\"Bound result\", vm.toString(result));\n    }\n\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\n    }\n\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\n        require(b.length <= 32, \"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\");\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\n    }\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\n        console2_log_StdUtils(\"computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.\");\n        return vm.computeCreateAddress(deployer, nonce);\n    }\n\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\n        internal\n        pure\n        virtual\n        returns (address)\n    {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initcodeHash, deployer);\n    }\n\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\n        console2_log_StdUtils(\"computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.\");\n        return vm.computeCreate2Address(salt, initCodeHash);\n    }\n\n    /// @dev returns an initialized mock ERC20 contract\n    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)\n        internal\n        returns (MockERC20 mock)\n    {\n        mock = new MockERC20();\n        mock.initialize(name, symbol, decimals);\n    }\n\n    /// @dev returns an initialized mock ERC721 contract\n    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {\n        mock = new MockERC721();\n        mock.initialize(name, symbol);\n    }\n\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\n        return hashInitCode(creationCode, \"\");\n    }\n\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\n    /// @param args the ABI-encoded arguments to the constructor of C\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(creationCode, args));\n    }\n\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\n    function getTokenBalances(address token, address[] memory addresses)\n        internal\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 tokenCodeSize;\n        assembly {\n            tokenCodeSize := extcodesize(token)\n        }\n        require(tokenCodeSize > 0, \"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\");\n\n        // ABI encode the aggregate call to Multicall3.\n        uint256 length = addresses.length;\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            // 0x70a08231 = bytes4(\"balanceOf(address)\"))\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\n        }\n\n        // Make the aggregate call.\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\n\n        // ABI decode the return data and return the balances.\n        balances = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            balances[i] = abi.decode(returnData[i], (uint256));\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                 PRIVATE FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    // This section is used to prevent the compilation of console, which shortens the compilation time when console is\n    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid\n    // any breaking changes to function signatures.\n    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)\n        internal\n        pure\n        returns (function(bytes memory) internal pure fnOut)\n    {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\n    }\n\n    function _sendLogPayloadView(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE2_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function console2_log_StdUtils(string memory p0) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function console2_log_StdUtils(string memory p0, string memory p1) private pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n}\n"
    },
    "lib/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\n// ðŸ’¬ ABOUT\n// Forge Std's default Test.\n\n// ðŸ§© MODULES\nimport {console} from \"./console.sol\";\nimport {console2} from \"./console2.sol\";\nimport {safeconsole} from \"./safeconsole.sol\";\nimport {StdAssertions} from \"./StdAssertions.sol\";\nimport {StdChains} from \"./StdChains.sol\";\nimport {StdCheats} from \"./StdCheats.sol\";\nimport {stdError} from \"./StdError.sol\";\nimport {StdInvariant} from \"./StdInvariant.sol\";\nimport {stdJson} from \"./StdJson.sol\";\nimport {stdMath} from \"./StdMath.sol\";\nimport {StdStorage, stdStorage} from \"./StdStorage.sol\";\nimport {StdStyle} from \"./StdStyle.sol\";\nimport {stdToml} from \"./StdToml.sol\";\nimport {StdUtils} from \"./StdUtils.sol\";\nimport {Vm} from \"./Vm.sol\";\n\n// ðŸ“¦ BOILERPLATE\nimport {TestBase} from \"./Base.sol\";\n\n// â­ï¸ TEST\nabstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {\n    // Note: IS_TEST() must return true.\n    bool public IS_TEST = true;\n}\n"
    },
    "lib/forge-std/src/Vm.sol": {
      "content": "// Automatically @generated by scripts/vm.py. Do not modify manually.\n\n// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.2 <0.9.0;\npragma experimental ABIEncoderV2;\n\n/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may\n/// result in Script simulations differing from on-chain execution. It is recommended to only use\n/// these cheats in scripts.\ninterface VmSafe {\n    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.\n    enum CallerMode {\n        // No caller modification is currently active.\n        None,\n        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.\n        Broadcast,\n        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.\n        RecurrentBroadcast,\n        // A one time prank triggered by a `vm.prank()` call is currently active.\n        Prank,\n        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.\n        RecurrentPrank\n    }\n\n    /// The kind of account access that occurred.\n    enum AccountAccessKind {\n        // The account was called.\n        Call,\n        // The account was called via delegatecall.\n        DelegateCall,\n        // The account was called via callcode.\n        CallCode,\n        // The account was called via staticcall.\n        StaticCall,\n        // The account was created.\n        Create,\n        // The account was selfdestructed.\n        SelfDestruct,\n        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).\n        Resume,\n        // The account's balance was read.\n        Balance,\n        // The account's codesize was read.\n        Extcodesize,\n        // The account's codehash was read.\n        Extcodehash,\n        // The account's code was copied.\n        Extcodecopy\n    }\n\n    /// Forge execution contexts.\n    enum ForgeContext {\n        // Test group execution context (test, coverage or snapshot).\n        TestGroup,\n        // `forge test` execution context.\n        Test,\n        // `forge coverage` execution context.\n        Coverage,\n        // `forge snapshot` execution context.\n        Snapshot,\n        // Script group execution context (dry run, broadcast or resume).\n        ScriptGroup,\n        // `forge script` execution context.\n        ScriptDryRun,\n        // `forge script --broadcast` execution context.\n        ScriptBroadcast,\n        // `forge script --resume` execution context.\n        ScriptResume,\n        // Unknown `forge` execution context.\n        Unknown\n    }\n\n    /// An Ethereum log. Returned by `getRecordedLogs`.\n    struct Log {\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The address of the log's emitter.\n        address emitter;\n    }\n\n    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.\n    struct Rpc {\n        // The alias of the RPC URL.\n        string key;\n        // The RPC URL.\n        string url;\n    }\n\n    /// An RPC log object. Returned by `eth_getLogs`.\n    struct EthGetLogs {\n        // The address of the log's emitter.\n        address emitter;\n        // The topics of the log, including the signature, if any.\n        bytes32[] topics;\n        // The raw data of the log.\n        bytes data;\n        // The block hash.\n        bytes32 blockHash;\n        // The block number.\n        uint64 blockNumber;\n        // The transaction hash.\n        bytes32 transactionHash;\n        // The transaction index in the block.\n        uint64 transactionIndex;\n        // The log index.\n        uint256 logIndex;\n        // Whether the log was removed.\n        bool removed;\n    }\n\n    /// A single entry in a directory listing. Returned by `readDir`.\n    struct DirEntry {\n        // The error message, if any.\n        string errorMessage;\n        // The path of the entry.\n        string path;\n        // The depth of the entry.\n        uint64 depth;\n        // Whether the entry is a directory.\n        bool isDir;\n        // Whether the entry is a symlink.\n        bool isSymlink;\n    }\n\n    /// Metadata information about a file.\n    /// This structure is returned from the `fsMetadata` function and represents known\n    /// metadata about a file such as its permissions, size, modification\n    /// times, etc.\n    struct FsMetadata {\n        // True if this metadata is for a directory.\n        bool isDir;\n        // True if this metadata is for a symlink.\n        bool isSymlink;\n        // The size of the file, in bytes, this metadata is for.\n        uint256 length;\n        // True if this metadata is for a readonly (unwritable) file.\n        bool readOnly;\n        // The last modification time listed in this metadata.\n        uint256 modified;\n        // The last access time of this metadata.\n        uint256 accessed;\n        // The creation time listed in this metadata.\n        uint256 created;\n    }\n\n    /// A wallet with a public and private key.\n    struct Wallet {\n        // The wallet's address.\n        address addr;\n        // The wallet's public key `X`.\n        uint256 publicKeyX;\n        // The wallet's public key `Y`.\n        uint256 publicKeyY;\n        // The wallet's private key.\n        uint256 privateKey;\n    }\n\n    /// The result of a `tryFfi` call.\n    struct FfiResult {\n        // The exit code of the call.\n        int32 exitCode;\n        // The optionally hex-decoded `stdout` data.\n        bytes stdout;\n        // The `stderr` data.\n        bytes stderr;\n    }\n\n    /// Information on the chain and fork.\n    struct ChainInfo {\n        // The fork identifier. Set to zero if no fork is active.\n        uint256 forkId;\n        // The chain ID of the current fork.\n        uint256 chainId;\n    }\n\n    /// The result of a `stopAndReturnStateDiff` call.\n    struct AccountAccess {\n        // The chain and fork the access occurred.\n        ChainInfo chainInfo;\n        // The kind of account access that determines what the account is.\n        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.\n        // If kind is Create, then the account is the newly created account.\n        // If kind is SelfDestruct, then the account is the selfdestruct recipient.\n        // If kind is a Resume, then account represents a account context that has resumed.\n        AccountAccessKind kind;\n        // The account that was accessed.\n        // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.\n        address account;\n        // What accessed the account.\n        address accessor;\n        // If the account was initialized or empty prior to the access.\n        // An account is considered initialized if it has code, a\n        // non-zero nonce, or a non-zero balance.\n        bool initialized;\n        // The previous balance of the accessed account.\n        uint256 oldBalance;\n        // The potential new balance of the accessed account.\n        // That is, all balance changes are recorded here, even if reverts occurred.\n        uint256 newBalance;\n        // Code of the account deployed by CREATE.\n        bytes deployedCode;\n        // Value passed along with the account access\n        uint256 value;\n        // Input data provided to the CREATE or CALL\n        bytes data;\n        // If this access reverted in either the current or parent context.\n        bool reverted;\n        // An ordered list of storage accesses made during an account access operation.\n        StorageAccess[] storageAccesses;\n        // Call depth traversed during the recording of state differences\n        uint64 depth;\n    }\n\n    /// The storage accessed during an `AccountAccess`.\n    struct StorageAccess {\n        // The account whose storage was accessed.\n        address account;\n        // The slot that was accessed.\n        bytes32 slot;\n        // If the access was a write.\n        bool isWrite;\n        // The previous value of the slot.\n        bytes32 previousValue;\n        // The new value of the slot.\n        bytes32 newValue;\n        // If the access was reverted.\n        bool reverted;\n    }\n\n    /// Gas used. Returned by `lastCallGas`.\n    struct Gas {\n        // The gas limit of the call.\n        uint64 gasLimit;\n        // The total gas used.\n        uint64 gasTotalUsed;\n        // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>\n        uint64 gasMemoryUsed;\n        // The amount of gas refunded.\n        int64 gasRefunded;\n        // The amount of gas remaining.\n        uint64 gasRemaining;\n    }\n\n    /// The result of the `stopDebugTraceRecording` call\n    struct DebugStep {\n        // The stack before executing the step of the run.\n        // stack\\[0\\] represents the top of the stack.\n        // and only stack data relevant to the opcode execution is contained.\n        uint256[] stack;\n        // The memory input data before executing the step of the run.\n        // only input data relevant to the opcode execution is contained.\n        // e.g. for MLOAD, it will have memory\\[offset:offset+32\\] copied here.\n        // the offset value can be get by the stack data.\n        bytes memoryInput;\n        // The opcode that was accessed.\n        uint8 opcode;\n        // The call depth of the step.\n        uint64 depth;\n        // Whether the call end up with out of gas error.\n        bool isOutOfGas;\n        // The contract address where the opcode is running\n        address contractAddr;\n    }\n\n    // ======== Crypto ========\n\n    /// Derives a private key from the name, labels the account with that name, and returns the wallet.\n    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key and returns the wallet.\n    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);\n\n    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.\n    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path)\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at the derivation path `m/44'/60'/0'/0/{index}`.\n    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language\n    /// at `{derivationPath}{index}`.\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)\n        external\n        pure\n        returns (uint256 privateKey);\n\n    /// Derives secp256r1 public key from the provided `privateKey`.\n    function publicKeyP256(uint256 privateKey) external pure returns (uint256 publicKeyX, uint256 publicKeyY);\n\n    /// Adds a private key to the local forge wallet and returns the address.\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\n\n    /// Derive a set number of wallets from a mnemonic at the derivation path `m/44'/60'/0'/0/{0..count}`.\n    ///\n    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.\n    function rememberKeys(string calldata mnemonic, string calldata derivationPath, uint32 count)\n        external\n        returns (address[] memory keyAddrs);\n\n    /// Derive a set number of wallets from a mnemonic in the specified language at the derivation path `m/44'/60'/0'/0/{0..count}`.\n    ///\n    /// The respective private keys are saved to the local forge wallet for later use and their addresses are returned.\n    function rememberKeys(\n        string calldata mnemonic,\n        string calldata derivationPath,\n        string calldata language,\n        uint32 count\n    ) external returns (address[] memory keyAddrs);\n\n    /// Signs data with a `Wallet`.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    function signCompact(Wallet calldata wallet, bytes32 digest) external returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    function signCompact(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function signCompact(bytes32 digest) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Returns a compact signature (`r`, `vs`) as per EIP-2098, where `vs` encodes both the\n    /// signature's `s` value, and the recovery id `v` in a single bytes32.\n    /// This format reduces the signature size from 65 to 64 bytes.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function signCompact(address signer, bytes32 digest) external pure returns (bytes32 r, bytes32 vs);\n\n    /// Signs `digest` with `privateKey` using the secp256r1 curve.\n    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);\n\n    /// Signs data with a `Wallet`.\n    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with `privateKey` using the secp256k1 curve.\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// If `--sender` is provided, the signer with provided address is used, otherwise,\n    /// if exactly one signer is provided to the script, that signer is used.\n    /// Raises error if signer passed through `--sender` does not match any unlocked signers or\n    /// if `--sender` is not provided and not exactly one signer is passed to the script.\n    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    /// Signs `digest` with signer provided to script using the secp256k1 curve.\n    /// Raises error if none of the signers passed into the script have provided address.\n    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\n\n    // ======== Environment ========\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and returns true if it exists, else returns false.\n    function envExists(string calldata name) external view returns (bool result);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `bool`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bool defaultValue) external view returns (bool value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\n        external\n        view\n        returns (address[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\n        external\n        view\n        returns (bytes32[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\n        external\n        view\n        returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\n        external\n        view\n        returns (bytes[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `int256`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);\n\n    /// Gets the environment variable `name` and parses it as `address`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, address defaultValue) external view returns (address value);\n\n    /// Gets the environment variable `name` and parses it as `bytes32`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as `bytes`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\n        external\n        view\n        returns (bool[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\n        external\n        view\n        returns (uint256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.\n    /// Reverts if the variable could not be parsed.\n    /// Returns `defaultValue` if the variable was not found.\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\n        external\n        view\n        returns (int256[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `string`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name) external view returns (string memory value);\n\n    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\n\n    /// Gets the environment variable `name` and parses it as `uint256`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name) external view returns (uint256 value);\n\n    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.\n    /// Reverts if the variable was not found or could not be parsed.\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\n\n    /// Returns true if `forge` command was executed in given context.\n    function isContext(ForgeContext context) external view returns (bool result);\n\n    /// Sets environment variables.\n    function setEnv(string calldata name, string calldata value) external;\n\n    // ======== EVM ========\n\n    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\n\n    /// Gets the address for a given private key.\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\n\n    /// Gets all the logs according to specified filter.\n    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)\n        external\n        returns (EthGetLogs[] memory logs);\n\n    /// Gets the current `block.blobbasefee`.\n    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlobBaseFee() external view returns (uint256 blobBaseFee);\n\n    /// Gets the current `block.number`.\n    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockNumber() external view returns (uint256 height);\n\n    /// Gets the current `block.timestamp`.\n    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,\n    /// and as a result will get optimized out by the compiler.\n    /// See https://github.com/foundry-rs/foundry/issues/6180\n    function getBlockTimestamp() external view returns (uint256 timestamp);\n\n    /// Gets the map key and parent of a mapping at a given slot, for a given address.\n    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)\n        external\n        returns (bool found, bytes32 key, bytes32 parent);\n\n    /// Gets the number of elements in the mapping at the given slot, for a given address.\n    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);\n\n    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The\n    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).\n    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);\n\n    /// Gets the nonce of an account.\n    function getNonce(address account) external view returns (uint64 nonce);\n\n    /// Get the nonce of a `Wallet`.\n    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);\n\n    /// Gets all the recorded logs.\n    function getRecordedLogs() external returns (Log[] memory logs);\n\n    /// Gets the gas used in the last call from the callee perspective.\n    function lastCallGas() external view returns (Gas memory gas);\n\n    /// Loads a storage slot from an address.\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\n\n    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\n    function pauseGasMetering() external;\n\n    /// Records all storage reads and writes.\n    function record() external;\n\n    /// Record all the transaction logs.\n    function recordLogs() external;\n\n    /// Reset gas metering (i.e. gas usage is set to gas limit).\n    function resetGasMetering() external;\n\n    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\n    function resumeGasMetering() external;\n\n    /// Performs an Ethereum JSON-RPC request to the current fork URL.\n    function rpc(string calldata method, string calldata params) external returns (bytes memory data);\n\n    /// Performs an Ethereum JSON-RPC request to the given endpoint.\n    function rpc(string calldata urlOrAlias, string calldata method, string calldata params)\n        external\n        returns (bytes memory data);\n\n    /// Records the debug trace during the run.\n    function startDebugTraceRecording() external;\n\n    /// Starts recording all map SSTOREs for later retrieval.\n    function startMappingRecording() external;\n\n    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,\n    /// along with the context of the calls\n    function startStateDiffRecording() external;\n\n    /// Stop debug trace recording and returns the recorded debug trace.\n    function stopAndReturnDebugTraceRecording() external returns (DebugStep[] memory step);\n\n    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.\n    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);\n\n    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.\n    function stopMappingRecording() external;\n\n    // ======== Filesystem ========\n\n    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    /// `path` is relative to the project root.\n    function closeFile(string calldata path) external;\n\n    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.\n    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.\n    /// Both `from` and `to` are relative to the project root.\n    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);\n\n    /// Creates a new, empty directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - User lacks permissions to modify `path`.\n    /// - A parent of the given path doesn't exist and `recursive` is false.\n    /// - `path` already exists and `recursive` is false.\n    /// `path` is relative to the project root.\n    function createDir(string calldata path, bool recursive) external;\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function deployCode(string calldata artifactPath) external returns (address deployedAddress);\n\n    /// Deploys a contract from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    /// Additionally accepts abi-encoded constructor arguments.\n    function deployCode(string calldata artifactPath, bytes calldata constructorArgs)\n        external\n        returns (address deployedAddress);\n\n    /// Returns true if the given path points to an existing entity, else returns false.\n    function exists(string calldata path) external returns (bool result);\n\n    /// Performs a foreign function call via the terminal.\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\n\n    /// Given a path, query the file system to get information about a file, directory, etc.\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\n\n    /// Gets the artifact path from code (aka. creation code).\n    function getArtifactPathByCode(bytes calldata code) external view returns (string memory path);\n\n    /// Gets the artifact path from deployed code (aka. runtime code).\n    function getArtifactPathByDeployedCode(bytes calldata deployedCode) external view returns (string memory path);\n\n    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\n\n    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the\n    /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\n\n    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.\n    function isDir(string calldata path) external returns (bool result);\n\n    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.\n    function isFile(string calldata path) external returns (bool result);\n\n    /// Get the path of the current project root.\n    function projectRoot() external view returns (string memory path);\n\n    /// Prompts the user for a string value in the terminal.\n    function prompt(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for an address in the terminal.\n    function promptAddress(string calldata promptText) external returns (address);\n\n    /// Prompts the user for a hidden string value in the terminal.\n    function promptSecret(string calldata promptText) external returns (string memory input);\n\n    /// Prompts the user for hidden uint256 in the terminal (usually pk).\n    function promptSecretUint(string calldata promptText) external returns (uint256);\n\n    /// Prompts the user for uint256 in the terminal.\n    function promptUint(string calldata promptText) external returns (uint256);\n\n    /// Reads the directory at the given path recursively, up to `maxDepth`.\n    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.\n    /// Follows symbolic links if `followLinks` is true.\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\n\n    /// See `readDir(string)`.\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\n        external\n        view\n        returns (DirEntry[] memory entries);\n\n    /// Reads the entire content of file to string. `path` is relative to the project root.\n    function readFile(string calldata path) external view returns (string memory data);\n\n    /// Reads the entire content of file as binary. `path` is relative to the project root.\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\n\n    /// Reads next line of file to string.\n    function readLine(string calldata path) external view returns (string memory line);\n\n    /// Reads a symbolic link, returning the path that the link points to.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` is not a symbolic link.\n    /// - `path` does not exist.\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\n\n    /// Removes a directory at the provided path.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` doesn't exist.\n    /// - `path` isn't a directory.\n    /// - User lacks permissions to modify `path`.\n    /// - The directory is not empty and `recursive` is false.\n    /// `path` is relative to the project root.\n    function removeDir(string calldata path, bool recursive) external;\n\n    /// Removes a file from the filesystem.\n    /// This cheatcode will revert in the following situations, but is not limited to just these cases:\n    /// - `path` points to a directory.\n    /// - The file doesn't exist.\n    /// - The user lacks permissions to remove the file.\n    /// `path` is relative to the project root.\n    function removeFile(string calldata path) external;\n\n    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.\n    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);\n\n    /// Returns the time since unix epoch in milliseconds.\n    function unixTime() external returns (uint256 milliseconds);\n\n    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFile(string calldata path, string calldata data) external;\n\n    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    /// `path` is relative to the project root.\n    function writeFileBinary(string calldata path, bytes calldata data) external;\n\n    /// Writes line to file, creating a file if it does not exist.\n    /// `path` is relative to the project root.\n    function writeLine(string calldata path, string calldata data) external;\n\n    // ======== JSON ========\n\n    /// Checks if `key` exists in a JSON object.\n    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address`.\n    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);\n\n    /// Parses a string of JSON data at `key` and coerces it to `address[]`.\n    function parseJsonAddressArray(string calldata json, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool`.\n    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.\n    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes`.\n    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.\n    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.\n    function parseJsonBytes32Array(string calldata json, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.\n    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256`.\n    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.\n    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a JSON object.\n    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string`.\n    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `string[]`.\n    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseJsonTypeArray(string calldata json, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(string calldata json, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseJsonType(string calldata json, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256`.\n    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.\n    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a JSON object.\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a JSON object at `key`.\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.\n    /// Returns the stringified version of the specific JSON file up to that moment.\n    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(string calldata typeDescription, bytes calldata value)\n        external\n        pure\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeJsonType(\n        string calldata objectKey,\n        string calldata valueKey,\n        string calldata typeDescription,\n        bytes calldata value\n    ) external returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\n        external\n        returns (string memory json);\n\n    /// See `serializeJson`.\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\n        external\n        returns (string memory json);\n\n    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.\n    function writeJson(string calldata json, string calldata path) external;\n\n    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\n\n    /// Checks if `key` exists in a JSON object\n    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.\n    function keyExists(string calldata json, string calldata key) external view returns (bool);\n\n    // ======== Scripting ========\n\n    /// Takes a signed transaction and broadcasts it to the network.\n    function broadcastRawTransaction(bytes calldata data) external;\n\n    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function broadcast() external;\n\n    /// Has the next call (at this call depth only) create a transaction with the address provided\n    /// as the sender that can later be signed and sent onchain.\n    function broadcast(address signer) external;\n\n    /// Has the next call (at this call depth only) create a transaction with the private key\n    /// provided as the sender that can later be signed and sent onchain.\n    function broadcast(uint256 privateKey) external;\n\n    /// Returns addresses of available unlocked wallets in the script environment.\n    function getScriptWallets() external returns (address[] memory wallets);\n\n    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.\n    /// Broadcasting address is determined by checking the following in order:\n    /// 1. If `--sender` argument was provided, that address is used.\n    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.\n    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.\n    function startBroadcast() external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the address\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(address signer) external;\n\n    /// Has all subsequent calls (at this call depth only) create transactions with the private key\n    /// provided that can later be signed and sent onchain.\n    function startBroadcast(uint256 privateKey) external;\n\n    /// Stops collecting onchain transactions.\n    function stopBroadcast() external;\n\n    /// Returns addresses of available unlocked wallets in the script environment.\n    function getWallets() external returns (address[] memory wallets);\n\n    // ======== String ========\n\n    /// Returns the index of the first occurrence of a `key` in an `input` string.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.\n    /// Returns 0 in case of an empty `key`.\n    function indexOf(string calldata input, string calldata key) external pure returns (uint256);\n\n    /// Parses the given `string` into an `address`.\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\n\n    /// Parses the given `string` into a `bool`.\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\n\n    /// Parses the given `string` into `bytes`.\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\n\n    /// Parses the given `string` into a `bytes32`.\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\n\n    /// Parses the given `string` into a `int256`.\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\n\n    /// Parses the given `string` into a `uint256`.\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\n\n    /// Replaces occurrences of `from` in the given `string` with `to`.\n    function replace(string calldata input, string calldata from, string calldata to)\n        external\n        pure\n        returns (string memory output);\n\n    /// Splits the given `string` into an array of strings divided by the `delimiter`.\n    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);\n\n    /// Converts the given `string` value to Lowercase.\n    function toLowercase(string calldata input) external pure returns (string memory output);\n\n    /// Converts the given value to a `string`.\n    function toString(address value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(bool value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given value to a `string`.\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\n\n    /// Converts the given `string` value to Uppercase.\n    function toUppercase(string calldata input) external pure returns (string memory output);\n\n    /// Trims leading and trailing whitespace from the given `string` value.\n    function trim(string calldata input) external pure returns (string memory output);\n\n    // ======== Testing ========\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message.\n    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqAbsDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;\n\n    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.\n    /// Includes error message into revert string on failure.\n    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        uint256 left,\n        uint256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message.\n    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertApproxEqRelDecimal(\n        int256 left,\n        int256 right,\n        uint256 maxPercentDelta,\n        uint256 decimals,\n        string calldata error\n    ) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;\n\n    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.\n    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%\n    /// Includes error message into revert string on failure.\n    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)\n        external\n        pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are equal.\n    function assertEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are equal.\n    function assertEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are equal.\n    function assertEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal.\n    function assertEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.\n    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256 values are equal.\n    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal.\n    function assertEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal.\n    function assertEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal.\n    function assertEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are equal.\n    function assertEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.\n    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal.\n    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.\n    function assertEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are equal.\n    function assertEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.\n    function assertEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are equal.\n    function assertEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are equal and includes error message into revert string on failure.\n    function assertEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are equal.\n    function assertEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.\n    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is false.\n    function assertFalse(bool condition) external pure;\n\n    /// Asserts that the given condition is false and includes error message into revert string on failure.\n    function assertFalse(bool condition, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    function assertGe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    function assertGe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertGe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    function assertGt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    function assertGt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be greater than second.\n    /// Includes error message into revert string on failure.\n    function assertGt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    function assertLe(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    function assertLe(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than or equal to second.\n    /// Includes error message into revert string on failure.\n    function assertLe(int256 left, int256 right, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Formats values with decimals in failure message. Includes error message into revert string on failure.\n    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    function assertLt(uint256 left, uint256 right) external pure;\n\n    /// Compares two `uint256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    function assertLt(int256 left, int256 right) external pure;\n\n    /// Compares two `int256` values. Expects first value to be less than second.\n    /// Includes error message into revert string on failure.\n    function assertLt(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;\n\n    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.\n    /// Includes error message into revert string on failure.\n    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;\n\n    /// Asserts that two `bool` values are not equal.\n    function assertNotEq(bool left, bool right) external pure;\n\n    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool left, bool right, string calldata error) external pure;\n\n    /// Asserts that two `string` values are not equal.\n    function assertNotEq(string calldata left, string calldata right) external pure;\n\n    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;\n\n    /// Asserts that two `bytes` values are not equal.\n    function assertNotEq(bytes calldata left, bytes calldata right) external pure;\n\n    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal.\n    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal.\n    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;\n\n    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal.\n    function assertNotEq(uint256 left, uint256 right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal.\n    function assertNotEq(address[] calldata left, address[] calldata right) external pure;\n\n    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal.\n    function assertNotEq(string[] calldata left, string[] calldata right) external pure;\n\n    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;\n\n    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;\n\n    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;\n\n    /// Asserts that two `int256` values are not equal.\n    function assertNotEq(int256 left, int256 right) external pure;\n\n    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(int256 left, int256 right, string calldata error) external pure;\n\n    /// Asserts that two `address` values are not equal.\n    function assertNotEq(address left, address right) external pure;\n\n    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(address left, address right, string calldata error) external pure;\n\n    /// Asserts that two `bytes32` values are not equal.\n    function assertNotEq(bytes32 left, bytes32 right) external pure;\n\n    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.\n    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;\n\n    /// Asserts that the given condition is true.\n    function assertTrue(bool condition) external pure;\n\n    /// Asserts that the given condition is true and includes error message into revert string on failure.\n    function assertTrue(bool condition, string calldata error) external pure;\n\n    /// If the condition is false, discard this run's fuzz inputs and generate new ones.\n    function assume(bool condition) external pure;\n\n    /// Discard this run's fuzz inputs and generate new ones if next call reverted.\n    function assumeNoRevert() external pure;\n\n    /// Writes a breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char) external pure;\n\n    /// Writes a conditional breakpoint to jump to in the debugger.\n    function breakpoint(string calldata char, bool value) external pure;\n\n    /// Returns the Foundry version.\n    /// Format: <cargo_version>+<git_sha>+<build_timestamp>\n    /// Sample output: 0.2.0+faa94c384+202407110019\n    /// Note: Build timestamps may vary slightly across platforms due to separate CI jobs.\n    /// For reliable version comparisons, use YYYYMMDD0000 format (e.g., >= 202407110000)\n    /// to compare timestamps while ignoring minor time differences.\n    function getFoundryVersion() external view returns (string memory version);\n\n    /// Returns the RPC url for the given alias.\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\n\n    /// Returns all rpc urls and their aliases as structs.\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\n\n    /// Returns all rpc urls and their aliases `[alias, url][]`.\n    function rpcUrls() external view returns (string[2][] memory urls);\n\n    /// Suspends execution of the main thread for `duration` milliseconds.\n    function sleep(uint256 duration) external;\n\n    // ======== Toml ========\n\n    /// Checks if `key` exists in a TOML table.\n    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address`.\n    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);\n\n    /// Parses a string of TOML data at `key` and coerces it to `address[]`.\n    function parseTomlAddressArray(string calldata toml, string calldata key)\n        external\n        pure\n        returns (address[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool`.\n    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.\n    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes`.\n    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.\n    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.\n    function parseTomlBytes32Array(string calldata toml, string calldata key)\n        external\n        pure\n        returns (bytes32[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.\n    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256`.\n    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.\n    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);\n\n    /// Returns an array of all the keys in a TOML table.\n    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string`.\n    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `string[]`.\n    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to type array corresponding to `typeDescription`.\n    function parseTomlTypeArray(string calldata toml, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of TOML data and coerces it to type corresponding to `typeDescription`.\n    function parseTomlType(string calldata toml, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to type corresponding to `typeDescription`.\n    function parseTomlType(string calldata toml, string calldata key, string calldata typeDescription)\n        external\n        pure\n        returns (bytes memory);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256`.\n    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);\n\n    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.\n    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);\n\n    /// ABI-encodes a TOML table.\n    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);\n\n    /// ABI-encodes a TOML table at `key`.\n    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.\n    function writeToml(string calldata json, string calldata path) external;\n\n    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>\n    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.\n    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;\n\n    // ======== Utilities ========\n\n    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)\n        external\n        pure\n        returns (address);\n\n    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);\n\n    /// Compute the address a contract will be deployed at for a given deployer address and nonce.\n    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);\n\n    /// Utility cheatcode to copy storage of `from` contract to another `to` contract.\n    function copyStorage(address from, address to) external;\n\n    /// Returns ENS namehash for provided string.\n    function ensNamehash(string calldata name) external pure returns (bytes32);\n\n    /// Gets the label for the specified address.\n    function getLabel(address account) external view returns (string memory currentLabel);\n\n    /// Labels an address in call traces.\n    function label(address account, string calldata newLabel) external;\n\n    /// Pauses collection of call traces. Useful in cases when you want to skip tracing of\n    /// complex calls which are not useful for debugging.\n    function pauseTracing() external view;\n\n    /// Returns a random `address`.\n    function randomAddress() external returns (address);\n\n    /// Returns a random `bool`.\n    function randomBool() external view returns (bool);\n\n    /// Returns a random byte array value of the given length.\n    function randomBytes(uint256 len) external view returns (bytes memory);\n\n    /// Returns a random fixed-size byte array of length 4.\n    function randomBytes4() external view returns (bytes4);\n\n    /// Returns a random fixed-size byte array of length 8.\n    function randomBytes8() external view returns (bytes8);\n\n    /// Returns a random `int256` value.\n    function randomInt() external view returns (int256);\n\n    /// Returns a random `int256` value of given bits.\n    function randomInt(uint256 bits) external view returns (int256);\n\n    /// Returns a random uint256 value.\n    function randomUint() external returns (uint256);\n\n    /// Returns random uint256 value between the provided range (=min..=max).\n    function randomUint(uint256 min, uint256 max) external returns (uint256);\n\n    /// Returns a random `uint256` value of given bits.\n    function randomUint(uint256 bits) external view returns (uint256);\n\n    /// Unpauses collection of call traces.\n    function resumeTracing() external view;\n\n    /// Utility cheatcode to set arbitrary storage for given target address.\n    function setArbitraryStorage(address target) external;\n\n    /// Encodes a `bytes` value to a base64url string.\n    function toBase64URL(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64url string.\n    function toBase64URL(string calldata data) external pure returns (string memory);\n\n    /// Encodes a `bytes` value to a base64 string.\n    function toBase64(bytes calldata data) external pure returns (string memory);\n\n    /// Encodes a `string` value to a base64 string.\n    function toBase64(string calldata data) external pure returns (string memory);\n}\n\n/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used\n/// in tests, but it is not recommended to use these cheats in scripts.\ninterface Vm is VmSafe {\n    // ======== EVM ========\n\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\n    function activeFork() external view returns (uint256 forkId);\n\n    /// In forking mode, explicitly grant the given address cheatcode access.\n    function allowCheatcodes(address account) external;\n\n    /// Sets `block.blobbasefee`\n    function blobBaseFee(uint256 newBlobBaseFee) external;\n\n    /// Sets the blobhashes in the transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function blobhashes(bytes32[] calldata hashes) external;\n\n    /// Sets `block.chainid`.\n    function chainId(uint256 newChainId) external;\n\n    /// Clears all mocked calls.\n    function clearMockedCalls() external;\n\n    /// Clones a source account code, state, balance and nonce to a target account and updates in-memory EVM state.\n    function cloneAccount(address source, address target) external;\n\n    /// Sets `block.coinbase`.\n    function coinbase(address newCoinbase) external;\n\n    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\n\n    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\n\n    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,\n    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\n\n    /// Sets an address' balance.\n    function deal(address account, uint256 newBalance) external;\n\n    /// Removes the snapshot with the given ID created by `snapshot`.\n    /// Takes the snapshot ID to delete.\n    /// Returns `true` if the snapshot was successfully deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function deleteStateSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// Removes _all_ snapshots previously created by `snapshot`.\n    function deleteStateSnapshots() external;\n\n    /// Sets `block.difficulty`.\n    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\n    /// Reverts if used on unsupported EVM versions.\n    function difficulty(uint256 newDifficulty) external;\n\n    /// Dump a genesis JSON file's `allocs` to disk.\n    function dumpState(string calldata pathToStateJson) external;\n\n    /// Sets an address' code.\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\n\n    /// Sets `block.basefee`.\n    function fee(uint256 newBasefee) external;\n\n    /// Gets the blockhashes from the current transaction.\n    /// Not available on EVM versions before Cancun.\n    /// If used on unsupported EVM versions it will revert.\n    function getBlobhashes() external view returns (bytes32[] memory hashes);\n\n    /// Returns true if the account is marked as persistent.\n    function isPersistent(address account) external view returns (bool persistent);\n\n    /// Load a genesis JSON file's `allocs` into the in-memory EVM state.\n    function loadAllocs(string calldata pathToAllocsJson) external;\n\n    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\n    /// Meaning, changes made to the state of this account will be kept when switching forks.\n    function makePersistent(address account) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address account0, address account1, address account2) external;\n\n    /// See `makePersistent(address)`.\n    function makePersistent(address[] calldata accounts) external;\n\n    /// Reverts a call to an address with specified revert data.\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\n\n    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\n        external;\n\n    /// Mocks a call to an address, returning specified data.\n    /// Calldata can either be strict or a partial match, e.g. if you only\n    /// pass a Solidity selector to the expected calldata, then the entire Solidity\n    /// function will be mocked.\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks a call to an address with a specific `msg.value`, returning specified data.\n    /// Calldata match takes precedence over `msg.value` in case of ambiguity.\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\n\n    /// Mocks multiple calls to an address, returning specified data for each call.\n    function mockCalls(address callee, bytes calldata data, bytes[] calldata returnData) external;\n\n    /// Mocks multiple calls to an address with a specific `msg.value`, returning specified data for each call.\n    function mockCalls(address callee, uint256 msgValue, bytes calldata data, bytes[] calldata returnData) external;\n\n    /// Whenever a call is made to `callee` with calldata `data`, this cheatcode instead calls\n    /// `target` with the same calldata. This functionality is similar to a delegate call made to\n    /// `target` contract from `callee`.\n    /// Can be used to substitute a call to a function with another implementation that captures\n    /// the primary logic of the original function but is easier to reason about.\n    /// If calldata is not a strict match then partial match by selector is attempted.\n    function mockFunction(address callee, address target, bytes calldata data) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address.\n    function prank(address msgSender) external;\n\n    /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.\n    function prank(address msgSender, address txOrigin) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(bytes32 newPrevrandao) external;\n\n    /// Sets `block.prevrandao`.\n    /// Not available on EVM versions before Paris. Use `difficulty` instead.\n    /// If used on unsupported EVM versions it will revert.\n    function prevrandao(uint256 newPrevrandao) external;\n\n    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\n\n    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.\n    function resetNonce(address account) external;\n\n    /// Revert the state of the EVM to a previous snapshot\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted.\n    /// Returns `false` if the snapshot does not exist.\n    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteStateSnapshot`.\n    function revertToState(uint256 snapshotId) external returns (bool success);\n\n    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots\n    /// Takes the snapshot ID to revert to.\n    /// Returns `true` if the snapshot was successfully reverted and deleted.\n    /// Returns `false` if the snapshot does not exist.\n    function revertToStateAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// Revokes persistent status from the address, previously added via `makePersistent`.\n    function revokePersistent(address account) external;\n\n    /// See `revokePersistent(address)`.\n    function revokePersistent(address[] calldata accounts) external;\n\n    /// Sets `block.height`.\n    function roll(uint256 newHeight) external;\n\n    /// Updates the currently active fork to given block number\n    /// This is similar to `roll` but for the currently active fork.\n    function rollFork(uint256 blockNumber) external;\n\n    /// Updates the currently active fork to given transaction. This will `rollFork` with the number\n    /// of the block the transaction was mined in and replays all transaction mined before it in the block.\n    function rollFork(bytes32 txHash) external;\n\n    /// Updates the given fork to given block number.\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\n\n    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.\n    function rollFork(uint256 forkId, bytes32 txHash) external;\n\n    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n    function selectFork(uint256 forkId) external;\n\n    /// Set blockhash for the current block.\n    /// It only sets the blockhash for blocks where `block.number - 256 <= number < block.number`.\n    function setBlockhash(uint256 blockNumber, bytes32 blockHash) external;\n\n    /// Sets the nonce of an account. Must be higher than the current nonce of the account.\n    function setNonce(address account, uint64 newNonce) external;\n\n    /// Sets the nonce of an account to an arbitrary value.\n    function setNonceUnsafe(address account, uint64 newNonce) external;\n\n    /// Snapshot capture the gas usage of the last call by name from the callee perspective.\n    function snapshotGasLastCall(string calldata name) external returns (uint256 gasUsed);\n\n    /// Snapshot capture the gas usage of the last call by name in a group from the callee perspective.\n    function snapshotGasLastCall(string calldata group, string calldata name) external returns (uint256 gasUsed);\n\n    /// Snapshot the current state of the evm.\n    /// Returns the ID of the snapshot that was created.\n    /// To revert a snapshot use `revertToState`.\n    function snapshotState() external returns (uint256 snapshotId);\n\n    /// Snapshot capture an arbitrary numerical value by name.\n    /// The group name is derived from the contract name.\n    function snapshotValue(string calldata name, uint256 value) external;\n\n    /// Snapshot capture an arbitrary numerical value by name in a group.\n    function snapshotValue(string calldata group, string calldata name, uint256 value) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.\n    function startPrank(address msgSender) external;\n\n    /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.\n    function startPrank(address msgSender, address txOrigin) external;\n\n    /// Start a snapshot capture of the current gas usage by name.\n    /// The group name is derived from the contract name.\n    function startSnapshotGas(string calldata name) external;\n\n    /// Start a snapshot capture of the current gas usage by name in a group.\n    function startSnapshotGas(string calldata group, string calldata name) external;\n\n    /// Resets subsequent calls' `msg.sender` to be `address(this)`.\n    function stopPrank() external;\n\n    /// Stop the snapshot capture of the current gas by latest snapshot name, capturing the gas used since the start.\n    function stopSnapshotGas() external returns (uint256 gasUsed);\n\n    /// Stop the snapshot capture of the current gas usage by name, capturing the gas used since the start.\n    /// The group name is derived from the contract name.\n    function stopSnapshotGas(string calldata name) external returns (uint256 gasUsed);\n\n    /// Stop the snapshot capture of the current gas usage by name in a group, capturing the gas used since the start.\n    function stopSnapshotGas(string calldata group, string calldata name) external returns (uint256 gasUsed);\n\n    /// Stores a value to an address' storage slot.\n    function store(address target, bytes32 slot, bytes32 value) external;\n\n    /// Fetches the given transaction from the active fork and executes it on the current state.\n    function transact(bytes32 txHash) external;\n\n    /// Fetches the given transaction from the given fork and executes it on the current state.\n    function transact(uint256 forkId, bytes32 txHash) external;\n\n    /// Sets `tx.gasprice`.\n    function txGasPrice(uint256 newGasPrice) external;\n\n    /// Sets `block.timestamp`.\n    function warp(uint256 newTimestamp) external;\n\n    /// `deleteSnapshot` is being deprecated in favor of `deleteStateSnapshot`. It will be removed in future versions.\n    function deleteSnapshot(uint256 snapshotId) external returns (bool success);\n\n    /// `deleteSnapshots` is being deprecated in favor of `deleteStateSnapshots`. It will be removed in future versions.\n    function deleteSnapshots() external;\n\n    /// `revertToAndDelete` is being deprecated in favor of `revertToStateAndDelete`. It will be removed in future versions.\n    function revertToAndDelete(uint256 snapshotId) external returns (bool success);\n\n    /// `revertTo` is being deprecated in favor of `revertToState`. It will be removed in future versions.\n    function revertTo(uint256 snapshotId) external returns (bool success);\n\n    /// `snapshot` is being deprecated in favor of `snapshotState`. It will be removed in future versions.\n    function snapshot() external returns (uint256 snapshotId);\n\n    // ======== Testing ========\n\n    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\n\n    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\n        external;\n\n    /// Expects a call to an address with the specified calldata.\n    /// Calldata can either be a strict or a partial match.\n    function expectCall(address callee, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified calldata.\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\n\n    /// Expects a call to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value` and calldata.\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\n\n    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\n\n    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\n\n    /// Prepare an expected anonymous log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmitAnonymous(bool checkTopic0, bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData)\n        external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(\n        bool checkTopic0,\n        bool checkTopic1,\n        bool checkTopic2,\n        bool checkTopic3,\n        bool checkData,\n        address emitter\n    ) external;\n\n    /// Prepare an expected anonymous log with all topic and data checks enabled.\n    /// Call this function, then emit an anonymous event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmitAnonymous() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmitAnonymous(address emitter) external;\n\n    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\n        external;\n\n    /// Prepare an expected log with all topic and data checks enabled.\n    /// Call this function, then emit an event, then call a function. Internally after the call, we check if\n    /// logs were emitted in the expected order with the expected topics and data.\n    function expectEmit() external;\n\n    /// Same as the previous method, but also checks supplied address against emitting contract.\n    function expectEmit(address emitter) external;\n\n    /// Expects an error on next call that starts with the revert data.\n    function expectPartialRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call to reverter address, that starts with the revert data.\n    function expectPartialRevert(bytes4 revertData, address reverter) external;\n\n    /// Expects an error on next call with any revert data.\n    function expectRevert() external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes4 revertData) external;\n\n    /// Expects an error on next call that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData) external;\n\n    /// Expects an error with any revert data on next call to reverter address.\n    function expectRevert(address reverter) external;\n\n    /// Expects an error from reverter address on next call, with any revert data.\n    function expectRevert(bytes4 revertData, address reverter) external;\n\n    /// Expects an error from reverter address on next call, that exactly matches the revert data.\n    function expectRevert(bytes calldata revertData, address reverter) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) âˆª [min, max) in the current subcontext. If any other\n    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\n    function expectSafeMemory(uint64 min, uint64 max) external;\n\n    /// Only allows memory writes to offsets [0x00, 0x60) âˆª [min, max) in the next created subcontext.\n    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\n    /// to the set.\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\n\n    /// Marks a test as skipped. Must be called at the top level of a test.\n    function skip(bool skipTest) external;\n\n    /// Marks a test as skipped with a reason. Must be called at the top level of a test.\n    function skip(bool skipTest, string calldata reason) external;\n\n    /// Stops all safe memory expectation in the current subcontext.\n    function stopExpectSafeMemory() external;\n}\n"
    },
    "lib/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, int256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,int256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "lib/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nimport {console as console2} from \"./console.sol\";\n"
    },
    "lib/forge-std/src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\nimport \"./IERC165.sol\";\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 is IERC165 {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\n    /// may be created and assigned without emitting Transfer. At the time of\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    /// reaffirmed. The zero address indicates there is no approved address.\n    /// When a Transfer event emits, this also indicates that the approved\n    /// address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    /// The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    /// function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    /// about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\n    /// `onERC721Received` on `_to` and throws if the return value is not\n    /// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    /// except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    /// THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    /// operator, or the approved address for this NFT. Throws if `_from` is\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\n    /// `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\n    /// operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external payable;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    /// all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    /// multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721TokenReceiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    /// after a `transfer`. This function MAY throw to revert and reject the\n    /// transfer. Return of other than the magic value MUST result in the\n    /// transaction being reverted.\n    /// Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\n        external\n        returns (bytes4);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\ninterface IERC721Metadata is IERC721 {\n    /// @notice A descriptive name for a collection of NFTs in this contract\n    function name() external view returns (string memory _name);\n\n    /// @notice An abbreviated name for NFTs in this contract\n    function symbol() external view returns (string memory _symbol);\n\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n    /// 3986. The URI may point to a JSON file that conforms to the \"ERC721\n    /// Metadata JSON Schema\".\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\ninterface IERC721Enumerable is IERC721 {\n    /// @notice Count NFTs tracked by this contract\n    /// @return A count of valid NFTs tracked by this contract, where each one of\n    /// them has an assigned and queryable owner not equal to the zero address\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Enumerate valid NFTs\n    /// @dev Throws if `_index` >= `totalSupply()`.\n    /// @param _index A counter less than `totalSupply()`\n    /// @return The token identifier for the `_index`th NFT,\n    /// (sort order not specified)\n    function tokenByIndex(uint256 _index) external view returns (uint256);\n\n    /// @notice Enumerate NFTs assigned to an owner\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n    /// `_owner` is the zero address, representing invalid NFTs.\n    /// @param _owner An address where we are interested in NFTs owned by them\n    /// @param _index A counter less than `balanceOf(_owner)`\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n    /// (sort order not specified)\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "lib/forge-std/src/interfaces/IMulticall3.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\npragma experimental ABIEncoderV2;\n\ninterface IMulticall3 {\n    struct Call {\n        address target;\n        bytes callData;\n    }\n\n    struct Call3 {\n        address target;\n        bool allowFailure;\n        bytes callData;\n    }\n\n    struct Call3Value {\n        address target;\n        bool allowFailure;\n        uint256 value;\n        bytes callData;\n    }\n\n    struct Result {\n        bool success;\n        bytes returnData;\n    }\n\n    function aggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes[] memory returnData);\n\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\n\n    function blockAndAggregate(Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n\n    function getBasefee() external view returns (uint256 basefee);\n\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\n\n    function getBlockNumber() external view returns (uint256 blockNumber);\n\n    function getChainId() external view returns (uint256 chainid);\n\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\n\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\n\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\n\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\n\n    function getEthBalance(address addr) external view returns (uint256 balance);\n\n    function getLastBlockHash() external view returns (bytes32 blockHash);\n\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (Result[] memory returnData);\n\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\n        external\n        payable\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\n}\n"
    },
    "lib/forge-std/src/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\n/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol\ncontract MockERC20 is IERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal _decimals;\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view override returns (uint8) {\n        return _decimals;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal _totalSupply;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    mapping(address => mapping(address => uint256)) internal _allowance;\n\n    function totalSupply() external view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) external view override returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal INITIAL_CHAIN_ID;\n\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               INITIALIZE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev A bool to track whether the contract has been initialized.\n    bool private initialized;\n\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\n    /// syntaxes, we add an initialization function that can be called only once.\n    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n\n        INITIAL_CHAIN_ID = _pureChainId();\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        initialized = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);\n\n        _balanceOf[from] = _sub(_balanceOf[from], amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        public\n        virtual\n    {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        address recoveredAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                            ),\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n        _allowance[recoveredAddress][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(_name)),\n                keccak256(\"1\"),\n                _pureChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        _totalSupply = _add(_totalSupply, amount);\n        _balanceOf[to] = _add(_balanceOf[to], amount);\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        _balanceOf[from] = _sub(_balanceOf[from], amount);\n        _totalSupply = _sub(_totalSupply, amount);\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MATH LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ERC20: addition overflow\");\n        return c;\n    }\n\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b, \"ERC20: subtraction underflow\");\n        return a - b;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\n    // Checker changed `chainid` from pure to view in 0.8.0.\n    function _viewChainId() private view returns (uint256 chainId) {\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\n        assembly {\n            chainId := chainid()\n        }\n\n        address(this); // Silence warnings in older Solc versions.\n    }\n\n    function _pureChainId() private pure returns (uint256 chainId) {\n        function() internal view returns (uint256) fnIn = _viewChainId;\n        function() internal pure returns (uint256) pureChainId;\n        assembly {\n            pureChainId := fnIn\n        }\n        chainId = pureChainId();\n    }\n}\n"
    },
    "lib/forge-std/src/mocks/MockERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nimport {IERC721Metadata, IERC721TokenReceiver} from \"../interfaces/IERC721.sol\";\n\n/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.\n/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol\ncontract MockERC721 is IERC721Metadata {\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string internal _name;\n\n    string internal _symbol;\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {}\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual override returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _getApproved;\n\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\n\n    function getApproved(uint256 id) public view virtual override returns (address) {\n        return _getApproved[id];\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _isApprovedForAll[owner][operator];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               INITIALIZE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev A bool to track whether the contract has been initialized.\n    bool private initialized;\n\n    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and\n    /// syntaxes, we add an initialization function that can be called only once.\n    function initialize(string memory name_, string memory symbol_) public {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n\n        _name = name_;\n        _symbol = symbol_;\n\n        initialized = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public payable virtual override {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        _getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(address from, address to, uint256 id) public payable virtual override {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        _balanceOf[from]--;\n\n        _balanceOf[to]++;\n\n        _ownerOf[id] = to;\n\n        delete _getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {\n        transferFrom(from, to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\")\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)\n        public\n        payable\n        virtual\n        override\n    {\n        transferFrom(from, to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165\n            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721\n            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n\n        _balanceOf[to]++;\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        _balanceOf[owner]--;\n\n        delete _ownerOf[id];\n\n        delete _getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\")\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n\n        require(\n            !_isContract(to)\n                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)\n                    == IERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                HELPERS\n    //////////////////////////////////////////////////////////////*/\n\n    function _isContract(address _addr) private view returns (bool) {\n        uint256 codeLength;\n\n        // Assembly required for versions < 0.8.0 to check extcodesize.\n        assembly {\n            codeLength := extcodesize(_addr)\n        }\n\n        return codeLength > 0;\n    }\n}\n"
    },
    "lib/forge-std/src/safeconsole.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\n/// @author philogy <https://github.com/philogy>\n/// @dev Code generated automatically by script.\nlibrary safeconsole {\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\n\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\n    // for the view-to-pure log trick.\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\n        function(uint256, uint256) internal pure pureSendLogPayload;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pureSendLogPayload := fnIn\n        }\n        pureSendLogPayload(offset, size);\n    }\n\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\n        }\n    }\n\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pureMemcopy := fnIn\n        }\n        pureMemcopy(fromOffset, toOffset, length);\n    }\n\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\n        }\n    }\n\n    function logMemory(uint256 offset, uint256 length) internal pure {\n        if (offset >= 0x60) {\n            // Sufficient memory before slice to prepare call header.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            /// @solidity memory-safe-assembly\n            assembly {\n                m0 := mload(sub(offset, 0x60))\n                m1 := mload(sub(offset, 0x40))\n                m2 := mload(sub(offset, 0x20))\n                // Selector of `log(bytes)`.\n                mstore(sub(offset, 0x60), 0x0be77f56)\n                mstore(sub(offset, 0x40), 0x20)\n                mstore(sub(offset, 0x20), length)\n            }\n            _sendLogPayload(offset - 0x44, length + 0x44);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(sub(offset, 0x60), m0)\n                mstore(sub(offset, 0x40), m1)\n                mstore(sub(offset, 0x20), m2)\n            }\n        } else {\n            // Insufficient space, so copy slice forward, add header and reverse.\n            bytes32 m0;\n            bytes32 m1;\n            bytes32 m2;\n            uint256 endOffset = offset + length;\n            /// @solidity memory-safe-assembly\n            assembly {\n                m0 := mload(add(endOffset, 0x00))\n                m1 := mload(add(endOffset, 0x20))\n                m2 := mload(add(endOffset, 0x40))\n            }\n            _memcopy(offset, offset + 0x60, length);\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Selector of `log(bytes)`.\n                mstore(add(offset, 0x00), 0x0be77f56)\n                mstore(add(offset, 0x20), 0x20)\n                mstore(add(offset, 0x40), length)\n            }\n            _sendLogPayload(offset + 0x1c, length + 0x44);\n            _memcopy(offset + 0x60, offset, length);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(endOffset, 0x00), m0)\n                mstore(add(endOffset, 0x20), m1)\n                mstore(add(endOffset, 0x40), m2)\n            }\n        }\n    }\n\n    function log(address p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(address)`.\n            mstore(0x00, 0x2c2ecbc2)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bool p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(bool)`.\n            mstore(0x00, 0x32458eed)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(uint256 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            // Selector of `log(uint256)`.\n            mstore(0x00, 0xf82c50f1)\n            mstore(0x20, p0)\n        }\n        _sendLogPayload(0x1c, 0x24);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n        }\n    }\n\n    function log(bytes32 p0) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(string)`.\n            mstore(0x00, 0x41304fac)\n            mstore(0x20, 0x20)\n            writeString(0x40, p0)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,address)`.\n            mstore(0x00, 0xdaf0d4aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,bool)`.\n            mstore(0x00, 0x75b605d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(address,uint256)`.\n            mstore(0x00, 0x8309e8a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(address p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,string)`.\n            mstore(0x00, 0x759f86bb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,address)`.\n            mstore(0x00, 0x853c4849)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,bool)`.\n            mstore(0x00, 0x2a110e83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(bool,uint256)`.\n            mstore(0x00, 0x399174d3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(bool p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,string)`.\n            mstore(0x00, 0x8feac525)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,address)`.\n            mstore(0x00, 0x69276c86)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,bool)`.\n            mstore(0x00, 0x1c9d7eb3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            // Selector of `log(uint256,uint256)`.\n            mstore(0x00, 0xf666715a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n        }\n        _sendLogPayload(0x1c, 0x44);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,string)`.\n            mstore(0x00, 0x643fd0df)\n            mstore(0x20, p0)\n            mstore(0x40, 0x40)\n            writeString(0x60, p1)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, address p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,address)`.\n            mstore(0x00, 0x319af333)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bool p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,bool)`.\n            mstore(0x00, 0xc3b55635)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(string,uint256)`.\n            mstore(0x00, 0xb60e72cc)\n            mstore(0x20, 0x40)\n            mstore(0x40, p1)\n            writeString(0x60, p0)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,string)`.\n            mstore(0x00, 0x4b5c4277)\n            mstore(0x20, 0x40)\n            mstore(0x40, 0x80)\n            writeString(0x60, p0)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,address)`.\n            mstore(0x00, 0x018c84c2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,bool)`.\n            mstore(0x00, 0xf2a66286)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,address,uint256)`.\n            mstore(0x00, 0x17fe6185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,address,string)`.\n            mstore(0x00, 0x007150be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,address)`.\n            mstore(0x00, 0xf11699ed)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,bool)`.\n            mstore(0x00, 0xeb830c92)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,bool,uint256)`.\n            mstore(0x00, 0x9c4f99fb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,bool,string)`.\n            mstore(0x00, 0x212255cc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,address)`.\n            mstore(0x00, 0x7bc0d848)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,bool)`.\n            mstore(0x00, 0x678209a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(address,uint256,uint256)`.\n            mstore(0x00, 0xb69bcaf6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,uint256,string)`.\n            mstore(0x00, 0xa1f2e8aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,address)`.\n            mstore(0x00, 0xf08744e8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,bool)`.\n            mstore(0x00, 0xcf020fb1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(address,string,uint256)`.\n            mstore(0x00, 0x67dd6ff1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(address,string,string)`.\n            mstore(0x00, 0xfb772265)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,address)`.\n            mstore(0x00, 0xd2763667)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,bool)`.\n            mstore(0x00, 0x18c9c746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,address,uint256)`.\n            mstore(0x00, 0x5f7b9afb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,address,string)`.\n            mstore(0x00, 0xde9a9270)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,address)`.\n            mstore(0x00, 0x1078f68d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,bool)`.\n            mstore(0x00, 0x50709698)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,bool,uint256)`.\n            mstore(0x00, 0x12f21602)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,bool,string)`.\n            mstore(0x00, 0x2555fa46)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,address)`.\n            mstore(0x00, 0x088ef9d2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,bool)`.\n            mstore(0x00, 0xe8defba9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(bool,uint256,uint256)`.\n            mstore(0x00, 0x37103367)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,uint256,string)`.\n            mstore(0x00, 0xc3fc3970)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,address)`.\n            mstore(0x00, 0x9591b953)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,bool)`.\n            mstore(0x00, 0xdbb4c247)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(bool,string,uint256)`.\n            mstore(0x00, 0x1093ee11)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(bool,string,string)`.\n            mstore(0x00, 0xb076847f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,address)`.\n            mstore(0x00, 0xbcfd9be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,bool)`.\n            mstore(0x00, 0x9b6ec042)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,address,uint256)`.\n            mstore(0x00, 0x5a9b5ed5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,address,string)`.\n            mstore(0x00, 0x63cb41f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,address)`.\n            mstore(0x00, 0x35085f7b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,bool)`.\n            mstore(0x00, 0x20718650)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,bool,uint256)`.\n            mstore(0x00, 0x20098014)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,bool,string)`.\n            mstore(0x00, 0x85775021)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,address)`.\n            mstore(0x00, 0x5c96b331)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,bool)`.\n            mstore(0x00, 0x4766da72)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            // Selector of `log(uint256,uint256,uint256)`.\n            mstore(0x00, 0xd1ed7a3c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n        }\n        _sendLogPayload(0x1c, 0x64);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,uint256,string)`.\n            mstore(0x00, 0x71d04af2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x60)\n            writeString(0x80, p2)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,address)`.\n            mstore(0x00, 0x7afac959)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,bool)`.\n            mstore(0x00, 0x4ceda75a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(uint256,string,uint256)`.\n            mstore(0x00, 0x37aa7d4c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, p2)\n            writeString(0x80, p1)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(uint256,string,string)`.\n            mstore(0x00, 0xb115611f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x60)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p1)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,address)`.\n            mstore(0x00, 0xfcec75e0)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,bool)`.\n            mstore(0x00, 0xc91d5ed4)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,address,uint256)`.\n            mstore(0x00, 0x0d26b925)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,address,string)`.\n            mstore(0x00, 0xe0e9ad4f)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,address)`.\n            mstore(0x00, 0x932bbb38)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,bool)`.\n            mstore(0x00, 0x850b7ad6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,bool,uint256)`.\n            mstore(0x00, 0xc95958d6)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,bool,string)`.\n            mstore(0x00, 0xe298f47d)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,address)`.\n            mstore(0x00, 0x1c7ec448)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,bool)`.\n            mstore(0x00, 0xca7733b1)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            // Selector of `log(string,uint256,uint256)`.\n            mstore(0x00, 0xca47c4eb)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n        }\n        _sendLogPayload(0x1c, 0xa4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,uint256,string)`.\n            mstore(0x00, 0x5970e089)\n            mstore(0x20, 0x60)\n            mstore(0x40, p1)\n            mstore(0x60, 0xa0)\n            writeString(0x80, p0)\n            writeString(0xc0, p2)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,address)`.\n            mstore(0x00, 0x95ed0195)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,bool)`.\n            mstore(0x00, 0xb0e0f9b5)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            // Selector of `log(string,string,uint256)`.\n            mstore(0x00, 0x5821efa1)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, p2)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n        }\n        _sendLogPayload(0x1c, 0xe4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            // Selector of `log(string,string,string)`.\n            mstore(0x00, 0x2ced7cef)\n            mstore(0x20, 0x60)\n            mstore(0x40, 0xa0)\n            mstore(0x60, 0xe0)\n            writeString(0x80, p0)\n            writeString(0xc0, p1)\n            writeString(0x100, p2)\n        }\n        _sendLogPayload(0x1c, 0x124);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n        }\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,address)`.\n            mstore(0x00, 0x665bf134)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,bool)`.\n            mstore(0x00, 0x0e378994)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,address,uint256)`.\n            mstore(0x00, 0x94250d77)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,address,string)`.\n            mstore(0x00, 0xf808da20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,address)`.\n            mstore(0x00, 0x9f1bc36e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,bool)`.\n            mstore(0x00, 0x2cd4134a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,bool,uint256)`.\n            mstore(0x00, 0x3971e78c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,bool,string)`.\n            mstore(0x00, 0xaa6540c8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,address)`.\n            mstore(0x00, 0x8da6def5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,bool)`.\n            mstore(0x00, 0x9b4254e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,address,uint256,uint256)`.\n            mstore(0x00, 0xbe553481)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,uint256,string)`.\n            mstore(0x00, 0xfdb4f990)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,address)`.\n            mstore(0x00, 0x8f736d16)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,bool)`.\n            mstore(0x00, 0x6f1a594e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,address,string,uint256)`.\n            mstore(0x00, 0xef1cefe7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,address,string,string)`.\n            mstore(0x00, 0x21bdaf25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,address)`.\n            mstore(0x00, 0x660375dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,bool)`.\n            mstore(0x00, 0xa6f50b0f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,address,uint256)`.\n            mstore(0x00, 0xa75c59de)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,address,string)`.\n            mstore(0x00, 0x2dd778e6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,address)`.\n            mstore(0x00, 0xcf394485)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,bool)`.\n            mstore(0x00, 0xcac43479)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,bool,uint256)`.\n            mstore(0x00, 0x8c4e5de6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,bool,string)`.\n            mstore(0x00, 0xdfc4a2e8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,address)`.\n            mstore(0x00, 0xccf790a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,bool)`.\n            mstore(0x00, 0xc4643e20)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,bool,uint256,uint256)`.\n            mstore(0x00, 0x386ff5f4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,uint256,string)`.\n            mstore(0x00, 0x0aa6cfad)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,address)`.\n            mstore(0x00, 0x19fd4956)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,bool)`.\n            mstore(0x00, 0x50ad461d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,bool,string,uint256)`.\n            mstore(0x00, 0x80e6a20b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,bool,string,string)`.\n            mstore(0x00, 0x475c5c33)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,address)`.\n            mstore(0x00, 0x478d1c62)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,bool)`.\n            mstore(0x00, 0xa1bcc9b3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,address,uint256)`.\n            mstore(0x00, 0x100f650e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,address,string)`.\n            mstore(0x00, 0x1da986ea)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,address)`.\n            mstore(0x00, 0xa31bfdcc)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,bool)`.\n            mstore(0x00, 0x3bf5e537)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,bool,uint256)`.\n            mstore(0x00, 0x22f6b999)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,bool,string)`.\n            mstore(0x00, 0xc5ad85f9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,address)`.\n            mstore(0x00, 0x20e3984d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,bool)`.\n            mstore(0x00, 0x66f1bc67)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(address,uint256,uint256,uint256)`.\n            mstore(0x00, 0x34f0e636)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,uint256,string)`.\n            mstore(0x00, 0x4a28c017)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,address)`.\n            mstore(0x00, 0x5c430d47)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,bool)`.\n            mstore(0x00, 0xcf18105c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,uint256,string,uint256)`.\n            mstore(0x00, 0xbf01f891)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,uint256,string,string)`.\n            mstore(0x00, 0x88a8c406)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,address)`.\n            mstore(0x00, 0x0d36fa20)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,bool)`.\n            mstore(0x00, 0x0df12b76)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,address,uint256)`.\n            mstore(0x00, 0x457fe3cf)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,address,string)`.\n            mstore(0x00, 0xf7e36245)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,address)`.\n            mstore(0x00, 0x205871c2)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,bool)`.\n            mstore(0x00, 0x5f1d5c9f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,bool,uint256)`.\n            mstore(0x00, 0x515e38b6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,bool,string)`.\n            mstore(0x00, 0xbc0b61fe)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,address)`.\n            mstore(0x00, 0x63183678)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,bool)`.\n            mstore(0x00, 0x0ef7e050)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(address,string,uint256,uint256)`.\n            mstore(0x00, 0x1dc8e1b8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,uint256,string)`.\n            mstore(0x00, 0x448830a8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,address)`.\n            mstore(0x00, 0xa04e2f87)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,bool)`.\n            mstore(0x00, 0x35a5071f)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(address,string,string,uint256)`.\n            mstore(0x00, 0x159f8927)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(address,string,string,string)`.\n            mstore(0x00, 0x5d02c50b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,address)`.\n            mstore(0x00, 0x1d14d001)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,bool)`.\n            mstore(0x00, 0x46600be0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,address,uint256)`.\n            mstore(0x00, 0x0c66d1be)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,address,string)`.\n            mstore(0x00, 0xd812a167)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,address)`.\n            mstore(0x00, 0x1c41a336)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,bool)`.\n            mstore(0x00, 0x6a9c478b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,bool,uint256)`.\n            mstore(0x00, 0x07831502)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,bool,string)`.\n            mstore(0x00, 0x4a66cb34)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,address)`.\n            mstore(0x00, 0x136b05dd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,bool)`.\n            mstore(0x00, 0xd6019f1c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,address,uint256,uint256)`.\n            mstore(0x00, 0x7bf181a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,uint256,string)`.\n            mstore(0x00, 0x51f09ff8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,address)`.\n            mstore(0x00, 0x6f7c603e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,bool)`.\n            mstore(0x00, 0xe2bfd60b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,address,string,uint256)`.\n            mstore(0x00, 0xc21f64c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,address,string,string)`.\n            mstore(0x00, 0xa73c1db6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,address)`.\n            mstore(0x00, 0xf4880ea4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,bool)`.\n            mstore(0x00, 0xc0a302d8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,address,uint256)`.\n            mstore(0x00, 0x4c123d57)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,address,string)`.\n            mstore(0x00, 0xa0a47963)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,address)`.\n            mstore(0x00, 0x8c329b1a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,bool)`.\n            mstore(0x00, 0x3b2a5ce0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,bool,uint256)`.\n            mstore(0x00, 0x6d7045c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,bool,string)`.\n            mstore(0x00, 0x2ae408d4)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,address)`.\n            mstore(0x00, 0x54a7a9a0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,bool)`.\n            mstore(0x00, 0x619e4d0e)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,bool,uint256,uint256)`.\n            mstore(0x00, 0x0bb00eab)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,uint256,string)`.\n            mstore(0x00, 0x7dd4d0e0)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,address)`.\n            mstore(0x00, 0xf9ad2b89)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,bool)`.\n            mstore(0x00, 0xb857163a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,bool,string,uint256)`.\n            mstore(0x00, 0xe3a9ca2f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,bool,string,string)`.\n            mstore(0x00, 0x6d1e8751)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,address)`.\n            mstore(0x00, 0x26f560a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,bool)`.\n            mstore(0x00, 0xb4c314ff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,address,uint256)`.\n            mstore(0x00, 0x1537dc87)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,address,string)`.\n            mstore(0x00, 0x1bb3b09a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,address)`.\n            mstore(0x00, 0x9acd3616)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,bool)`.\n            mstore(0x00, 0xceb5f4d7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,bool,uint256)`.\n            mstore(0x00, 0x7f9bbca2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,bool,string)`.\n            mstore(0x00, 0x9143dbb1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,address)`.\n            mstore(0x00, 0x00dd87b9)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,bool)`.\n            mstore(0x00, 0xbe984353)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(bool,uint256,uint256,uint256)`.\n            mstore(0x00, 0x374bb4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,uint256,string)`.\n            mstore(0x00, 0x8e69fb5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,address)`.\n            mstore(0x00, 0xfedd1fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,bool)`.\n            mstore(0x00, 0xe5e70b2b)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,uint256,string,uint256)`.\n            mstore(0x00, 0x6a1199e2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,uint256,string,string)`.\n            mstore(0x00, 0xf5bc2249)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,address)`.\n            mstore(0x00, 0x2b2b18dc)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,bool)`.\n            mstore(0x00, 0x6dd434ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,address,uint256)`.\n            mstore(0x00, 0xa5cada94)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,address,string)`.\n            mstore(0x00, 0x12d6c788)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,address)`.\n            mstore(0x00, 0x538e06ab)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,bool)`.\n            mstore(0x00, 0xdc5e935b)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,bool,uint256)`.\n            mstore(0x00, 0x1606a393)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,bool,string)`.\n            mstore(0x00, 0x483d0416)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,address)`.\n            mstore(0x00, 0x1596a1ce)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,bool)`.\n            mstore(0x00, 0x6b0e5d53)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(bool,string,uint256,uint256)`.\n            mstore(0x00, 0x28863fcb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,uint256,string)`.\n            mstore(0x00, 0x1ad96de6)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,address)`.\n            mstore(0x00, 0x97d394d8)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,bool)`.\n            mstore(0x00, 0x1e4b87e5)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(bool,string,string,uint256)`.\n            mstore(0x00, 0x7be0c3eb)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(bool,string,string,string)`.\n            mstore(0x00, 0x1762e32a)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,address)`.\n            mstore(0x00, 0x2488b414)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,bool)`.\n            mstore(0x00, 0x091ffaf5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,address,uint256)`.\n            mstore(0x00, 0x736efbb6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,address,string)`.\n            mstore(0x00, 0x031c6f73)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,address)`.\n            mstore(0x00, 0xef72c513)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,bool)`.\n            mstore(0x00, 0xe351140f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,bool,uint256)`.\n            mstore(0x00, 0x5abd992a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,bool,string)`.\n            mstore(0x00, 0x90fb06aa)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,address)`.\n            mstore(0x00, 0x15c127b5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,bool)`.\n            mstore(0x00, 0x5f743a7c)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,address,uint256,uint256)`.\n            mstore(0x00, 0x0c9cd9c1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,uint256,string)`.\n            mstore(0x00, 0xddb06521)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,address)`.\n            mstore(0x00, 0x9cba8fff)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,bool)`.\n            mstore(0x00, 0xcc32ab07)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,address,string,uint256)`.\n            mstore(0x00, 0x46826b5d)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,address,string,string)`.\n            mstore(0x00, 0x3e128ca3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,address)`.\n            mstore(0x00, 0xa1ef4cbb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,bool)`.\n            mstore(0x00, 0x454d54a5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,address,uint256)`.\n            mstore(0x00, 0x078287f5)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,address,string)`.\n            mstore(0x00, 0xade052c7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,address)`.\n            mstore(0x00, 0x69640b59)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,bool)`.\n            mstore(0x00, 0xb6f577a1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,bool,uint256)`.\n            mstore(0x00, 0x7464ce23)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,bool,string)`.\n            mstore(0x00, 0xdddb9561)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,address)`.\n            mstore(0x00, 0x88cb6041)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,bool)`.\n            mstore(0x00, 0x91a02e2a)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,bool,uint256,uint256)`.\n            mstore(0x00, 0xc6acc7a8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,uint256,string)`.\n            mstore(0x00, 0xde03e774)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,address)`.\n            mstore(0x00, 0xef529018)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,bool)`.\n            mstore(0x00, 0xeb928d7f)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,bool,string,uint256)`.\n            mstore(0x00, 0x2c1d0746)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,bool,string,string)`.\n            mstore(0x00, 0x68c8b8bd)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,address)`.\n            mstore(0x00, 0x56a5d1b1)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,bool)`.\n            mstore(0x00, 0x15cac476)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,address,uint256)`.\n            mstore(0x00, 0x88f6e4b2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,address,string)`.\n            mstore(0x00, 0x6cde40b8)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,address)`.\n            mstore(0x00, 0x9a816a83)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,bool)`.\n            mstore(0x00, 0xab085ae6)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,bool,uint256)`.\n            mstore(0x00, 0xeb7f6fd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,bool,string)`.\n            mstore(0x00, 0xa5b4fc99)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,address)`.\n            mstore(0x00, 0xfa8185af)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,bool)`.\n            mstore(0x00, 0xc598d185)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        /// @solidity memory-safe-assembly\n        assembly {\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\n            mstore(0x00, 0x193fb800)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n        }\n        _sendLogPayload(0x1c, 0x84);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,uint256,string)`.\n            mstore(0x00, 0x59cfcbe3)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0x80)\n            writeString(0xa0, p3)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,address)`.\n            mstore(0x00, 0x42d21db7)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,bool)`.\n            mstore(0x00, 0x7af6ab25)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,uint256,string,uint256)`.\n            mstore(0x00, 0x5da297eb)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, p3)\n            writeString(0xa0, p2)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,uint256,string,string)`.\n            mstore(0x00, 0x27d8afd2)\n            mstore(0x20, p0)\n            mstore(0x40, p1)\n            mstore(0x60, 0x80)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p2)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,address)`.\n            mstore(0x00, 0x6168ed61)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,bool)`.\n            mstore(0x00, 0x90c30a56)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,address,uint256)`.\n            mstore(0x00, 0xe8d3018d)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,address,string)`.\n            mstore(0x00, 0x9c3adfa1)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,address)`.\n            mstore(0x00, 0xae2ec581)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,bool)`.\n            mstore(0x00, 0xba535d9c)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,bool,uint256)`.\n            mstore(0x00, 0xcf009880)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,bool,string)`.\n            mstore(0x00, 0xd2d423cd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,address)`.\n            mstore(0x00, 0x3b2279b4)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,bool)`.\n            mstore(0x00, 0x691a8f74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(uint256,string,uint256,uint256)`.\n            mstore(0x00, 0x82c25b74)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,uint256,string)`.\n            mstore(0x00, 0xb7b914ca)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p1)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,address)`.\n            mstore(0x00, 0xd583c602)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,bool)`.\n            mstore(0x00, 0xb3a6b6bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(uint256,string,string,uint256)`.\n            mstore(0x00, 0xb028c9bd)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(uint256,string,string,string)`.\n            mstore(0x00, 0x21ad0683)\n            mstore(0x20, p0)\n            mstore(0x40, 0x80)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p1)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,address)`.\n            mstore(0x00, 0xed8f28f6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,bool)`.\n            mstore(0x00, 0xb59dbd60)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,address,uint256)`.\n            mstore(0x00, 0x8ef3f399)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,address,string)`.\n            mstore(0x00, 0x800a1c67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,address)`.\n            mstore(0x00, 0x223603bd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,bool)`.\n            mstore(0x00, 0x79884c2b)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,bool,uint256)`.\n            mstore(0x00, 0x3e9f866a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,bool,string)`.\n            mstore(0x00, 0x0454c079)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,address)`.\n            mstore(0x00, 0x63fb8bc5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,bool)`.\n            mstore(0x00, 0xfc4845f0)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,address,uint256,uint256)`.\n            mstore(0x00, 0xf8f51b1e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,uint256,string)`.\n            mstore(0x00, 0x5a477632)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,address)`.\n            mstore(0x00, 0xaabc9a31)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,bool)`.\n            mstore(0x00, 0x5f15d28c)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,address,string,uint256)`.\n            mstore(0x00, 0x91d1112e)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,address,string,string)`.\n            mstore(0x00, 0x245986f2)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,address)`.\n            mstore(0x00, 0x33e9dd1d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,bool)`.\n            mstore(0x00, 0x958c28c6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,address,uint256)`.\n            mstore(0x00, 0x5d08bb05)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,address,string)`.\n            mstore(0x00, 0x2d8e33a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,address)`.\n            mstore(0x00, 0x7190a529)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,bool)`.\n            mstore(0x00, 0x895af8c5)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,bool,uint256)`.\n            mstore(0x00, 0x8e3f78a9)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,bool,string)`.\n            mstore(0x00, 0x9d22d5dd)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,address)`.\n            mstore(0x00, 0x935e09bf)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,bool)`.\n            mstore(0x00, 0x8af7cf8a)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,bool,uint256,uint256)`.\n            mstore(0x00, 0x64b5bb67)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,uint256,string)`.\n            mstore(0x00, 0x742d6ee7)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,address)`.\n            mstore(0x00, 0xe0625b29)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,bool)`.\n            mstore(0x00, 0x3f8a701d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,bool,string,uint256)`.\n            mstore(0x00, 0x24f91465)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,bool,string,string)`.\n            mstore(0x00, 0xa826caeb)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,address)`.\n            mstore(0x00, 0x5ea2b7ae)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,bool)`.\n            mstore(0x00, 0x82112a42)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,address,uint256)`.\n            mstore(0x00, 0x4f04fdc6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,address,string)`.\n            mstore(0x00, 0x9ffb2f93)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,address)`.\n            mstore(0x00, 0xe0e95b98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,bool)`.\n            mstore(0x00, 0x354c36d6)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,bool,uint256)`.\n            mstore(0x00, 0xe41b6f6f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,bool,string)`.\n            mstore(0x00, 0xabf73a98)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,address)`.\n            mstore(0x00, 0xe21de278)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,bool)`.\n            mstore(0x00, 0x7626db92)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            // Selector of `log(string,uint256,uint256,uint256)`.\n            mstore(0x00, 0xa7a87853)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n        }\n        _sendLogPayload(0x1c, 0xc4);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,uint256,string)`.\n            mstore(0x00, 0x854b3496)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, p2)\n            mstore(0x80, 0xc0)\n            writeString(0xa0, p0)\n            writeString(0xe0, p3)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,address)`.\n            mstore(0x00, 0x7c4632a4)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,bool)`.\n            mstore(0x00, 0x7d24491d)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,uint256,string,uint256)`.\n            mstore(0x00, 0xc67ea9d1)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,uint256,string,string)`.\n            mstore(0x00, 0x5ab84e1f)\n            mstore(0x20, 0x80)\n            mstore(0x40, p1)\n            mstore(0x60, 0xc0)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p2)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,address)`.\n            mstore(0x00, 0x439c7bef)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,bool)`.\n            mstore(0x00, 0x5ccd4e37)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,address,uint256)`.\n            mstore(0x00, 0x7cc3c607)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,address,string)`.\n            mstore(0x00, 0xeb1bff80)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,address)`.\n            mstore(0x00, 0xc371c7db)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,bool)`.\n            mstore(0x00, 0x40785869)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,bool,uint256)`.\n            mstore(0x00, 0xd6aefad2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,bool,string)`.\n            mstore(0x00, 0x5e84b0ea)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,address)`.\n            mstore(0x00, 0x1023f7b2)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,bool)`.\n            mstore(0x00, 0xc3a8a654)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            // Selector of `log(string,string,uint256,uint256)`.\n            mstore(0x00, 0xf45d7d2c)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n        }\n        _sendLogPayload(0x1c, 0x104);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,uint256,string)`.\n            mstore(0x00, 0x5d1a971a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, p2)\n            mstore(0x80, 0x100)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p3)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,address)`.\n            mstore(0x00, 0x6d572f44)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,bool)`.\n            mstore(0x00, 0x2c1754ed)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            // Selector of `log(string,string,string,uint256)`.\n            mstore(0x00, 0x8eafb02b)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, p3)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n        }\n        _sendLogPayload(0x1c, 0x144);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n        }\n    }\n\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\n        bytes32 m0;\n        bytes32 m1;\n        bytes32 m2;\n        bytes32 m3;\n        bytes32 m4;\n        bytes32 m5;\n        bytes32 m6;\n        bytes32 m7;\n        bytes32 m8;\n        bytes32 m9;\n        bytes32 m10;\n        bytes32 m11;\n        bytes32 m12;\n        /// @solidity memory-safe-assembly\n        assembly {\n            function writeString(pos, w) {\n                let length := 0\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\n                mstore(pos, length)\n                let shift := sub(256, shl(3, length))\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\n            }\n            m0 := mload(0x00)\n            m1 := mload(0x20)\n            m2 := mload(0x40)\n            m3 := mload(0x60)\n            m4 := mload(0x80)\n            m5 := mload(0xa0)\n            m6 := mload(0xc0)\n            m7 := mload(0xe0)\n            m8 := mload(0x100)\n            m9 := mload(0x120)\n            m10 := mload(0x140)\n            m11 := mload(0x160)\n            m12 := mload(0x180)\n            // Selector of `log(string,string,string,string)`.\n            mstore(0x00, 0xde68f20a)\n            mstore(0x20, 0x80)\n            mstore(0x40, 0xc0)\n            mstore(0x60, 0x100)\n            mstore(0x80, 0x140)\n            writeString(0xa0, p0)\n            writeString(0xe0, p1)\n            writeString(0x120, p2)\n            writeString(0x160, p3)\n        }\n        _sendLogPayload(0x1c, 0x184);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, m0)\n            mstore(0x20, m1)\n            mstore(0x40, m2)\n            mstore(0x60, m3)\n            mstore(0x80, m4)\n            mstore(0xa0, m5)\n            mstore(0xc0, m6)\n            mstore(0xe0, m7)\n            mstore(0x100, m8)\n            mstore(0x120, m9)\n            mstore(0x140, m10)\n            mstore(0x160, m11)\n            mstore(0x180, m12)\n        }\n    }\n}\n"
    },
    "script/CommonDeployer.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {Root} from \"src/common/Root.sol\";\nimport {GasService} from \"src/common/GasService.sol\";\nimport {Gateway} from \"src/common/Gateway.sol\";\nimport {Guardian, ISafe} from \"src/common/Guardian.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {MessageProcessor} from \"src/common/MessageProcessor.sol\";\nimport {MessageDispatcher} from \"src/common/MessageDispatcher.sol\";\nimport {TokenRecoverer} from \"src/common/TokenRecoverer.sol\";\n\nimport {JsonRegistry} from \"script/utils/JsonRegistry.s.sol\";\n\nimport \"forge-std/Script.sol\";\n\nstring constant MESSAGE_COST_ENV = \"MESSAGE_COST\";\nstring constant MAX_BATCH_SIZE_ENV = \"MAX_BATCH_SIZE\";\n\nabstract contract CommonDeployer is Script, JsonRegistry {\n    uint256 constant DELAY = 48 hours;\n    bytes32 immutable SALT;\n    uint128 constant FALLBACK_MSG_COST = uint128(0.02 ether); // in Weight\n    uint128 constant FALLBACK_MAX_BATCH_SIZE = uint128(10_000_000 ether); // 10M in Weight\n\n    IAdapter[] adapters;\n\n    ISafe public adminSafe;\n    Root public root;\n    TokenRecoverer public tokenRecoverer;\n    Guardian public guardian;\n    GasService public gasService;\n    Gateway public gateway;\n    MessageProcessor public messageProcessor;\n    MessageDispatcher public messageDispatcher;\n\n    constructor() {\n        // If no salt is provided, a pseudo-random salt is generated,\n        // thus effectively making the deployment non-deterministic\n        SALT = vm.envOr(\n            \"DEPLOYMENT_SALT\", keccak256(abi.encodePacked(string(abi.encodePacked(blockhash(block.number - 1)))))\n        );\n    }\n\n    function deployCommon(uint16 centrifugeId, ISafe adminSafe_, address deployer, bool isTests) public {\n        if (address(root) != address(0)) {\n            return; // Already deployed. Make this method idempotent.\n        }\n\n        startDeploymentOutput(isTests);\n\n        uint128 messageGasLimit = uint128(vm.envOr(MESSAGE_COST_ENV, FALLBACK_MSG_COST));\n        uint128 maxBatchSize = uint128(vm.envOr(MAX_BATCH_SIZE_ENV, FALLBACK_MAX_BATCH_SIZE));\n\n        root = new Root(DELAY, deployer);\n        tokenRecoverer = new TokenRecoverer(root, deployer);\n\n        messageProcessor = new MessageProcessor(root, tokenRecoverer, deployer);\n\n        gasService = new GasService(maxBatchSize, messageGasLimit);\n        gateway = new Gateway(centrifugeId, root, gasService, deployer);\n\n        messageDispatcher = new MessageDispatcher(centrifugeId, root, gateway, tokenRecoverer, deployer);\n\n        adminSafe = adminSafe_;\n\n        // deployer is not actually an implementation of ISafe but for deployment this is not an issue\n        guardian = new Guardian(ISafe(deployer), root, messageDispatcher);\n\n        _commonRegister();\n        _commonRely();\n        _commonFile();\n    }\n\n    function _commonRegister() private {\n        register(\"root\", address(root));\n        register(\"adminSafe\", address(adminSafe));\n        register(\"guardian\", address(guardian));\n        register(\"gasService\", address(gasService));\n        register(\"gateway\", address(gateway));\n        register(\"messageProcessor\", address(messageProcessor));\n        register(\"messageDispatcher\", address(messageDispatcher));\n    }\n\n    function _commonRely() private {\n        root.rely(address(guardian));\n        root.rely(address(messageProcessor));\n        root.rely(address(messageDispatcher));\n        gateway.rely(address(root));\n        gateway.rely(address(guardian));\n        gateway.rely(address(messageDispatcher));\n        gateway.rely(address(messageProcessor));\n        messageDispatcher.rely(address(root));\n        messageProcessor.rely(address(gateway));\n        messageDispatcher.rely(address(guardian));\n        tokenRecoverer.rely(address(messageDispatcher));\n        tokenRecoverer.rely(address(messageProcessor));\n    }\n\n    function _commonFile() private {\n        messageProcessor.file(\"gateway\", address(gateway));\n        gateway.file(\"processor\", address(messageProcessor));\n    }\n\n    function wire(uint16 centrifugeId, IAdapter adapter, address deployer) public {\n        adapters.push(adapter);\n        gateway.file(\"adapters\", centrifugeId, adapters);\n        IAuth(address(adapter)).rely(address(root));\n        IAuth(address(adapter)).deny(deployer);\n    }\n\n    function removeCommonDeployerAccess(address deployer) public {\n        if (root.wards(deployer) == 0) {\n            return; // Already removed. Make this method idempotent.\n        }\n\n        guardian.file(\"safe\", address(adminSafe));\n\n        root.deny(deployer);\n        gateway.deny(deployer);\n        tokenRecoverer.deny(deployer);\n        messageProcessor.deny(deployer);\n        messageDispatcher.deny(deployer);\n    }\n}\n"
    },
    "script/FullDeployer.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ISafe} from \"src/common/Guardian.sol\";\n\nimport \"forge-std/Script.sol\";\nimport {HubDeployer} from \"script/HubDeployer.s.sol\";\nimport {VaultsDeployer} from \"script/VaultsDeployer.s.sol\";\n\ncontract FullDeployer is HubDeployer, VaultsDeployer {\n    function deployFull(uint16 centrifugeId, ISafe adminSafe_, address deployer, bool isTests) public {\n        deployHub(centrifugeId, adminSafe_, deployer, isTests);\n        deployVaults(centrifugeId, adminSafe_, deployer, isTests);\n    }\n\n    function removeFullDeployerAccess(address deployer) public {\n        removeHubDeployerAccess(deployer);\n        removeVaultsDeployerAccess(deployer);\n    }\n}\n"
    },
    "script/HubDeployer.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IdentityValuation} from \"src/misc/IdentityValuation.sol\";\n\nimport {ISafe} from \"src/common/Guardian.sol\";\nimport {Gateway} from \"src/common/Gateway.sol\";\nimport {Root} from \"src/common/Root.sol\";\n\nimport {AssetId, newAssetId} from \"src/common/types/AssetId.sol\";\nimport {HubRegistry} from \"src/hub/HubRegistry.sol\";\nimport {ShareClassManager} from \"src/hub/ShareClassManager.sol\";\nimport {Holdings} from \"src/hub/Holdings.sol\";\nimport {Accounting} from \"src/hub/Accounting.sol\";\nimport {Hub} from \"src/hub/Hub.sol\";\n\nimport \"forge-std/Script.sol\";\nimport {CommonDeployer} from \"script/CommonDeployer.s.sol\";\n\ncontract HubDeployer is CommonDeployer {\n    // Main contracts\n    HubRegistry public hubRegistry;\n    Accounting public accounting;\n    Holdings public holdings;\n    ShareClassManager public shareClassManager;\n    Hub public hub;\n\n    // Utilities\n    IdentityValuation public identityValuation;\n\n    // Data\n    AssetId public immutable USD = newAssetId(840);\n\n    function deployHub(uint16 centrifugeId, ISafe adminSafe_, address deployer, bool isTests) public {\n        deployCommon(centrifugeId, adminSafe_, deployer, isTests);\n\n        hubRegistry = new HubRegistry(deployer);\n        identityValuation = new IdentityValuation(hubRegistry, deployer);\n        accounting = new Accounting(deployer);\n        holdings = new Holdings(hubRegistry, deployer);\n        shareClassManager = new ShareClassManager(hubRegistry, deployer);\n        hub = new Hub(shareClassManager, hubRegistry, accounting, holdings, gateway, deployer);\n\n        _poolsRegister();\n        _poolsRely();\n        _poolsFile();\n        _poolsInitialConfig();\n    }\n\n    function _poolsRegister() private {\n        register(\"hubRegistry\", address(hubRegistry));\n        register(\"accounting\", address(accounting));\n        register(\"holdings\", address(holdings));\n        register(\"shareClassManager\", address(shareClassManager));\n        register(\"hub\", address(hub));\n        register(\"identityValuation\", address(identityValuation));\n    }\n\n    function _poolsRely() private {\n        // Rely hub\n        hubRegistry.rely(address(hub));\n        holdings.rely(address(hub));\n        accounting.rely(address(hub));\n        shareClassManager.rely(address(hub));\n        gateway.rely(address(hub));\n        messageDispatcher.rely(address(hub));\n\n        // Rely others on hub\n        hub.rely(address(messageProcessor));\n        hub.rely(address(messageDispatcher));\n        hub.rely(address(guardian));\n\n        // Rely root\n        hubRegistry.rely(address(root));\n        accounting.rely(address(root));\n        holdings.rely(address(root));\n        shareClassManager.rely(address(root));\n        hub.rely(address(root));\n        identityValuation.rely(address(root));\n    }\n\n    function _poolsFile() private {\n        messageProcessor.file(\"hub\", address(hub));\n        messageDispatcher.file(\"hub\", address(hub));\n\n        hub.file(\"sender\", address(messageDispatcher));\n\n        guardian.file(\"hub\", address(hub));\n    }\n\n    function _poolsInitialConfig() private {\n        hubRegistry.registerAsset(USD, 18);\n    }\n\n    function removeHubDeployerAccess(address deployer) public {\n        removeCommonDeployerAccess(deployer);\n\n        hubRegistry.deny(deployer);\n        accounting.deny(deployer);\n        holdings.deny(deployer);\n        shareClassManager.deny(deployer);\n        hub.deny(deployer);\n\n        identityValuation.deny(deployer);\n    }\n}\n"
    },
    "script/VaultsDeployer.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {ISafe} from \"src/common/Guardian.sol\";\nimport {Gateway} from \"src/common/Gateway.sol\";\n\nimport {AsyncRequestManager} from \"src/vaults/AsyncRequestManager.sol\";\nimport {BalanceSheet} from \"src/vaults/BalanceSheet.sol\";\nimport {TokenFactory} from \"src/vaults/factories/TokenFactory.sol\";\nimport {AsyncVaultFactory} from \"src/vaults/factories/AsyncVaultFactory.sol\";\nimport {SyncDepositVaultFactory} from \"src/vaults/factories/SyncDepositVaultFactory.sol\";\nimport {FreezeOnly} from \"src/hooks/FreezeOnly.sol\";\nimport {RedemptionRestrictions} from \"src/hooks/RedemptionRestrictions.sol\";\nimport {FullRestrictions} from \"src/hooks/FullRestrictions.sol\";\nimport {SyncRequestManager} from \"src/vaults/SyncRequestManager.sol\";\nimport {PoolManager} from \"src/vaults/PoolManager.sol\";\nimport {VaultRouter} from \"src/vaults/VaultRouter.sol\";\nimport {Escrow} from \"src/vaults/Escrow.sol\";\nimport {IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {PoolEscrowFactory} from \"src/vaults/factories/PoolEscrowFactory.sol\";\nimport {IVaultFactory} from \"src/vaults/interfaces/factories/IVaultFactory.sol\";\n\nimport \"forge-std/Script.sol\";\nimport {CommonDeployer} from \"script/CommonDeployer.s.sol\";\n\ncontract VaultsDeployer is CommonDeployer {\n    BalanceSheet public balanceSheet;\n    AsyncRequestManager public asyncRequestManager;\n    SyncRequestManager public syncRequestManager;\n    PoolManager public poolManager;\n    PoolEscrowFactory public poolEscrowFactory;\n    Escrow public routerEscrow;\n    Escrow public globalEscrow;\n    VaultRouter public vaultRouter;\n    AsyncVaultFactory public asyncVaultFactory;\n    SyncDepositVaultFactory public syncDepositVaultFactory;\n    TokenFactory public tokenFactory;\n\n    // Hooks\n    address public freezeOnlyHook;\n    address public redemptionRestrictionsHook;\n    address public fullRestrictionsHook;\n\n    function deployVaults(uint16 centrifugeId, ISafe adminSafe_, address deployer, bool isTests) public {\n        deployCommon(centrifugeId, adminSafe_, deployer, isTests);\n\n        poolEscrowFactory = new PoolEscrowFactory{salt: SALT}(address(root), deployer);\n        routerEscrow = new Escrow{salt: keccak256(abi.encodePacked(SALT, \"escrow2\"))}(deployer);\n        globalEscrow = new Escrow{salt: keccak256(abi.encodePacked(SALT, \"escrow3\"))}(deployer);\n        tokenFactory = new TokenFactory{salt: SALT}(address(root), deployer);\n\n        asyncRequestManager = new AsyncRequestManager(IEscrow(globalEscrow), address(root), deployer);\n        syncRequestManager = new SyncRequestManager(IEscrow(globalEscrow), address(root), deployer);\n        asyncVaultFactory = new AsyncVaultFactory(address(root), asyncRequestManager, deployer);\n        syncDepositVaultFactory =\n            new SyncDepositVaultFactory(address(root), syncRequestManager, asyncRequestManager, deployer);\n\n        IVaultFactory[] memory vaultFactories = new IVaultFactory[](2);\n        vaultFactories[0] = asyncVaultFactory;\n        vaultFactories[1] = syncDepositVaultFactory;\n\n        poolManager = new PoolManager(tokenFactory, deployer);\n        balanceSheet = new BalanceSheet(root, deployer);\n        vaultRouter = new VaultRouter(address(routerEscrow), gateway, poolManager, messageDispatcher, deployer);\n\n        // Hooks\n        freezeOnlyHook = address(new FreezeOnly{salt: SALT}(address(root), deployer));\n        fullRestrictionsHook = address(new FullRestrictions{salt: SALT}(address(root), deployer));\n        redemptionRestrictionsHook = address(new RedemptionRestrictions{salt: SALT}(address(root), deployer));\n\n        _vaultsRegister();\n        _vaultsEndorse();\n        _vaultsRely();\n        _vaultsFile();\n    }\n\n    function _vaultsRegister() private {\n        register(\"poolEscrowFactory\", address(poolEscrowFactory));\n        register(\"routerEscrow\", address(routerEscrow));\n        register(\"globalEscrow\", address(globalEscrow));\n        register(\"freezeOnlyHook\", address(freezeOnlyHook));\n        register(\"redemptionRestrictionsHook\", address(redemptionRestrictionsHook));\n        register(\"fullRestrictionsHook\", address(fullRestrictionsHook));\n        register(\"tokenFactory\", address(tokenFactory));\n        register(\"asyncRequestManager\", address(asyncRequestManager));\n        register(\"syncRequestManager\", address(syncRequestManager));\n        register(\"asyncVaultFactory\", address(asyncVaultFactory));\n        register(\"syncDepositVaultFactory\", address(syncDepositVaultFactory));\n        register(\"poolManager\", address(poolManager));\n        register(\"vaultRouter\", address(vaultRouter));\n        register(\"balanceSheet\", address(balanceSheet));\n    }\n\n    function _vaultsEndorse() private {\n        root.endorse(address(vaultRouter));\n        root.endorse(address(globalEscrow));\n        root.endorse(address(balanceSheet));\n    }\n\n    function _vaultsRely() private {\n        // Rely PoolManager\n        IAuth(asyncVaultFactory).rely(address(poolManager));\n        IAuth(syncDepositVaultFactory).rely(address(poolManager));\n        IAuth(tokenFactory).rely(address(poolManager));\n        asyncRequestManager.rely(address(poolManager));\n        syncRequestManager.rely(address(poolManager));\n        IAuth(freezeOnlyHook).rely(address(poolManager));\n        IAuth(fullRestrictionsHook).rely(address(poolManager));\n        IAuth(redemptionRestrictionsHook).rely(address(poolManager));\n        messageDispatcher.rely(address(poolManager));\n        poolEscrowFactory.rely(address(poolManager));\n        gateway.rely(address(poolManager));\n\n        // Rely async requests manager\n        balanceSheet.rely(address(asyncRequestManager));\n        messageDispatcher.rely(address(asyncRequestManager));\n        globalEscrow.rely(address(asyncRequestManager));\n\n        // Rely sync requests manager\n        balanceSheet.rely(address(syncRequestManager));\n        asyncRequestManager.rely(address(syncRequestManager));\n        globalEscrow.rely(address(syncRequestManager));\n\n        // Rely BalanceSheet\n        messageDispatcher.rely(address(balanceSheet));\n\n        // Rely Root\n        vaultRouter.rely(address(root));\n        poolManager.rely(address(root));\n        asyncRequestManager.rely(address(root));\n        syncRequestManager.rely(address(root));\n        balanceSheet.rely(address(root));\n        poolEscrowFactory.rely(address(root));\n        routerEscrow.rely(address(root));\n        globalEscrow.rely(address(root));\n        IAuth(asyncVaultFactory).rely(address(root));\n        IAuth(syncDepositVaultFactory).rely(address(root));\n        IAuth(tokenFactory).rely(address(root));\n        IAuth(freezeOnlyHook).rely(address(root));\n        IAuth(fullRestrictionsHook).rely(address(root));\n        IAuth(redemptionRestrictionsHook).rely(address(root));\n\n        // Rely gateway\n        asyncRequestManager.rely(address(gateway));\n        poolManager.rely(address(gateway));\n\n        // Rely others\n        routerEscrow.rely(address(vaultRouter));\n        syncRequestManager.rely(address(syncDepositVaultFactory));\n\n        // Rely messageProcessor\n        poolManager.rely(address(messageProcessor));\n        asyncRequestManager.rely(address(messageProcessor));\n        balanceSheet.rely(address(messageProcessor));\n\n        // Rely messageDispatcher\n        poolManager.rely(address(messageDispatcher));\n        asyncRequestManager.rely(address(messageDispatcher));\n        balanceSheet.rely(address(messageDispatcher));\n\n        // Rely VaultRouter\n        gateway.rely(address(vaultRouter));\n        poolManager.rely(address(vaultRouter));\n    }\n\n    function _vaultsFile() public {\n        messageDispatcher.file(\"poolManager\", address(poolManager));\n        messageDispatcher.file(\"investmentManager\", address(asyncRequestManager));\n        messageDispatcher.file(\"balanceSheet\", address(balanceSheet));\n\n        messageProcessor.file(\"poolManager\", address(poolManager));\n        messageProcessor.file(\"investmentManager\", address(asyncRequestManager));\n        messageProcessor.file(\"balanceSheet\", address(balanceSheet));\n\n        poolManager.file(\"gateway\", address(gateway));\n        poolManager.file(\"balanceSheet\", address(balanceSheet));\n        poolManager.file(\"sender\", address(messageDispatcher));\n        poolManager.file(\"poolEscrowFactory\", address(poolEscrowFactory));\n        poolManager.file(\"asyncRequestManager\", address(asyncRequestManager));\n        poolManager.file(\"syncRequestManager\", address(syncRequestManager));\n        poolManager.file(\"vaultFactory\", address(asyncVaultFactory), true);\n        poolManager.file(\"vaultFactory\", address(syncDepositVaultFactory), true);\n\n        asyncRequestManager.file(\"sender\", address(messageDispatcher));\n        asyncRequestManager.file(\"poolManager\", address(poolManager));\n        asyncRequestManager.file(\"balanceSheet\", address(balanceSheet));\n        asyncRequestManager.file(\"poolEscrowProvider\", address(poolEscrowFactory));\n\n        syncRequestManager.file(\"poolManager\", address(poolManager));\n        syncRequestManager.file(\"balanceSheet\", address(balanceSheet));\n        syncRequestManager.file(\"poolEscrowProvider\", address(poolEscrowFactory));\n\n        balanceSheet.file(\"poolManager\", address(poolManager));\n        balanceSheet.file(\"sender\", address(messageDispatcher));\n        balanceSheet.file(\"poolEscrowProvider\", address(poolEscrowFactory));\n\n        poolEscrowFactory.file(\"poolManager\", address(poolManager));\n        poolEscrowFactory.file(\"gateway\", address(gateway));\n        poolEscrowFactory.file(\"balanceSheet\", address(balanceSheet));\n        poolEscrowFactory.file(\"asyncRequestManager\", address(asyncRequestManager));\n    }\n\n    function removeVaultsDeployerAccess(address deployer) public {\n        removeCommonDeployerAccess(deployer);\n\n        IAuth(asyncVaultFactory).deny(deployer);\n        IAuth(syncDepositVaultFactory).deny(deployer);\n        IAuth(tokenFactory).deny(deployer);\n        IAuth(freezeOnlyHook).deny(deployer);\n        IAuth(fullRestrictionsHook).deny(deployer);\n        IAuth(redemptionRestrictionsHook).deny(deployer);\n        asyncRequestManager.deny(deployer);\n        syncRequestManager.deny(deployer);\n        poolManager.deny(deployer);\n        balanceSheet.deny(deployer);\n        poolEscrowFactory.deny(deployer);\n        routerEscrow.deny(deployer);\n        globalEscrow.deny(deployer);\n        vaultRouter.deny(deployer);\n    }\n}\n"
    },
    "script/adapters/Axelar.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {AxelarAdapter} from \"src/common/adapters/AxelarAdapter.sol\";\nimport {ISafe} from \"src/common/interfaces/IGuardian.sol\";\n\nimport {FullDeployer} from \"script/FullDeployer.s.sol\";\n\n// Script to deploy CP and CP with an AxelarScript Adapter.\ncontract AxelarDeployer is FullDeployer {\n    function run() public {\n        uint16 localCentrifugeId = uint16(vm.envUint(\"CENTRIFUGE_ID\"));\n        uint16 remoteCentrifugeId = uint16(vm.envUint(\"REMOTE_CENTRIFUGE_ID\"));\n        address axelarGateway = address(vm.envAddress(\"AXELAR_GATEWAY\"));\n        address axelarGasService = address(vm.envAddress(\"AXELAR_GAS_SERVICE\"));\n\n        vm.startBroadcast();\n\n        deployFull(localCentrifugeId, ISafe(vm.envAddress(\"ADMIN\")), msg.sender, false);\n\n        AxelarAdapter adapter = new AxelarAdapter(gateway, axelarGateway, axelarGasService, msg.sender);\n        wire(remoteCentrifugeId, adapter, msg.sender);\n\n        removeFullDeployerAccess(msg.sender);\n\n        vm.stopBroadcast();\n    }\n}\n"
    },
    "script/adapters/Localhost.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\n\nimport {ISafe} from \"src/common/interfaces/IGuardian.sol\";\nimport {VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId, newAssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {MessageLib, VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\n\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {SyncDepositVault} from \"src/vaults/SyncDepositVault.sol\";\nimport {IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\nimport {FullDeployer} from \"script/FullDeployer.s.sol\";\n\n// Script to deploy Hub and Vaults with a Localhost Adapter.\ncontract LocalhostDeployer is FullDeployer {\n    using CastLib for address;\n    using MessageLib for *;\n\n    function run() public {\n        uint16 centrifugeId = uint16(vm.envUint(\"CENTRIFUGE_ID\"));\n\n        vm.startBroadcast();\n\n        deployFull(centrifugeId, ISafe(vm.envAddress(\"ADMIN\")), msg.sender, false);\n\n        // Since `wire()` is not called, separately adding the safe here\n        guardian.file(\"safe\", address(adminSafe));\n\n        saveDeploymentOutput();\n\n        _configureTestData(centrifugeId);\n\n        vm.stopBroadcast();\n    }\n\n    function _configureTestData(uint16 centrifugeId) internal {\n        // Deploy and register test USDC\n        ERC20 token = new ERC20(6);\n        token.file(\"name\", \"USD Coin\");\n        token.file(\"symbol\", \"USDC\");\n        token.mint(msg.sender, 10_000_000e6);\n        poolManager.registerAsset(centrifugeId, address(token), 0);\n\n        AssetId assetId = newAssetId(centrifugeId, 1);\n\n        _deployAsyncVault(centrifugeId, token, assetId);\n        _deploySyncDepositVault(centrifugeId, token, assetId);\n    }\n\n    function _deployAsyncVault(uint16 centrifugeId, ERC20 token, AssetId assetId) internal {\n        PoolId poolId = hubRegistry.poolId(centrifugeId, 1);\n        hub.createPool(poolId, msg.sender, USD);\n        hub.updateManager(poolId, vm.envAddress(\"ADMIN\"), true);\n        ShareClassId scId = shareClassManager.previewNextShareClassId(poolId);\n\n        D18 navPerShare = d18(1, 1);\n\n        hub.setPoolMetadata(poolId, bytes(\"Testing pool\"));\n        hub.addShareClass(poolId, \"Tokenized MMF\", \"MMF\", bytes32(bytes(\"1\")));\n        hub.notifyPool(poolId, centrifugeId);\n        hub.notifyShareClass(poolId, scId, centrifugeId, bytes32(bytes20(redemptionRestrictionsHook)));\n\n        hub.createAccount(poolId, AccountId.wrap(0x01), true);\n        hub.createAccount(poolId, AccountId.wrap(0x02), false);\n        hub.createAccount(poolId, AccountId.wrap(0x03), false);\n        hub.createAccount(poolId, AccountId.wrap(0x04), false);\n        hub.createHolding(\n            poolId,\n            scId,\n            assetId,\n            identityValuation,\n            AccountId.wrap(0x01),\n            AccountId.wrap(0x02),\n            AccountId.wrap(0x03),\n            AccountId.wrap(0x04)\n        );\n\n        hub.updateContract(\n            poolId,\n            scId,\n            centrifugeId,\n            bytes32(bytes20(address(poolManager))),\n            MessageLib.UpdateContractVaultUpdate({\n                vaultOrFactory: bytes32(bytes20(address(asyncVaultFactory))),\n                assetId: assetId.raw(),\n                kind: uint8(VaultUpdateKind.DeployAndLink)\n            }).serialize()\n        );\n\n        hub.updatePricePerShare(poolId, scId, navPerShare);\n        hub.notifySharePrice(poolId, scId, centrifugeId);\n        hub.notifyAssetPrice(poolId, scId, assetId);\n\n        // Submit deposit request\n        IShareToken shareToken = IShareToken(poolManager.shareToken(poolId, scId));\n        IAsyncVault vault = IAsyncVault(shareToken.vault(address(token)));\n\n        token.approve(address(vault), 1_000_000e6);\n        vault.requestDeposit(1_000_000e6, msg.sender, msg.sender);\n\n        // Fulfill deposit request\n        hub.approveDeposits(poolId, scId, assetId, shareClassManager.nowDepositEpoch(scId, assetId), 1_000_000e6);\n        hub.issueShares(poolId, scId, assetId, shareClassManager.nowIssueEpoch(scId, assetId), d18(1, 1));\n\n        uint32 maxClaims = shareClassManager.maxDepositClaims(scId, msg.sender.toBytes32(), assetId);\n        hub.notifyDeposit(poolId, scId, assetId, msg.sender.toBytes32(), maxClaims);\n\n        // Claim deposit request\n        vault.mint(1_000_000e18, msg.sender);\n\n        // Withdraw principal\n        balanceSheet.withdraw(poolId, scId, address(token), 0, msg.sender, 1_000_000e6);\n\n        // Update price, deposit principal + yield\n        hub.updatePricePerShare(poolId, scId, d18(11, 10));\n        hub.notifySharePrice(poolId, scId, centrifugeId);\n        hub.notifyAssetPrice(poolId, scId, assetId);\n\n        token.approve(address(balanceSheet), 1_100_000e18);\n        balanceSheet.deposit(poolId, scId, address(token), 0, msg.sender, 1_100_000e6);\n\n        // Make sender a member to submit redeem request\n        hub.updateRestriction(\n            poolId,\n            scId,\n            centrifugeId,\n            MessageLib.UpdateRestrictionMember({user: bytes32(bytes20(msg.sender)), validUntil: type(uint64).max})\n                .serialize()\n        );\n\n        // Submit redeem request\n        vault.requestRedeem(1_000_000e18, msg.sender, msg.sender);\n\n        // Fulfill redeem request\n        hub.approveRedeems(poolId, scId, assetId, shareClassManager.nowRedeemEpoch(scId, assetId), 1_000_000e18);\n        hub.revokeShares(poolId, scId, assetId, shareClassManager.nowRevokeEpoch(scId, assetId), d18(11, 10));\n\n        hub.notifyRedeem(poolId, scId, assetId, bytes32(bytes20(msg.sender)), 1);\n\n        // Claim redeem request\n        vault.withdraw(1_100_000e6, msg.sender, msg.sender);\n    }\n\n    function _deploySyncDepositVault(uint16 centrifugeId, ERC20 token, AssetId assetId) internal {\n        PoolId poolId = hubRegistry.poolId(centrifugeId, 2);\n        hub.createPool(poolId, msg.sender, USD);\n        hub.updateManager(poolId, vm.envAddress(\"ADMIN\"), true);\n        ShareClassId scId = shareClassManager.previewNextShareClassId(poolId);\n\n        D18 navPerShare = d18(1, 1);\n\n        hub.setPoolMetadata(poolId, bytes(\"Testing pool\"));\n        hub.addShareClass(poolId, \"RWA Portfolio\", \"RWA\", bytes32(bytes(\"2\")));\n        hub.notifyPool(poolId, centrifugeId);\n        hub.notifyShareClass(poolId, scId, centrifugeId, bytes32(bytes20(redemptionRestrictionsHook)));\n\n        hub.createAccount(poolId, AccountId.wrap(0x01), true);\n        hub.createAccount(poolId, AccountId.wrap(0x02), false);\n        hub.createAccount(poolId, AccountId.wrap(0x03), false);\n        hub.createAccount(poolId, AccountId.wrap(0x04), false);\n        hub.createHolding(\n            poolId,\n            scId,\n            assetId,\n            identityValuation,\n            AccountId.wrap(0x01),\n            AccountId.wrap(0x02),\n            AccountId.wrap(0x03),\n            AccountId.wrap(0x04)\n        );\n\n        hub.updateContract(\n            poolId,\n            scId,\n            centrifugeId,\n            bytes32(bytes20(address(poolManager))),\n            MessageLib.UpdateContractVaultUpdate({\n                vaultOrFactory: bytes32(bytes20(address(syncDepositVaultFactory))),\n                assetId: assetId.raw(),\n                kind: uint8(VaultUpdateKind.DeployAndLink)\n            }).serialize()\n        );\n\n        hub.updatePricePerShare(poolId, scId, navPerShare);\n        hub.notifySharePrice(poolId, scId, centrifugeId);\n        hub.notifyAssetPrice(poolId, scId, assetId);\n\n        // Deposit\n        IShareToken shareToken = IShareToken(poolManager.shareToken(poolId, scId));\n        SyncDepositVault vault = SyncDepositVault(shareToken.vault(address(token)));\n\n        uint128 investAmount = 1_000_000e6;\n        token.approve(address(vault), investAmount);\n        vault.deposit(investAmount, msg.sender);\n    }\n}\n"
    },
    "script/adapters/Wormhole.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {WormholeAdapter} from \"src/common/adapters/WormholeAdapter.sol\";\nimport {ISafe} from \"src/common/interfaces/IGuardian.sol\";\n\nimport {FullDeployer} from \"script/FullDeployer.s.sol\";\n\n// Script to deploy CP and CP with an Wormhole Adapter.\ncontract WormholeDeployer is FullDeployer {\n    function run() public {\n        uint16 localCentrifugeId = uint16(vm.envUint(\"CENTRIFUGE_ID\"));\n        uint16 remoteCentrifugeId = uint16(vm.envUint(\"REMOTE_CENTRIFUGE_ID\"));\n        address relayer = address(vm.envAddress(\"WORMHOLE_RELAYER\"));\n\n        vm.startBroadcast();\n\n        deployFull(localCentrifugeId, ISafe(vm.envAddress(\"ADMIN\")), msg.sender, false);\n\n        WormholeAdapter adapter = new WormholeAdapter(gateway, relayer, msg.sender);\n        wire(remoteCentrifugeId, adapter, msg.sender);\n\n        removeFullDeployerAccess(msg.sender);\n\n        vm.stopBroadcast();\n    }\n}\n"
    },
    "script/utils/JsonRegistry.s.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Script.sol\";\nimport {console} from \"forge-std/console.sol\";\n\ncontract JsonRegistry is Script {\n    string deploymentOutput;\n    uint256 registeredContracts = 0;\n\n    uint64 startTime = uint64(block.timestamp);\n\n    function register(string memory name, address target) public {\n        deploymentOutput = (registeredContracts == 0)\n            ? string(abi.encodePacked(deploymentOutput, '    \"', name, '\": \"', vm.toString(target), '\"'))\n            : string(abi.encodePacked(deploymentOutput, ',\\n    \"', name, '\": \"', vm.toString(target), '\"'));\n\n        registeredContracts += 1;\n    }\n\n    function startDeploymentOutput(bool isTests) public {\n        deploymentOutput = '{\\n  \"contracts\": {\\n';\n\n        if (!isTests) {\n            console.log(\n                \"\\n\\n---------\\n\\nStarting deployment: %s_%s\\n\\n\", vm.toString(block.chainid), vm.toString(startTime)\n            );\n        }\n    }\n\n    function saveDeploymentOutput() public {\n        string memory path = string(\n            abi.encodePacked(\"./deployments/latest/\", vm.toString(block.chainid), \"_\", vm.toString(startTime), \".json\")\n        );\n        deploymentOutput = string(abi.encodePacked(deploymentOutput, \"\\n  }\\n}\\n\"));\n        vm.writeFile(path, deploymentOutput);\n    }\n}\n"
    },
    "src/common/GasService.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IGasService} from \"src/common/interfaces/IGasService.sol\";\n\n/// @title  GasService\n/// @notice This is a utility contract used to determine the execution gas limit\n///         for a payload being sent across all supported adapters.\ncontract GasService is IGasService {\n    uint128 internal immutable _maxBatchSize;\n    uint128 internal immutable _messageGasLimit;\n\n    constructor(uint128 maxBatchSize_, uint128 messageGasLimit) {\n        _maxBatchSize = maxBatchSize_;\n        _messageGasLimit = messageGasLimit;\n    }\n\n    /// @inheritdoc IGasService\n    function maxBatchSize(uint16) public view returns (uint128) {\n        return _maxBatchSize;\n    }\n\n    /// @inheritdoc IGasService\n    function gasLimit(uint16, bytes calldata) public view returns (uint128) {\n        return _messageGasLimit;\n    }\n}\n"
    },
    "src/common/Gateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {ArrayLib} from \"src/misc/libraries/ArrayLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {Recoverable, IRecoverable, ETH_ADDRESS} from \"src/misc/Recoverable.sol\";\nimport {TransientArrayLib} from \"src/misc/libraries/TransientArrayLib.sol\";\nimport {TransientBytesLib} from \"src/misc/libraries/TransientBytesLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {IGasService} from \"src/common/interfaces/IGasService.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {IMessageProcessor} from \"src/common/interfaces/IMessageProcessor.sol\";\nimport {IMessageSender} from \"src/common/interfaces/IMessageSender.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {IGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\n\n/// @title  Gateway\n/// @notice Routing contract that forwards outgoing messages to multiple adapters (1 full message, n-1 proofs)\n///         and validates that multiple adapters have confirmed a message.\n///\n///         Supports batching multiple messages, as well as paying for methods manually or through pool-level subsidies.\n///\n///         Supports processing multiple duplicate messages in parallel by storing counts of messages\n///         and proofs that have been received. Also implements a retry method for failed messages.\ncontract Gateway is Auth, Recoverable, IGateway {\n    using BytesLib for bytes;\n    using MathLib for uint256;\n    using MessageProofLib for *;\n    using ArrayLib for uint16[8];\n    using TransientStorageLib for bytes32;\n\n    uint8 public constant MAX_ADAPTER_COUNT = 8;\n    uint8 public constant PRIMARY_ADAPTER_ID = 1;\n    PoolId public constant GLOBAL_POT = PoolId.wrap(0);\n    uint256 public constant RECOVERY_CHALLENGE_PERIOD = 7 days;\n    bytes32 public constant BATCH_LOCATORS_SLOT = bytes32(uint256(keccak256(\"Centrifuge/batch-locators\")) - 1);\n\n    uint16 public immutable localCentrifugeId;\n\n    // Dependencies\n    IRoot public immutable root;\n    IGasService public gasService;\n    IMessageProcessor public processor;\n\n    // Outbound & payments\n    bool public transient isBatching;\n    uint256 public transient fuel;\n    address public transient transactionRefund;\n    mapping(PoolId => Funds) public subsidy;\n    mapping(uint16 centrifugeId => mapping(bytes32 batchHash => Underpaid)) public underpaid;\n\n    // Adapters\n    mapping(uint16 centrifugeId => IAdapter[]) public adapters;\n    mapping(uint16 centrifugeId => mapping(IAdapter adapter => Adapter)) internal _activeAdapters;\n\n    // Inbound & recoveries\n    mapping(uint16 centrifugeId => mapping(bytes32 messageHash => uint256)) public failedMessages;\n    mapping(uint16 centrifugeId => mapping(bytes32 batchHash => InboundBatch)) public inboundBatch;\n    mapping(uint16 centrifugeId => mapping(IAdapter adapter => mapping(bytes32 payloadHash => uint256 timestamp)))\n        public recoveries;\n\n    constructor(uint16 localCentrifugeId_, IRoot root_, IGasService gasService_, address deployer) Auth(deployer) {\n        localCentrifugeId = localCentrifugeId_;\n        root = root_;\n        gasService = gasService_;\n\n        setRefundAddress(GLOBAL_POT, IRecoverable(address(this)));\n    }\n\n    modifier pauseable() {\n        require(!root.paused(), Paused());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGateway\n    function file(bytes32 what, uint16 centrifugeId, IAdapter[] calldata addresses) external auth {\n        if (what == \"adapters\") {\n            uint8 quorum_ = addresses.length.toUint8();\n            require(quorum_ != 0, EmptyAdapterSet());\n            require(quorum_ <= MAX_ADAPTER_COUNT, ExceedsMax());\n\n            // Increment session id to reset pending votes\n            uint256 numAdapters = adapters[centrifugeId].length;\n            uint64 sessionId =\n                numAdapters > 0 ? _activeAdapters[centrifugeId][adapters[centrifugeId][0]].activeSessionId + 1 : 0;\n\n            // Disable old adapters\n            for (uint8 i; i < numAdapters; i++) {\n                delete _activeAdapters[centrifugeId][adapters[centrifugeId][i]];\n            }\n\n            // Enable new adapters, setting quorum to number of adapters\n            for (uint8 j; j < quorum_; j++) {\n                require(_activeAdapters[centrifugeId][addresses[j]].id == 0, NoDuplicatesAllowed());\n\n                // Ids are assigned sequentially starting at 1\n                _activeAdapters[centrifugeId][addresses[j]] = Adapter(j + 1, quorum_, sessionId);\n            }\n\n            adapters[centrifugeId] = addresses;\n        } else {\n            revert FileUnrecognizedParam();\n        }\n\n        emit File(what, centrifugeId, addresses);\n    }\n\n    /// @inheritdoc IGateway\n    function file(bytes32 what, address instance) external auth {\n        if (what == \"gasService\") gasService = IGasService(instance);\n        else if (what == \"processor\") processor = IMessageProcessor(instance);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, instance);\n    }\n\n    receive() external payable {\n        _subsidizePool(GLOBAL_POT, msg.sender, msg.value);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev Handle an inbound payload\n    function handle(uint16 centrifugeId, bytes calldata payload) external pauseable {\n        _handle(centrifugeId, payload, IAdapter(msg.sender), false);\n    }\n\n    function _handle(uint16 centrifugeId, bytes calldata payload, IAdapter adapter_, bool isRecovery) internal {\n        Adapter memory adapter = _activeAdapters[centrifugeId][adapter_];\n        require(adapter.id != 0, InvalidAdapter());\n\n        IMessageProcessor processor_ = processor;\n        if (processor_.isMessageRecovery(payload)) {\n            require(!isRecovery, RecoveryPayloadRecovered());\n            return processor_.handle(centrifugeId, payload);\n        }\n\n        bool isMessageProof = payload.toUint8(0) == MessageProofLib.MESSAGE_PROOF_ID;\n\n        // Verify adapter and parse message hash\n        bytes32 batchHash;\n        if (isMessageProof) {\n            require(adapter.id != PRIMARY_ADAPTER_ID, NonProofAdapter());\n\n            batchHash = payload.deserializeMessageProof();\n            bytes32 payloadId = keccak256(abi.encodePacked(centrifugeId, localCentrifugeId, batchHash));\n            emit HandleProof(centrifugeId, payloadId, batchHash, adapter_);\n        } else {\n            require(adapter.id == PRIMARY_ADAPTER_ID, NonBatchAdapter());\n\n            batchHash = keccak256(payload);\n            bytes32 payloadId = keccak256(abi.encodePacked(centrifugeId, localCentrifugeId, batchHash));\n            emit HandleBatch(centrifugeId, payloadId, payload, adapter_);\n        }\n\n        // Special case for gas efficiency\n        if (adapter.quorum == 1 && !isMessageProof) {\n            _handleBatch(centrifugeId, payload);\n            return;\n        }\n\n        InboundBatch storage state = inboundBatch[centrifugeId][batchHash];\n\n        if (adapter.activeSessionId != state.sessionId) {\n            // Clear votes from previous session\n            delete state.votes;\n            state.sessionId = adapter.activeSessionId;\n        }\n\n        // Increase vote\n        state.votes[adapter.id - 1]++;\n\n        if (state.votes.countNonZeroValues() >= adapter.quorum) {\n            // Reduce votes by quorum\n            state.votes.decreaseFirstNValues(adapter.quorum);\n\n            if (isMessageProof) {\n                _handleBatch(centrifugeId, state.pendingBatch);\n            } else {\n                _handleBatch(centrifugeId, payload);\n            }\n\n            // Only if there are no more pending messages, remove the pending message\n            if (state.votes.isEmpty()) {\n                delete state.pendingBatch;\n            }\n        } else if (!isMessageProof) {\n            state.pendingBatch = payload;\n        }\n    }\n\n    function _handleBatch(uint16 centrifugeId, bytes memory batch_) internal {\n        IMessageProcessor processor_ = processor;\n        bytes memory remaining = batch_;\n\n        while (remaining.length > 0) {\n            uint256 length = processor_.messageLength(remaining);\n            bytes memory message = remaining.slice(0, length);\n            remaining = remaining.slice(length, remaining.length - length);\n\n            try processor_.handle(centrifugeId, message) {\n                emit ExecuteMessage(centrifugeId, message);\n            } catch (bytes memory err) {\n                bytes32 messageHash = keccak256(message);\n                failedMessages[centrifugeId][messageHash]++;\n                emit FailMessage(centrifugeId, message, err);\n            }\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function retry(uint16 centrifugeId, bytes memory message) external pauseable {\n        bytes32 messageHash = keccak256(message);\n        require(failedMessages[centrifugeId][messageHash] > 0, NotFailedMessage());\n\n        processor.handle(centrifugeId, message);\n        failedMessages[centrifugeId][messageHash]--;\n\n        emit ExecuteMessage(centrifugeId, message);\n    }\n\n    /// @inheritdoc IGatewayHandler\n    function initiateRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external auth {\n        require(_activeAdapters[centrifugeId][adapter].id != 0, InvalidAdapter());\n        recoveries[centrifugeId][adapter][payloadHash] = block.timestamp + RECOVERY_CHALLENGE_PERIOD;\n        emit InitiateRecovery(centrifugeId, payloadHash, adapter);\n    }\n\n    /// @inheritdoc IGatewayHandler\n    function disputeRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external auth {\n        delete recoveries[centrifugeId][adapter][payloadHash];\n        emit DisputeRecovery(centrifugeId, payloadHash, adapter);\n    }\n\n    /// @inheritdoc IGateway\n    function executeRecovery(uint16 centrifugeId, IAdapter adapter, bytes calldata payload) external {\n        bytes32 payloadHash = keccak256(payload);\n        uint256 recovery = recoveries[centrifugeId][adapter][payloadHash];\n\n        require(recovery != 0, RecoveryNotInitiated());\n        require(recovery <= block.timestamp, RecoveryChallengePeriodNotEnded());\n\n        delete recoveries[centrifugeId][adapter][payloadHash];\n        _handle(centrifugeId, payload, adapter, true);\n        emit ExecuteRecovery(centrifugeId, payload, adapter);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageSender\n    function send(uint16 centrifugeId, bytes calldata message) external pauseable auth {\n        require(message.length > 0, EmptyMessage());\n\n        PoolId poolId = processor.messagePoolId(message);\n\n        emit PrepareMessage(centrifugeId, poolId, message);\n\n        if (isBatching) {\n            bytes32 batchSlot = _outboundBatchSlot(centrifugeId, poolId);\n            bytes memory previousMessage = TransientBytesLib.get(batchSlot);\n\n            bytes32 gasLimitSlot = _gasLimitSlot(centrifugeId, poolId);\n            uint128 newGasLimit = gasLimitSlot.tloadUint128() + gasService.gasLimit(centrifugeId, message);\n            require(newGasLimit <= gasService.maxBatchSize(centrifugeId), ExceedsMaxBatchSize());\n            gasLimitSlot.tstore(uint256(newGasLimit));\n\n            if (previousMessage.length == 0) {\n                TransientArrayLib.push(BATCH_LOCATORS_SLOT, _encodeLocator(centrifugeId, poolId));\n            }\n\n            TransientBytesLib.append(batchSlot, message);\n        } else {\n            _send(centrifugeId, poolId, message, gasService.gasLimit(centrifugeId, message));\n            _refundTransaction();\n        }\n    }\n\n    function _send(uint16 centrifugeId, PoolId poolId, bytes memory batch, uint128 batchGasLimit)\n        internal\n        returns (bool succeeded)\n    {\n        IAdapter[] memory adapters_ = adapters[centrifugeId];\n        require(adapters[centrifugeId].length != 0, EmptyAdapterSet());\n\n        SendData memory data = SendData({\n            batchHash: keccak256(batch),\n            payloadId: bytes32(\"\"),\n            gasCost: new uint256[](MAX_ADAPTER_COUNT)\n        });\n        data.payloadId = keccak256(abi.encodePacked(localCentrifugeId, centrifugeId, data.batchHash));\n\n        {\n            // Estimate gas usage\n            uint256 total;\n            for (uint256 i; i < adapters_.length; i++) {\n                data.gasCost[i] = adapters_[i].estimate(\n                    centrifugeId,\n                    i == PRIMARY_ADAPTER_ID - 1 ? batch : data.batchHash.serializeMessageProof(),\n                    batchGasLimit\n                );\n\n                total += data.gasCost[i];\n            }\n\n            // Ensure sufficient funds are available\n            if (transactionRefund != address(0)) {\n                require(total <= fuel, NotEnoughTransactionGas());\n                fuel -= total;\n            } else {\n                if (total > subsidy[poolId].value) {\n                    _requestPoolFunding(poolId);\n                }\n\n                if (total <= subsidy[poolId].value) {\n                    subsidy[poolId].value -= uint96(total);\n                } else {\n                    underpaid[centrifugeId][data.batchHash].counter++;\n                    underpaid[centrifugeId][data.batchHash].gasLimit = batchGasLimit;\n                    emit UnderpaidBatch(centrifugeId, batch);\n                    return false;\n                }\n            }\n        }\n\n        // Send batch and proofs\n        for (uint256 j; j < adapters_.length; j++) {\n            bytes32 adapterData = adapters_[j].send{value: data.gasCost[j]}(\n                centrifugeId,\n                j == PRIMARY_ADAPTER_ID - 1 ? batch : data.batchHash.serializeMessageProof(),\n                batchGasLimit,\n                transactionRefund != address(0) ? transactionRefund : address(subsidy[poolId].refund)\n            );\n\n            if (j == PRIMARY_ADAPTER_ID - 1) {\n                emit SendBatch(\n                    centrifugeId,\n                    data.payloadId,\n                    batch,\n                    adapters_[j],\n                    adapterData,\n                    transactionRefund != address(0) ? transactionRefund : address(subsidy[poolId].refund)\n                );\n            } else {\n                emit SendProof(\n                    centrifugeId,\n                    data.payloadId,\n                    data.batchHash,\n                    adapters_[j],\n                    adapterData\n                );\n            }\n        }\n\n        return true;\n    }\n\n    /// @inheritdoc IGateway\n    function repay(uint16 centrifugeId, bytes memory batch) external payable pauseable {\n        bytes32 batchHash = keccak256(batch);\n        Underpaid storage underpaid_ = underpaid[centrifugeId][batchHash];\n        require(underpaid_.counter > 0, NotUnderpaidBatch());\n\n        PoolId poolId = processor.messagePoolId(batch);\n        if (msg.value > 0) subsidizePool(poolId);\n\n        require(_send(centrifugeId, poolId, batch, underpaid_.gasLimit), InsufficientFundsForRepayment());\n        underpaid[centrifugeId][batchHash].counter--;\n\n        emit RepayBatch(centrifugeId, batch);\n    }\n\n    function _refundTransaction() internal {\n        if (transactionRefund == address(0)) return;\n\n        // Reset before external call\n        uint256 fuel_ = fuel;\n        address transactionRefund_ = transactionRefund;\n        fuel = 0;\n        transactionRefund = address(0);\n\n        if (fuel_ > 0) {\n            (bool success,) = payable(transactionRefund_).call{value: fuel_}(new bytes(0));\n\n            if (!success) {\n                // If refund fails, move remaining fuel to global pot\n                _subsidizePool(GLOBAL_POT, transactionRefund_, fuel_);\n            }\n        }\n    }\n\n    function _requestPoolFunding(PoolId poolId) internal {\n        IRecoverable refund = subsidy[poolId].refund;\n        if (!poolId.isNull() && address(refund) != address(0)) {\n            uint256 refundBalance = address(refund).balance;\n            if (refundBalance == 0) return;\n\n            // Send to the gateway GLOBAL_POT\n            refund.recoverTokens(ETH_ADDRESS, address(this), refundBalance);\n\n            // Extract from the GLOBAL_POT\n            subsidy[GLOBAL_POT].value -= uint96(refundBalance);\n            _subsidizePool(poolId, address(refund), refundBalance);\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function setRefundAddress(PoolId poolId, IRecoverable refund) public auth {\n        subsidy[poolId].refund = refund;\n        emit SetRefundAddress(poolId, refund);\n    }\n\n    /// @inheritdoc IGateway\n    function subsidizePool(PoolId poolId) public payable {\n        require(address(subsidy[poolId].refund) != address(0), RefundAddressNotSet());\n        _subsidizePool(poolId, msg.sender, msg.value);\n    }\n\n    function _subsidizePool(PoolId poolId, address who, uint256 value) internal {\n        subsidy[poolId].value += uint96(value);\n        emit SubsidizePool(poolId, who, value);\n    }\n\n    /// @inheritdoc IGateway\n    function payTransaction(address payer) external payable auth {\n        transactionRefund = payer;\n        fuel += msg.value;\n    }\n\n    /// @inheritdoc IGateway\n    function startBatching() external auth {\n        isBatching = true;\n    }\n\n    /// @inheritdoc IGateway\n    function endBatching() external auth {\n        require(isBatching, NoBatched());\n\n        bytes32[] memory locators = TransientArrayLib.getBytes32(BATCH_LOCATORS_SLOT);\n        for (uint256 i; i < locators.length; i++) {\n            (uint16 centrifugeId, PoolId poolId) = _parseLocator(locators[i]);\n            bytes32 outboundBatchSlot = _outboundBatchSlot(centrifugeId, poolId);\n            uint128 gasLimit = _gasLimitSlot(centrifugeId, poolId).tloadUint128();\n\n            _send(centrifugeId, poolId, TransientBytesLib.get(outboundBatchSlot), gasLimit);\n\n            TransientBytesLib.clear(outboundBatchSlot);\n            _gasLimitSlot(centrifugeId, poolId).tstore(uint256(0));\n        }\n\n        TransientArrayLib.clear(BATCH_LOCATORS_SLOT);\n        isBatching = false;\n\n        _refundTransaction();\n    }\n\n    function _encodeLocator(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return bytes32(abi.encodePacked(bytes2(centrifugeId), bytes8(poolId.raw())));\n    }\n\n    function _parseLocator(bytes32 locator) internal pure returns (uint16 centrifugeId, PoolId poolId) {\n        centrifugeId = uint16(bytes2(locator));\n        poolId = PoolId.wrap(uint64(bytes8(locator << 16)));\n    }\n\n    function _gasLimitSlot(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"batchGasLimit\", centrifugeId, poolId));\n    }\n\n    function _outboundBatchSlot(uint16 centrifugeId, PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"outboundBatch\", centrifugeId, poolId));\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGateway\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256 total) {\n        bytes memory proof = keccak256(payload).serializeMessageProof();\n\n        uint256 gasLimit = 0;\n        for (uint256 pos; pos < payload.length;) {\n            bytes calldata inner = payload[pos:payload.length];\n            gasLimit += gasService.gasLimit(centrifugeId, inner);\n            pos += processor.messageLength(inner);\n        }\n\n        uint256 adaptersCount = adapters[centrifugeId].length;\n        for (uint256 i; i < adaptersCount; i++) {\n            bytes memory message = i == PRIMARY_ADAPTER_ID - 1 ? payload : proof;\n            total += IAdapter(adapters[centrifugeId][i]).estimate(centrifugeId, message, gasLimit);\n        }\n    }\n\n    /// @inheritdoc IGateway\n    function quorum(uint16 centrifugeId) external view returns (uint8) {\n        Adapter memory adapter = _activeAdapters[centrifugeId][adapters[centrifugeId][0]];\n        return adapter.quorum;\n    }\n\n    /// @inheritdoc IGateway\n    function activeSessionId(uint16 centrifugeId) external view returns (uint64) {\n        Adapter memory adapter = _activeAdapters[centrifugeId][adapters[centrifugeId][0]];\n        return adapter.activeSessionId;\n    }\n\n    /// @inheritdoc IGateway\n    function votes(uint16 centrifugeId, bytes32 batchHash) external view returns (uint16[MAX_ADAPTER_COUNT] memory) {\n        return inboundBatch[centrifugeId][batchHash].votes;\n    }\n}\n\n"
    },
    "src/common/Guardian.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {IGuardian, ISafe} from \"src/common/interfaces/IGuardian.sol\";\nimport {IRootMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\nimport {IHubGuardianActions} from \"src/common/interfaces/IGuardianActions.sol\";\n\ncontract Guardian is IGuardian {\n    using CastLib for address;\n\n    IRoot public immutable root;\n\n    IHubGuardianActions public hub;\n    ISafe public safe;\n    IRootMessageSender public sender;\n\n    constructor(ISafe safe_, IRoot root_, IRootMessageSender messageDispatcher_) {\n        root = root_;\n        safe = safe_;\n        sender = messageDispatcher_;\n    }\n\n    modifier onlySafe() {\n        require(msg.sender == address(safe), NotTheAuthorizedSafe());\n        _;\n    }\n\n    modifier onlySafeOrOwner() {\n        require(msg.sender == address(safe) || _isSafeOwner(msg.sender), NotTheAuthorizedSafeOrItsOwner());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGuardian\n    function file(bytes32 what, address data) external onlySafe {\n        if (what == \"safe\") safe = ISafe(data);\n        else if (what == \"sender\") sender = IRootMessageSender(data);\n        else if (what == \"hub\") hub = IHubGuardianActions(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Admin actions\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IGuardian\n    function createPool(PoolId poolId, address admin, AssetId currency) external onlySafe {\n        return hub.createPool(poolId, admin, currency);\n    }\n\n    /// @inheritdoc IGuardian\n    function pause() external onlySafeOrOwner {\n        root.pause();\n    }\n\n    /// @inheritdoc IGuardian\n    function unpause() external onlySafe {\n        root.unpause();\n    }\n\n    /// @inheritdoc IGuardian\n    function scheduleRely(address target) external onlySafe {\n        root.scheduleRely(target);\n    }\n\n    /// @inheritdoc IGuardian\n    function cancelRely(address target) external onlySafe {\n        root.cancelRely(target);\n    }\n\n    /// @inheritdoc IGuardian\n    function scheduleUpgrade(uint16 centrifugeId, address target) external onlySafe {\n        sender.sendScheduleUpgrade(centrifugeId, target.toBytes32());\n    }\n\n    /// @inheritdoc IGuardian\n    function cancelUpgrade(uint16 centrifugeId, address target) external onlySafe {\n        sender.sendCancelUpgrade(centrifugeId, target.toBytes32());\n    }\n\n    /// @inheritdoc IGuardian\n    function recoverTokens(\n        uint16 centrifugeId,\n        address target,\n        address token,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) external onlySafe {\n        sender.sendRecoverTokens(centrifugeId, target.toBytes32(), token.toBytes32(), tokenId, to.toBytes32(), amount);\n    }\n\n    /// @inheritdoc IGuardian\n    function initiateRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, IAdapter adapter, bytes32 hash)\n        external\n        onlySafe\n    {\n        sender.sendInitiateRecovery(centrifugeId, adapterCentrifugeId, address(adapter).toBytes32(), hash);\n    }\n\n    /// @inheritdoc IGuardian\n    function disputeRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, IAdapter adapter, bytes32 hash)\n        external\n        onlySafe\n    {\n        sender.sendDisputeRecovery(centrifugeId, adapterCentrifugeId, address(adapter).toBytes32(), hash);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------------------------------\n\n    function _isSafeOwner(address addr) internal view returns (bool) {\n        try safe.isOwner(addr) returns (bool isOwner) {\n            return isOwner;\n        } catch {\n            return false;\n        }\n    }\n}\n"
    },
    "src/common/MessageDispatcher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {\n    IRequestManagerGatewayHandler,\n    IPoolManagerGatewayHandler,\n    IBalanceSheetGatewayHandler,\n    IHubGatewayHandler\n} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {IVaultMessageSender, IPoolMessageSender, IRootMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {IMessageDispatcher} from \"src/common/interfaces/IMessageDispatcher.sol\";\nimport {ITokenRecoverer} from \"src/common/interfaces/ITokenRecoverer.sol\";\n\ncontract MessageDispatcher is Auth, IMessageDispatcher {\n    using CastLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using MathLib for uint256;\n\n    IRoot public immutable root;\n    IGateway public immutable gateway;\n    ITokenRecoverer public immutable tokenRecoverer;\n\n    uint16 public immutable localCentrifugeId;\n\n    IHubGatewayHandler public hub;\n    IPoolManagerGatewayHandler public poolManager;\n    IRequestManagerGatewayHandler public investmentManager;\n    IBalanceSheetGatewayHandler public balanceSheet;\n\n    constructor(\n        uint16 localCentrifugeId_,\n        IRoot root_,\n        IGateway gateway_,\n        ITokenRecoverer tokenRecoverer_,\n        address deployer\n    ) Auth(deployer) {\n        localCentrifugeId = localCentrifugeId_;\n        root = root_;\n        gateway = gateway_;\n        tokenRecoverer = tokenRecoverer_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageDispatcher\n    function file(bytes32 what, address data) external auth {\n        if (what == \"hub\") hub = IHubGatewayHandler(data);\n        else if (what == \"poolManager\") poolManager = IPoolManagerGatewayHandler(data);\n        else if (what == \"investmentManager\") investmentManager = IRequestManagerGatewayHandler(data);\n        else if (what == \"balanceSheet\") balanceSheet = IBalanceSheetGatewayHandler(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageDispatcher\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256 amount) {\n        if (centrifugeId == localCentrifugeId) return 0;\n        return gateway.estimate(centrifugeId, payload);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPoolMessageSender\n    function sendNotifyPool(uint16 centrifugeId, PoolId poolId) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.addPool(poolId);\n        } else {\n            gateway.send(centrifugeId, MessageLib.NotifyPool({poolId: poolId.raw()}).serialize());\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendNotifyShareClass(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 salt,\n        bytes32 hook\n    ) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.addShareClass(poolId, scId, name, symbol, decimals, salt, hook.toAddress());\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.NotifyShareClass({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    name: name,\n                    symbol: symbol.toBytes32(),\n                    decimals: decimals,\n                    salt: salt,\n                    hook: hook\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendNotifyShareMetadata(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        string memory name,\n        string memory symbol\n    ) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.updateShareMetadata(poolId, scId, name, symbol);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.NotifyShareMetadata({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    name: name,\n                    symbol: symbol.toBytes32()\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendUpdateShareHook(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes32 hook) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.updateShareHook(poolId, scId, hook.toAddress());\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.UpdateShareHook({poolId: poolId.raw(), scId: scId.raw(), hook: hook}).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendNotifyPricePoolPerShare(uint16 chainId, PoolId poolId, ShareClassId scId, D18 sharePrice)\n        external\n        auth\n    {\n        uint64 timestamp = block.timestamp.toUint64();\n        if (chainId == localCentrifugeId) {\n            poolManager.updatePricePoolPerShare(poolId, scId, sharePrice.raw(), timestamp);\n        } else {\n            gateway.send(\n                chainId,\n                MessageLib.NotifyPricePoolPerShare({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    price: sharePrice.raw(),\n                    timestamp: timestamp\n                }).serialize()\n            );\n        }\n    }\n\n    function sendNotifyPricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 price) external auth {\n        uint64 timestamp = block.timestamp.toUint64();\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            poolManager.updatePricePoolPerAsset(poolId, scId, assetId, price.raw(), timestamp);\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.NotifyPricePoolPerAsset({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    assetId: assetId.raw(),\n                    price: price.raw(),\n                    timestamp: timestamp\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendFulfilledDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 assetAmount,\n        uint128 shareAmount\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.fulfillDepositRequest(\n                poolId, scId, investor.toAddress(), assetId, assetAmount, shareAmount\n            );\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.FulfilledDepositRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw(),\n                    assetAmount: assetAmount,\n                    shareAmount: shareAmount\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendFulfilledRedeemRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 assetAmount,\n        uint128 shareAmount\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.fulfillRedeemRequest(\n                poolId, scId, investor.toAddress(), assetId, assetAmount, shareAmount\n            );\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.FulfilledRedeemRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw(),\n                    assetAmount: assetAmount,\n                    shareAmount: shareAmount\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendFulfilledCancelDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 cancelledAmount\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.fulfillCancelDepositRequest(\n                poolId, scId, investor.toAddress(), assetId, cancelledAmount, cancelledAmount\n            );\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.FulfilledCancelDepositRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw(),\n                    cancelledAmount: cancelledAmount\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendFulfilledCancelRedeemRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 cancelledShares\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.fulfillCancelRedeemRequest(poolId, scId, investor.toAddress(), assetId, cancelledShares);\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.FulfilledCancelRedeemRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw(),\n                    cancelledShares: cancelledShares\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendUpdateRestriction(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes calldata payload)\n        external\n        auth\n    {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.updateRestriction(poolId, scId, payload);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.UpdateRestriction({poolId: poolId.raw(), scId: scId.raw(), payload: payload}).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendUpdateContract(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        bytes32 target,\n        bytes calldata payload\n    ) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.updateContract(poolId, scId, target.toAddress(), payload);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.UpdateContract({poolId: poolId.raw(), scId: scId.raw(), target: target, payload: payload})\n                    .serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendApprovedDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        D18 pricePoolPerAsset\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.approvedDeposits(poolId, scId, assetId, assetAmount, pricePoolPerAsset);\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.ApprovedDeposits({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    assetId: assetId.raw(),\n                    assetAmount: assetAmount,\n                    pricePoolPerAsset: pricePoolPerAsset.raw()\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendIssuedShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.issuedShares(poolId, scId, shareAmount, pricePoolPerShare);\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.IssuedShares({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    shareAmount: shareAmount,\n                    pricePoolPerShare: pricePoolPerShare.raw()\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendRevokedShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            investmentManager.revokedShares(poolId, scId, assetId, assetAmount, shareAmount, pricePoolPerShare);\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.RevokedShares({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    assetId: assetId.raw(),\n                    assetAmount: assetAmount,\n                    shareAmount: shareAmount,\n                    pricePoolPerShare: pricePoolPerShare.raw()\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendTriggerIssueShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, address who, uint128 shares)\n        external\n        auth\n    {\n        if (centrifugeId == localCentrifugeId) {\n            balanceSheet.triggerIssueShares(poolId, scId, who, shares);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.TriggerIssueShares({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    who: who.toBytes32(),\n                    shares: shares\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendTriggerSubmitQueuedShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            balanceSheet.submitQueuedShares(poolId, scId);\n        } else {\n            gateway.send(\n                centrifugeId, MessageLib.TriggerSubmitQueuedShares({poolId: poolId.raw(), scId: scId.raw()}).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendTriggerSubmitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) external auth {\n        if (assetId.centrifugeId() == localCentrifugeId) {\n            balanceSheet.submitQueuedAssets(poolId, scId, assetId);\n        } else {\n            gateway.send(\n                assetId.centrifugeId(),\n                MessageLib.TriggerSubmitQueuedAssets({poolId: poolId.raw(), scId: scId.raw(), assetId: assetId.raw()})\n                    .serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IPoolMessageSender\n    function sendSetQueue(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bool enabled) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            balanceSheet.setQueue(poolId, scId, enabled);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.SetQueue({poolId: poolId.raw(), scId: scId.raw(), enabled: enabled}).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IRootMessageSender\n    function sendScheduleUpgrade(uint16 centrifugeId, bytes32 target) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            root.scheduleRely(target.toAddress());\n        } else {\n            gateway.send(centrifugeId, MessageLib.ScheduleUpgrade({target: target}).serialize());\n        }\n    }\n\n    /// @inheritdoc IRootMessageSender\n    function sendCancelUpgrade(uint16 centrifugeId, bytes32 target) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            root.cancelRely(target.toAddress());\n        } else {\n            gateway.send(centrifugeId, MessageLib.CancelUpgrade({target: target}).serialize());\n        }\n    }\n\n    /// @inheritdoc IRootMessageSender\n    function sendRecoverTokens(\n        uint16 centrifugeId,\n        bytes32 target,\n        bytes32 token,\n        uint256 tokenId,\n        bytes32 to,\n        uint256 amount\n    ) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            tokenRecoverer.recoverTokens(\n                IRecoverable(target.toAddress()), token.toAddress(), tokenId, to.toAddress(), amount\n            );\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.RecoverTokens({target: target, token: token, tokenId: tokenId, to: to, amount: amount})\n                    .serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IRootMessageSender\n    function sendInitiateRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, bytes32 adapter, bytes32 hash)\n        external\n        auth\n    {\n        if (centrifugeId == localCentrifugeId) {\n            gateway.initiateRecovery(adapterCentrifugeId, IAdapter(adapter.toAddress()), hash);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.InitiateRecovery({hash: hash, adapter: adapter, centrifugeId: adapterCentrifugeId}).serialize(\n                )\n            );\n        }\n    }\n\n    /// @inheritdoc IRootMessageSender\n    function sendDisputeRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, bytes32 adapter, bytes32 hash)\n        external\n        auth\n    {\n        if (centrifugeId == localCentrifugeId) {\n            gateway.disputeRecovery(adapterCentrifugeId, IAdapter(adapter.toAddress()), hash);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.DisputeRecovery({hash: hash, adapter: adapter, centrifugeId: adapterCentrifugeId}).serialize(\n                )\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendTransferShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes32 receiver, uint128 amount)\n        external\n        auth\n    {\n        if (centrifugeId == localCentrifugeId) {\n            poolManager.handleTransferShares(poolId, scId, receiver.toAddress(), amount);\n        } else {\n            gateway.send(\n                centrifugeId,\n                MessageLib.TransferShares({poolId: poolId.raw(), scId: scId.raw(), receiver: receiver, amount: amount})\n                    .serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId, uint128 amount)\n        external\n        auth\n    {\n        if (poolId.centrifugeId() == localCentrifugeId) {\n            hub.depositRequest(poolId, scId, investor, assetId, amount);\n        } else {\n            gateway.send(\n                poolId.centrifugeId(),\n                MessageLib.DepositRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw(),\n                    amount: amount\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId, uint128 amount)\n        external\n        auth\n    {\n        if (poolId.centrifugeId() == localCentrifugeId) {\n            hub.redeemRequest(poolId, scId, investor, assetId, amount);\n        } else {\n            gateway.send(\n                poolId.centrifugeId(),\n                MessageLib.RedeemRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw(),\n                    amount: amount\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendCancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId)\n        external\n        auth\n    {\n        if (poolId.centrifugeId() == localCentrifugeId) {\n            hub.cancelDepositRequest(poolId, scId, investor, assetId);\n        } else {\n            gateway.send(\n                poolId.centrifugeId(),\n                MessageLib.CancelDepositRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw()\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendCancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId)\n        external\n        auth\n    {\n        if (poolId.centrifugeId() == localCentrifugeId) {\n            hub.cancelRedeemRequest(poolId, scId, investor, assetId);\n        } else {\n            gateway.send(\n                poolId.centrifugeId(),\n                MessageLib.CancelRedeemRequest({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    investor: investor,\n                    assetId: assetId.raw()\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendUpdateHoldingAmount(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address provider,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease\n    ) external auth {\n        if (poolId.centrifugeId() == localCentrifugeId) {\n            hub.updateHoldingAmount(poolId, scId, assetId, amount, pricePoolPerAsset, isIncrease);\n        } else {\n            gateway.send(\n                poolId.centrifugeId(),\n                MessageLib.UpdateHoldingAmount({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    assetId: assetId.raw(),\n                    who: provider.toBytes32(),\n                    amount: amount,\n                    pricePerUnit: pricePoolPerAsset.raw(),\n                    timestamp: uint64(block.timestamp),\n                    isIncrease: isIncrease\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendUpdateShares(PoolId poolId, ShareClassId scId, uint128 shares, bool isIssuance) external auth {\n        if (poolId.centrifugeId() == localCentrifugeId) {\n            if (isIssuance) {\n                hub.increaseShareIssuance(poolId, scId, shares);\n            } else {\n                hub.decreaseShareIssuance(poolId, scId, shares);\n            }\n        } else {\n            gateway.send(\n                poolId.centrifugeId(),\n                MessageLib.UpdateShares({\n                    poolId: poolId.raw(),\n                    scId: scId.raw(),\n                    shares: shares,\n                    timestamp: uint64(block.timestamp),\n                    isIssuance: isIssuance\n                }).serialize()\n            );\n        }\n    }\n\n    /// @inheritdoc IVaultMessageSender\n    function sendRegisterAsset(uint16 centrifugeId, AssetId assetId, uint8 decimals) external auth {\n        if (centrifugeId == localCentrifugeId) {\n            hub.registerAsset(assetId, decimals);\n        } else {\n            gateway.send(\n                centrifugeId, MessageLib.RegisterAsset({assetId: assetId.raw(), decimals: decimals}).serialize()\n            );\n        }\n    }\n}\n"
    },
    "src/common/MessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {MessageType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {IMessageProcessor} from \"src/common/interfaces/IMessageProcessor.sol\";\nimport {IMessageProperties} from \"src/common/interfaces/IMessageProperties.sol\";\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {\n    IGatewayHandler,\n    IPoolManagerGatewayHandler,\n    IBalanceSheetGatewayHandler,\n    IHubGatewayHandler,\n    IRequestManagerGatewayHandler\n} from \"src/common/interfaces/IGatewayHandlers.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ITokenRecoverer} from \"src/common/interfaces/ITokenRecoverer.sol\";\n\ncontract MessageProcessor is Auth, IMessageProcessor {\n    using CastLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n\n    IRoot public immutable root;\n    ITokenRecoverer public immutable tokenRecoverer;\n\n    IGatewayHandler public gateway;\n    IHubGatewayHandler public hub;\n    IPoolManagerGatewayHandler public poolManager;\n    IRequestManagerGatewayHandler public investmentManager;\n    IBalanceSheetGatewayHandler public balanceSheet;\n\n    constructor(IRoot root_, ITokenRecoverer tokenRecoverer_, address deployer) Auth(deployer) {\n        root = root_;\n        tokenRecoverer = tokenRecoverer_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageProcessor\n    function file(bytes32 what, address data) external auth {\n        if (what == \"gateway\") gateway = IGatewayHandler(data);\n        else if (what == \"hub\") hub = IHubGatewayHandler(data);\n        else if (what == \"poolManager\") poolManager = IPoolManagerGatewayHandler(data);\n        else if (what == \"investmentManager\") investmentManager = IRequestManagerGatewayHandler(data);\n        else if (what == \"balanceSheet\") balanceSheet = IBalanceSheetGatewayHandler(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMessageHandler\n    function handle(uint16, bytes calldata message) external auth {\n        MessageType kind = message.messageType();\n\n        if (kind == MessageType.InitiateRecovery) {\n            MessageLib.InitiateRecovery memory m = message.deserializeInitiateRecovery();\n            gateway.initiateRecovery(m.centrifugeId, IAdapter(m.adapter.toAddress()), m.hash);\n        } else if (kind == MessageType.DisputeRecovery) {\n            MessageLib.DisputeRecovery memory m = message.deserializeDisputeRecovery();\n            gateway.disputeRecovery(m.centrifugeId, IAdapter(m.adapter.toAddress()), m.hash);\n        } else if (kind == MessageType.ScheduleUpgrade) {\n            MessageLib.ScheduleUpgrade memory m = message.deserializeScheduleUpgrade();\n            root.scheduleRely(m.target.toAddress());\n        } else if (kind == MessageType.CancelUpgrade) {\n            MessageLib.CancelUpgrade memory m = message.deserializeCancelUpgrade();\n            root.cancelRely(m.target.toAddress());\n        } else if (kind == MessageType.RecoverTokens) {\n            MessageLib.RecoverTokens memory m = message.deserializeRecoverTokens();\n            tokenRecoverer.recoverTokens(\n                IRecoverable(m.target.toAddress()), m.token.toAddress(), m.tokenId, m.to.toAddress(), m.amount\n            );\n        } else if (kind == MessageType.RegisterAsset) {\n            MessageLib.RegisterAsset memory m = message.deserializeRegisterAsset();\n            hub.registerAsset(AssetId.wrap(m.assetId), m.decimals);\n        } else if (kind == MessageType.NotifyPool) {\n            poolManager.addPool(PoolId.wrap(MessageLib.deserializeNotifyPool(message).poolId));\n        } else if (kind == MessageType.NotifyShareClass) {\n            MessageLib.NotifyShareClass memory m = MessageLib.deserializeNotifyShareClass(message);\n            poolManager.addShareClass(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                m.name,\n                m.symbol.toString(),\n                m.decimals,\n                m.salt,\n                m.hook.toAddress()\n            );\n        } else if (kind == MessageType.NotifyPricePoolPerShare) {\n            MessageLib.NotifyPricePoolPerShare memory m = MessageLib.deserializeNotifyPricePoolPerShare(message);\n            poolManager.updatePricePoolPerShare(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.price, m.timestamp);\n        } else if (kind == MessageType.NotifyPricePoolPerAsset) {\n            MessageLib.NotifyPricePoolPerAsset memory m = MessageLib.deserializeNotifyPricePoolPerAsset(message);\n            poolManager.updatePricePoolPerAsset(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), AssetId.wrap(m.assetId), m.price, m.timestamp\n            );\n        } else if (kind == MessageType.NotifyShareMetadata) {\n            MessageLib.NotifyShareMetadata memory m = MessageLib.deserializeNotifyShareMetadata(message);\n            poolManager.updateShareMetadata(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.name, m.symbol.toString()\n            );\n        } else if (kind == MessageType.UpdateShareHook) {\n            MessageLib.UpdateShareHook memory m = MessageLib.deserializeUpdateShareHook(message);\n            poolManager.updateShareHook(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.hook.toAddress());\n        } else if (kind == MessageType.TransferShares) {\n            MessageLib.TransferShares memory m = MessageLib.deserializeTransferShares(message);\n            poolManager.handleTransferShares(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.receiver.toAddress(), m.amount\n            );\n        } else if (kind == MessageType.UpdateRestriction) {\n            MessageLib.UpdateRestriction memory m = MessageLib.deserializeUpdateRestriction(message);\n            poolManager.updateRestriction(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.payload);\n        } else if (kind == MessageType.UpdateContract) {\n            MessageLib.UpdateContract memory m = MessageLib.deserializeUpdateContract(message);\n            poolManager.updateContract(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.target.toAddress(), m.payload\n            );\n        } else if (kind == MessageType.DepositRequest) {\n            MessageLib.DepositRequest memory m = message.deserializeDepositRequest();\n            hub.depositRequest(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.investor, AssetId.wrap(m.assetId), m.amount\n            );\n        } else if (kind == MessageType.RedeemRequest) {\n            MessageLib.RedeemRequest memory m = message.deserializeRedeemRequest();\n            hub.redeemRequest(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.investor, AssetId.wrap(m.assetId), m.amount\n            );\n        } else if (kind == MessageType.CancelDepositRequest) {\n            MessageLib.CancelDepositRequest memory m = message.deserializeCancelDepositRequest();\n            hub.cancelDepositRequest(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.investor, AssetId.wrap(m.assetId)\n            );\n        } else if (kind == MessageType.CancelRedeemRequest) {\n            MessageLib.CancelRedeemRequest memory m = message.deserializeCancelRedeemRequest();\n            hub.cancelRedeemRequest(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.investor, AssetId.wrap(m.assetId)\n            );\n        } else if (kind == MessageType.FulfilledDepositRequest) {\n            MessageLib.FulfilledDepositRequest memory m = message.deserializeFulfilledDepositRequest();\n            investmentManager.fulfillDepositRequest(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                m.investor.toAddress(),\n                AssetId.wrap(m.assetId),\n                m.assetAmount,\n                m.shareAmount\n            );\n        } else if (kind == MessageType.FulfilledRedeemRequest) {\n            MessageLib.FulfilledRedeemRequest memory m = message.deserializeFulfilledRedeemRequest();\n            investmentManager.fulfillRedeemRequest(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                m.investor.toAddress(),\n                AssetId.wrap(m.assetId),\n                m.assetAmount,\n                m.shareAmount\n            );\n        } else if (kind == MessageType.FulfilledCancelDepositRequest) {\n            MessageLib.FulfilledCancelDepositRequest memory m = message.deserializeFulfilledCancelDepositRequest();\n            investmentManager.fulfillCancelDepositRequest(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                m.investor.toAddress(),\n                AssetId.wrap(m.assetId),\n                m.cancelledAmount,\n                m.cancelledAmount\n            );\n        } else if (kind == MessageType.FulfilledCancelRedeemRequest) {\n            MessageLib.FulfilledCancelRedeemRequest memory m = message.deserializeFulfilledCancelRedeemRequest();\n            investmentManager.fulfillCancelRedeemRequest(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                m.investor.toAddress(),\n                AssetId.wrap(m.assetId),\n                m.cancelledShares\n            );\n        } else if (kind == MessageType.TriggerIssueShares) {\n            MessageLib.TriggerIssueShares memory m = message.deserializeTriggerIssueShares();\n            balanceSheet.triggerIssueShares(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.who.toAddress(), m.shares\n            );\n        } else if (kind == MessageType.UpdateHoldingAmount) {\n            MessageLib.UpdateHoldingAmount memory m = message.deserializeUpdateHoldingAmount();\n            hub.updateHoldingAmount(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                AssetId.wrap(m.assetId),\n                m.amount,\n                D18.wrap(m.pricePerUnit),\n                m.isIncrease\n            );\n        } else if (kind == MessageType.UpdateShares) {\n            MessageLib.UpdateShares memory m = message.deserializeUpdateShares();\n            if (m.isIssuance) {\n                hub.increaseShareIssuance(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.shares);\n            } else {\n                hub.decreaseShareIssuance(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.shares);\n            }\n        } else if (kind == MessageType.ApprovedDeposits) {\n            MessageLib.ApprovedDeposits memory m = message.deserializeApprovedDeposits();\n            investmentManager.approvedDeposits(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                AssetId.wrap(m.assetId),\n                m.assetAmount,\n                D18.wrap(m.pricePoolPerAsset)\n            );\n        } else if (kind == MessageType.IssuedShares) {\n            MessageLib.IssuedShares memory m = message.deserializeIssuedShares();\n            investmentManager.issuedShares(\n                PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.shareAmount, D18.wrap(m.pricePoolPerShare)\n            );\n        } else if (kind == MessageType.RevokedShares) {\n            MessageLib.RevokedShares memory m = message.deserializeRevokedShares();\n            investmentManager.revokedShares(\n                PoolId.wrap(m.poolId),\n                ShareClassId.wrap(m.scId),\n                AssetId.wrap(m.assetId),\n                m.assetAmount,\n                m.shareAmount,\n                D18.wrap(m.pricePoolPerShare)\n            );\n        } else if (kind == MessageType.TriggerSubmitQueuedShares) {\n            MessageLib.TriggerSubmitQueuedShares memory m = message.deserializeTriggerSubmitQueuedShares();\n            balanceSheet.submitQueuedShares(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId));\n        } else if (kind == MessageType.TriggerSubmitQueuedAssets) {\n            MessageLib.TriggerSubmitQueuedAssets memory m = message.deserializeTriggerSubmitQueuedAssets();\n            balanceSheet.submitQueuedAssets(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), AssetId.wrap(m.assetId));\n        } else if (kind == MessageType.SetQueue) {\n            MessageLib.SetQueue memory m = message.deserializeSetQueue();\n            balanceSheet.setQueue(PoolId.wrap(m.poolId), ShareClassId.wrap(m.scId), m.enabled);\n        } else {\n            revert InvalidMessage(uint8(kind));\n        }\n    }\n\n    /// @inheritdoc IMessageProperties\n    function isMessageRecovery(bytes calldata message) external pure returns (bool) {\n        uint8 code = message.messageCode();\n        return code == uint8(MessageType.InitiateRecovery) || code == uint8(MessageType.DisputeRecovery);\n    }\n\n    /// @inheritdoc IMessageProperties\n    function messageLength(bytes calldata message) external pure returns (uint16) {\n        return message.messageLength();\n    }\n\n    /// @inheritdoc IMessageProperties\n    function messagePoolId(bytes calldata message) external pure returns (PoolId) {\n        return message.messagePoolId();\n    }\n}\n"
    },
    "src/common/Root.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\n\n/// @title  Root\n/// @notice Core contract that is a ward on all other deployed contracts.\n/// @dev    Pausing can happen instantaneously, but relying on other contracts\n///         is restricted to the timelock set by the delay.\ncontract Root is Auth, IRoot {\n    /// @dev To prevent filing a delay that would block any updates indefinitely\n    uint256 internal constant MAX_DELAY = 4 weeks;\n\n    bool public paused;\n    uint256 public delay;\n    mapping(address => uint256) public endorsements;\n    mapping(address relyTarget => uint256 timestamp) public schedule;\n\n    constructor(uint256 _delay, address deployer) Auth(deployer) {\n        require(_delay <= MAX_DELAY, DelayTooLong());\n        delay = _delay;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IRoot\n    function file(bytes32 what, uint256 data) external auth {\n        if (what == \"delay\") {\n            require(data <= MAX_DELAY, DelayTooLong());\n            delay = data;\n        } else {\n            revert FileUnrecognizedParam();\n        }\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IRoot\n    function endorse(address user) external auth {\n        endorsements[user] = 1;\n        emit Endorse(user);\n    }\n\n    /// @inheritdoc IRoot\n    function veto(address user) external auth {\n        endorsements[user] = 0;\n        emit Veto(user);\n    }\n\n    /// @inheritdoc IRoot\n    function endorsed(address user) external view returns (bool) {\n        return endorsements[user] == 1;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Pause management\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IRoot\n    function pause() external auth {\n        paused = true;\n        emit Pause();\n    }\n\n    /// @inheritdoc IRoot\n    function unpause() external auth {\n        paused = false;\n        emit Unpause();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Timelocked ward management\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IRoot\n    function scheduleRely(address target) external auth {\n        schedule[target] = block.timestamp + delay;\n        emit ScheduleRely(target, schedule[target]);\n    }\n\n    /// @inheritdoc IRoot\n    function cancelRely(address target) external auth {\n        require(schedule[target] != 0, TargetNotScheduled());\n        schedule[target] = 0;\n        emit CancelRely(target);\n    }\n\n    /// @inheritdoc IRoot\n    function executeScheduledRely(address target) external {\n        require(schedule[target] != 0, TargetNotScheduled());\n        require(schedule[target] <= block.timestamp, TargetNotReady());\n\n        wards[target] = 1;\n        emit Rely(target);\n\n        schedule[target] = 0;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // External contract ward management\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IRoot\n    function relyContract(address target, address user) external auth {\n        IAuth(target).rely(user);\n        emit RelyContract(target, user);\n    }\n\n    /// @inheritdoc IRoot\n    function denyContract(address target, address user) external auth {\n        IAuth(target).deny(user);\n        emit DenyContract(target, user);\n    }\n}\n"
    },
    "src/common/TokenRecoverer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {ITokenRecoverer} from \"src/common/interfaces/ITokenRecoverer.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\ncontract TokenRecoverer is Auth, ITokenRecoverer {\n    IRoot public immutable root;\n\n    constructor(IRoot root_, address deployer) Auth(deployer) {\n        root = root_;\n    }\n\n    /// @notice inheritdoc ITokenRecoverer\n    function recoverTokens(IRecoverable target, address token, uint256 tokenId, address to, uint256 amount)\n        external\n        auth\n    {\n        root.relyContract(address(target), address(this));\n\n        if (tokenId == 0) {\n            target.recoverTokens(token, to, amount);\n        } else {\n            target.recoverTokens(token, tokenId, to, amount);\n        }\n\n        root.denyContract(address(target), address(this));\n\n        emit RecoverTokens(target, token, tokenId, to, amount);\n    }\n}\n"
    },
    "src/common/adapters/AxelarAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {\n    IAxelarAdapter,\n    IAdapter,\n    IAxelarGateway,\n    IAxelarGasService,\n    AxelarSource,\n    AxelarDestination,\n    IAxelarExecutable\n} from \"src/common/interfaces/IAxelarAdapter.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\n\n/// @title  Axelar Adapter\n/// @notice Routing contract that integrates with an Axelar Gateway\ncontract AxelarAdapter is Auth, IAxelarAdapter {\n    using CastLib for *;\n\n    IMessageHandler public immutable gateway;\n    IAxelarGateway public immutable axelarGateway;\n    IAxelarGasService public immutable axelarGasService;\n\n    mapping(string axelarId => AxelarSource) public sources;\n    mapping(uint16 centrifugeId => AxelarDestination) public destinations;\n\n    constructor(IMessageHandler gateway_, address axelarGateway_, address axelarGasService_, address deployer)\n        Auth(deployer)\n    {\n        gateway = gateway_;\n        axelarGateway = IAxelarGateway(axelarGateway_);\n        axelarGasService = IAxelarGasService(axelarGasService_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAxelarAdapter\n    function file(bytes32 what, string calldata axelarId, uint16 centrifugeId, string calldata source) external auth {\n        if (what == \"sources\") sources[axelarId] = AxelarSource(centrifugeId, keccak256(bytes(source)));\n        else revert FileUnrecognizedParam();\n        emit File(what, axelarId, centrifugeId, source);\n    }\n\n    /// @inheritdoc IAxelarAdapter\n    function file(bytes32 what, uint16 centrifugeId, string calldata axelarId, string calldata destination)\n        external\n        auth\n    {\n        if (what == \"destinations\") destinations[centrifugeId] = AxelarDestination(axelarId, destination);\n        else revert FileUnrecognizedParam();\n        emit File(what, centrifugeId, axelarId, destination);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAxelarExecutable\n    function execute(\n        bytes32 commandId,\n        string calldata sourceAxelarId,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) public {\n        AxelarSource memory source = sources[sourceAxelarId];\n        require(\n            source.addressHash != bytes32(\"\") && source.addressHash == keccak256(bytes(sourceAddress)), InvalidAddress()\n        );\n\n        require(\n            axelarGateway.validateContractCall(commandId, sourceAxelarId, sourceAddress, keccak256(payload)),\n            NotApprovedByGateway()\n        );\n\n        gateway.handle(source.centrifugeId, payload);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAdapter\n    function send(uint16 centrifugeId, bytes calldata payload, uint256, /* gasLimit */ address refund)\n        external\n        payable\n        returns (bytes32 adapterData)\n    {\n        require(msg.sender == address(gateway), NotGateway());\n        AxelarDestination memory destination = destinations[centrifugeId];\n        require(bytes(destination.axelarId).length != 0, UnknownChainId());\n\n        axelarGasService.payNativeGasForContractCall{value: msg.value}(\n            address(this), destination.axelarId, destination.addr, payload, refund\n        );\n\n        axelarGateway.callContract(destination.axelarId, destination.addr, payload);\n\n        adapterData = bytes32(\"\");\n    }\n\n    /// @inheritdoc IAdapter\n    function estimate(uint16 centrifugeId, bytes calldata payload, uint256 gasLimit) public view returns (uint256) {\n        AxelarDestination memory destination = destinations[centrifugeId];\n        return axelarGasService.estimateGasFee(destination.axelarId, destination.addr, payload, gasLimit, bytes(\"\"));\n    }\n}\n"
    },
    "src/common/adapters/WormholeAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {\n    IWormholeAdapter,\n    IAdapter,\n    IWormholeRelayer,\n    IWormholeDeliveryProvider,\n    IWormholeReceiver,\n    WormholeSource,\n    WormholeDestination\n} from \"src/common/interfaces/IWormholeAdapter.sol\";\n\n/// @title  Wormhole Adapter\n/// @notice Routing contract that integrates with the Wormhole Relayer service\ncontract WormholeAdapter is Auth, IWormholeAdapter {\n    using CastLib for bytes32;\n\n    uint16 public immutable localWormholeId;\n    IMessageHandler public immutable gateway;\n    IWormholeRelayer public immutable relayer;\n\n    mapping(uint16 wormholeId => WormholeSource) public sources;\n    mapping(uint16 centrifugeId => WormholeDestination) public destinations;\n\n    constructor(IMessageHandler gateway_, address relayer_, address deployer) Auth(deployer) {\n        gateway = gateway_;\n        relayer = IWormholeRelayer(relayer_);\n\n        IWormholeDeliveryProvider deliveryProvider = IWormholeDeliveryProvider(relayer.getDefaultDeliveryProvider());\n        localWormholeId = deliveryProvider.chainId();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IWormholeAdapter\n    function file(bytes32 what, uint16 centrifugeId, uint16 wormholeId, address addr) external auth {\n        if (what == \"sources\") sources[wormholeId] = WormholeSource(centrifugeId, addr);\n        else if (what == \"destinations\") destinations[centrifugeId] = WormholeDestination(wormholeId, addr);\n        else revert FileUnrecognizedParam();\n        emit File(what, centrifugeId, wormholeId, addr);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IWormholeReceiver\n    function receiveWormholeMessages(\n        bytes memory payload,\n        bytes[] memory, /* additionalVaas */\n        bytes32 sourceAddress,\n        uint16 sourceWormholeId,\n        bytes32 /* deliveryHash */\n    ) external payable {\n        WormholeSource memory source = sources[sourceWormholeId];\n        require(source.addr != address(0) && source.addr == sourceAddress.toAddressLeftPadded(), InvalidSource());\n        require(msg.sender == address(relayer), NotWormholeRelayer());\n\n        gateway.handle(source.centrifugeId, payload);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAdapter\n    function send(uint16 centrifugeId, bytes calldata payload, uint256 gasLimit, address refund)\n        external\n        payable\n        returns (bytes32 adapterData)\n    {\n        require(msg.sender == address(gateway), NotGateway());\n        WormholeDestination memory destination = destinations[centrifugeId];\n        require(destination.wormholeId != 0, UnknownChainId());\n\n        uint64 sequence = relayer.sendPayloadToEvm{value: msg.value}(\n            destination.wormholeId, destination.addr, payload, 0, gasLimit, localWormholeId, refund\n        );\n\n        adapterData = bytes32(bytes8(sequence));\n    }\n\n    /// @inheritdoc IAdapter\n    function estimate(uint16 centrifugeId, bytes calldata, uint256 gasLimit)\n        public\n        view\n        returns (uint256 nativePriceQuote)\n    {\n        (nativePriceQuote,) = relayer.quoteEVMDeliveryPrice(destinations[centrifugeId].wormholeId, 0, gasLimit);\n    }\n}\n"
    },
    "src/common/interfaces/IAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\ninterface IAdapter is IAuth {\n    error NotGateway();\n    error UnknownChainId();\n\n    /// @notice Send a payload to the destination chain\n    function send(uint16 centrifugeId, bytes calldata payload, uint256 gasLimit, address refund)\n        external\n        payable\n        returns (bytes32 adapterData);\n\n    /// @notice Estimate the total cost in native gas tokens\n    function estimate(uint16 centrifugeId, bytes calldata payload, uint256 gasLimit) external view returns (uint256);\n}\n"
    },
    "src/common/interfaces/IAxelarAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\n// From https://github.com/axelarnetwork/axelar-cgp-solidity/blob/main/contracts/interfaces/IAxelarGateway.sol\ninterface IAxelarGateway {\n    function callContract(string calldata destinationChain, string calldata contractAddress, bytes calldata payload)\n        external;\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n}\n\ninterface IAxelarGasService {\n    // From\n    // https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/00682b6c3db0cc922ec0c4ea3791852c93d7ae31/contracts/gas-estimation/InterchainGasEstimation.sol#L48\n    function estimateGasFee(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        uint256 executionGasLimit,\n        bytes calldata params\n    ) external view returns (uint256 gasEstimate);\n\n    // From https://github.com/axelarnetwork/axelar-cgp-solidity/blob/main/contracts/interfaces/IAxelarGasService.sol\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n}\n\n// From\n// https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/00682b6c3db0cc922ec0c4ea3791852c93d7ae31/contracts/interfaces/IAxelarExecutable.sol#L14\ninterface IAxelarExecutable {\n    /**\n     * @dev Thrown when a function is called with an invalid address.\n     */\n    error InvalidAddress();\n\n    /**\n     * @dev Thrown when the call is not approved by the Axelar Gateway.\n     */\n    error NotApprovedByGateway();\n\n    /**\n     * @notice Executes the specified command sent from another chain.\n     * @dev This function is called by the Axelar Gateway to carry out cross-chain commands.\n     * Reverts if the call is not approved by the gateway or other checks fail.\n     * @param commandId The identifier of the command to execute.\n     * @param sourceChain The name of the source chain from where the command originated.\n     * @param sourceAddress The address on the source chain that sent the command.\n     * @param payload The payload of the command to be executed. This typically includes the function selector and\n     * encoded arguments.\n     */\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n}\n\nstruct AxelarSource {\n    uint16 centrifugeId;\n    bytes32 addressHash;\n}\n\nstruct AxelarDestination {\n    string axelarId;\n    string addr;\n}\n\ninterface IAxelarAdapter is IAdapter, IAxelarExecutable {\n    event File(bytes32 indexed what, string axelarId, uint16 centrifugeId, string source);\n    event File(bytes32 indexed what, uint16 centrifugeId, string axelarId, string destination);\n\n    error FileUnrecognizedParam();\n\n    function file(bytes32 what, string calldata axelarId, uint16 centrifugeId, string calldata source) external;\n    function file(bytes32 what, uint16 centrifugeId, string calldata axelarId, string calldata destination) external;\n}\n"
    },
    "src/common/interfaces/IGasService.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\ninterface IGasService {\n    /// @notice Gas limit for the execution cost of an individual message in a remote chain.\n    /// @dev    NOTE: In the future we could want to dispatch:\n    ///         - by destination chain (for non-EVM chains)\n    ///         - by message type\n    ///         - by inspecting the payload checking different subsmessages that alter the endpoint processing\n    /// @param centrifugeId Where to the cost is defined\n    /// @param message Individual message\n    /// @return Estimated cost in WEI units\n    function gasLimit(uint16 centrifugeId, bytes calldata message) external view returns (uint128);\n\n    /// @notice Gas limit for the execution cost of a batch in a remote chain.\n    /// @param centrifugeId Where to the cost is defined\n    /// @return Max cost in WEI units\n    function maxBatchSize(uint16 centrifugeId) external view returns (uint128);\n}\n"
    },
    "src/common/interfaces/IGateway.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {IGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {IMessageSender} from \"src/common/interfaces/IMessageSender.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nuint8 constant MAX_ADAPTER_COUNT = 8;\n\n/// @notice Interface for dispatch-only gateway\ninterface IGateway is IMessageHandler, IMessageSender, IGatewayHandler {\n    /// @dev Each adapter struct is packed with the quorum to reduce SLOADs on handle\n    struct Adapter {\n        /// @notice Starts at 1 and maps to id - 1 as the index on the adapters array\n        uint8 id;\n        /// @notice Number of votes required for a message to be executed\n        uint8 quorum;\n        /// @notice Each time the quorum is decreased, a new session starts which invalidates old votes\n        uint64 activeSessionId;\n    }\n\n    struct InboundBatch {\n        /// @dev Counts are stored as integers (instead of boolean values) to accommodate duplicate\n        ///      messages (e.g. two investments from the same user with the same amount) being\n        ///      processed in parallel. The entire struct is packed in a single bytes32 slot.\n        ///      Max uint16 = 65,535 so at most 65,535 duplicate messages can be processed in parallel.\n        uint16[MAX_ADAPTER_COUNT] votes;\n        /// @notice Each time adapters are updated, a new session starts which invalidates old votes\n        uint64 sessionId;\n        bytes pendingBatch;\n    }\n\n    struct Funds {\n        /// @notice Funds associated to pay for sending messages\n        /// @dev    Overflows with type(uint64).max / 10**18 = 7.923 Ã— 10^10 ETH\n        uint96 value;\n        /// @notice Address where to refund the remaining gas\n        IRecoverable refund;\n    }\n\n    // Used to bypass stack too deep issue\n    struct SendData {\n        bytes32 batchHash;\n        bytes32 payloadId;\n        uint256[] gasCost;\n    }\n\n    struct Underpaid {\n        uint128 counter;\n        uint128 gasLimit;\n    }\n\n    // --- Events ---\n    event PrepareMessage(uint16 indexed centrifugeId, PoolId poolId, bytes message);\n    event UnderpaidBatch(uint16 indexed centrifugeId, bytes batch);\n    event RepayBatch(uint16 indexed centrifugeId, bytes batch);\n    event SendBatch(\n        uint16 indexed centrifugeId,\n        bytes32 indexed payloadId,\n        bytes batch,\n        IAdapter adapter,\n        bytes32 adapterData,\n        address refund\n    );\n    event SendProof(\n        uint16 indexed centrifugeId, bytes32 indexed payloadId, bytes32 batchHash, IAdapter adapter, bytes32 adapterData\n    );\n    event HandleBatch(uint16 indexed centrifugeId, bytes32 indexed payloadId, bytes batch, IAdapter adapter);\n    event HandleProof(uint16 indexed centrifugeId, bytes32 indexed payloadId, bytes32 batchHash, IAdapter adapter);\n    event ExecuteMessage(uint16 indexed centrifugeId, bytes message);\n    event FailMessage(uint16 indexed centrifugeId, bytes message, bytes error);\n\n    event RecoverMessage(IAdapter adapter, bytes message);\n    event RecoverProof(IAdapter adapter, bytes32 batchHash);\n    event InitiateRecovery(uint16 centrifugeId, bytes32 batchHash, IAdapter adapter);\n    event DisputeRecovery(uint16 centrifugeId, bytes32 batchHash, IAdapter adapter);\n    event ExecuteRecovery(uint16 centrifugeId, bytes message, IAdapter adapter);\n\n    event File(bytes32 indexed what, uint16 centrifugeId, IAdapter[] adapters);\n    event File(bytes32 indexed what, address addr);\n\n    event SetRefundAddress(PoolId poolId, IRecoverable refund);\n    event SubsidizePool(PoolId indexed poolId, address indexed sender, uint256 amount);\n\n    /// @notice Dispatched when the `what` parameter of `file()` is not supported by the implementation.\n    error FileUnrecognizedParam();\n\n    /// @notice Dispatched when the batch is ended without starting it.\n    error NoBatched();\n\n    /// @notice Dispatched when the gateway is paused.\n    error Paused();\n\n    /// @notice Dispatched when the gateway is configured with a number of adapter exceeding the maximum.\n    error ExceedsMax();\n\n    /// @notice Dispatched when the gateway is configured with an empty adapter set.\n    error EmptyAdapterSet();\n\n    /// @notice Dispatched when the gateway is configured with duplicate adapters.\n    error NoDuplicatesAllowed();\n\n    /// @notice Dispatched when the gateway tries to handle a message from an adaptet not contained in the adapter set.\n    error InvalidAdapter();\n\n    /// @notice Dispatched when the gateway tries to recover a recovery message, which is not allowed.\n    error RecoveryPayloadRecovered();\n\n    /// @notice Dispatched when the gateway tries to handle a proof from a non proof adapter.\n    error NonProofAdapter();\n\n    /// @notice Dispatched when the gateway tries to handle a batch from a non message adapter.\n    error NonBatchAdapter();\n\n    /// @notice Dispatched when a recovery message is executed without being initiated.\n    error RecoveryNotInitiated();\n\n    /// @notice Dispatched when a recovery message is executed without waiting the challenge period.\n    error RecoveryChallengePeriodNotEnded();\n\n    /// @notice Dispatched when a the gateway tries to send an empty message.\n    error EmptyMessage();\n\n    /// @notice Dispatched when a the gateway has not enough fuel to send a message.\n    /// Only dispatched in PayTransaction method\n    error NotEnoughTransactionGas();\n\n    /// @notice Dispatched when a message that has not failed is retried.\n    error NotFailedMessage();\n\n    /// @notice Dispatched when a batch that has not been underpaid is repaid.\n    error NotUnderpaidBatch();\n\n    /// @notice Dispatched when a batch is repaid with insufficient funds.\n    error InsufficientFundsForRepayment();\n\n    /// @notice Dispatched when a message is added to a batch that causes it to exceed the max batch size.\n    error ExceedsMaxBatchSize();\n\n    /// @notice Dispatched when a refund address is not set.\n    error RefundAddressNotSet();\n\n    // --- Administration ---\n    /// @notice Used to update an array of addresses ( state variable ) on very rare occasions.\n    /// @dev    Currently it is used to update the supported adapters.\n    /// @param  what The name of the variable to be updated.\n    /// @param  centrifugeId Chain where the adapters are associated to.\n    /// @param  value New addresses.\n    function file(bytes32 what, uint16 centrifugeId, IAdapter[] calldata value) external;\n\n    /// @notice Used to update an address ( state variable ) on very rare occasions.\n    /// @dev    Currently used to update addresses of contract instances.\n    /// @param  what The name of the variable to be updated.\n    /// @param  data New address.\n    function file(bytes32 what, address data) external;\n\n    /// @notice Repay an underpaid batch. Send unused funds to subsidy pot of the pool.\n    function repay(uint16 centrifugeId, bytes memory batch) external payable;\n\n    /// @notice Retry a failed message.\n    function retry(uint16 centrifugeId, bytes memory message) external;\n\n    /// @notice Set the refund address for message associated to a poolId\n    function setRefundAddress(PoolId poolId, IRecoverable refund) external;\n\n    /// @notice Pay upfront to later be able to subsidize messages associated to a pool\n    function subsidizePool(PoolId poolId) external payable;\n\n    /// @notice Prepays for the TX cost for sending the messages through the adapters\n    ///         Currently being called from Vault Router only.\n    ///         In order to prepay, the method MUST be called with `msg.value`.\n    ///         Called is assumed to have called IGateway.estimate before calling this.\n    function payTransaction(address payer) external payable;\n\n    /// @notice Initialize batching message\n    function startBatching() external;\n\n    /// @notice Finalize batching messages and send the resulting batch message\n    function endBatching() external;\n\n    /// @notice Execute message recovery. After the challenge period, the recovery can be executed.\n    ///         If a malign adapter initiates message recovery,\n    ///         governance can dispute and immediately cancel the recovery, using any other valid adapter.\n    ///\n    ///         Only 1 recovery can be outstanding per message hash. If multiple adapters fail at the same time,\n    ///         these will need to be recovered serially (increasing the challenge period for each failed adapter).\n    /// @param  centrifugeId Chain where the adapter is configured for\n    /// @param  adapter Adapter's address that the recovery is targeting\n    /// @param  message Hash of the message to be recovered\n    function executeRecovery(uint16 centrifugeId, IAdapter adapter, bytes calldata message) external;\n\n    // --- Helpers ---\n    /// @notice A view method of the current quorum.abi\n    /// @dev    Quorum shows the amount of votes needed in order for a message to be dispatched further.\n    ///         The quorum is taken from the first adapter which is always the length of active adapters.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    /// return  Needed amount\n    function quorum(uint16 centrifugeId) external view returns (uint8);\n\n    /// @notice Gets the current active routers session id.\n    /// @dev    When the adapters are updated with new ones,\n    ///         each new set of adapters has their own sessionId.\n    ///         Currently it uses sessionId of the previous set and\n    ///         increments it by 1. The idea of an activeSessionId is\n    ///         to invalidate any incoming messages from previously used adapters.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    function activeSessionId(uint16 centrifugeId) external view returns (uint64);\n\n    /// @notice Counts how many times each incoming messages has been received per adapter.\n    /// @dev    It supports parallel messages ( duplicates ). That means that the incoming messages could be\n    ///         the result of two or more independ request from the user of the same type.\n    ///         i.e. Same user would like to deposit same underlying asset with the same amount more then once.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    /// @param  batchHash The hash value of the incoming batch message.\n    function votes(uint16 centrifugeId, bytes32 batchHash) external view returns (uint16[MAX_ADAPTER_COUNT] memory);\n\n    /// @notice Used to calculate overall cost for bridging a payload on the first adapter and settling\n    ///         on the destination chain and bridging its payload proofs on n-1 adapter\n    ///         and settling on the destination chain.\n    /// @param  payload Used in gas cost calculations.\n    /// @dev    Currenly the payload is not taken into consideration.\n    /// @return total Total cost for sending one message and corresponding proofs on through all adapters\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256 total);\n\n    /// @notice Returns the address of the adapter at the given id.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    function adapters(uint16 centrifugeId, uint256 id) external view returns (IAdapter);\n\n    /// @notice Returns the timestamp when the given recovery can be executed.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    function recoveries(uint16 centrifugeId, IAdapter adapter, bytes32 batchHash)\n        external\n        view\n        returns (uint256 timestamp);\n\n    /// @notice Returns the current gateway batching level.\n    function isBatching() external view returns (bool);\n}\n"
    },
    "src/common/interfaces/IGatewayHandlers.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {D18} from \"src/misc/types/D18.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\n/// -----------------------------------------------------\n///  Common Handlers\n/// -----------------------------------------------------\n/// @notice Interface for Gateway methods called by messages\ninterface IGatewayHandler {\n    /// @notice Initialize the recovery of a payload.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    /// @param  adapter Adapter that the recovery was targeting\n    /// @param  payloadHash Hash of the payload being disputed\n    function initiateRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external;\n\n    /// @notice Cancel the recovery of a payload.\n    /// @param  centrifugeId Chain where the adapter is configured for\n    /// @param  adapter Adapter that the recovery was targeting\n    /// @param  payloadHash Hash of the payload being disputed\n    function disputeRecovery(uint16 centrifugeId, IAdapter adapter, bytes32 payloadHash) external;\n}\n\n/// -----------------------------------------------------\n///  CP Handlers\n/// -----------------------------------------------------\n\n/// @notice Interface for CP methods called by messages\ninterface IHubGatewayHandler {\n    /// @notice Tells that an asset was already registered in CV, in order to perform the corresponding register.\n    function registerAsset(AssetId assetId, uint8 decimals) external;\n\n    /// @notice Perform a deposit that was requested from CV.\n    function depositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId, uint128 amount)\n        external;\n\n    /// @notice Perform a redeem that was requested from CV.\n    function redeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId, uint128 amount)\n        external;\n\n    /// @notice Perform a deposit cancellation that was requested from CV.\n    function cancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external;\n\n    /// @notice Perform a redeem cancellation that was requested from CV.\n    function cancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId) external;\n\n    /// @notice Update a holding by request from CAL.\n    function updateHoldingAmount(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease\n    ) external;\n\n    /// @notice Increases the total issuance of shares by request from CAL.\n    function increaseShareIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external;\n\n    /// @notice Decreases the total issuance of shares by request from CAL.\n    function decreaseShareIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external;\n}\n\n/// -----------------------------------------------------\n///  CV Handlers\n/// -----------------------------------------------------\n\n/// @notice Interface for CV methods related to pools called by messages\ninterface IPoolManagerGatewayHandler {\n    /// @notice    New pool details from an existing Centrifuge pool are added.\n    /// @dev       The function can only be executed by the gateway contract.\n    function addPool(PoolId poolId) external;\n\n    /// @notice     New share class details from an existing Centrifuge pool are added.\n    /// @dev        The function can only be executed by the gateway contract.\n    function addShareClass(\n        PoolId poolId,\n        ShareClassId scId,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals,\n        bytes32 salt,\n        address hook\n    ) external;\n\n    /// @notice   Updates the tokenName and tokenSymbol of a share class token\n    /// @dev      The function can only be executed by the gateway contract.\n    function updateShareMetadata(PoolId poolId, ShareClassId scId, string memory tokenName, string memory tokenSymbol)\n        external;\n\n    /// @notice  Updates the price of a share class token, i.e. the factor of pool currency amount per share class token\n    /// @dev     The function can only be executed by the gateway contract.\n    /// @param  poolId The pool id\n    /// @param  scId The share class id\n    /// @param  price The price of pool currency per share class token as factor.\n    /// @param  computedAt The timestamp when the price was computed\n    function updatePricePoolPerShare(PoolId poolId, ShareClassId scId, uint128 price, uint64 computedAt) external;\n\n    /// @notice  Updates the price of an asset, i.e. the factor of pool currency amount per asset unit\n    /// @dev     The function can only be executed by the gateway contract.\n    /// @param  poolId The pool id\n    /// @param  scId The share class id\n    /// @param  assetId The asset id\n    /// @param  poolPerAsset The price of pool currency per asset unit as factor.\n    /// @param  computedAt The timestamp when the price was computed\n    function updatePricePoolPerAsset(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 poolPerAsset,\n        uint64 computedAt\n    ) external;\n\n    /// @notice Updates the hook of a share class token\n    /// @param  poolId The centrifuge pool id\n    /// @param  scId The share class id\n    /// @param  hook The new hook addres\n    function updateShareHook(PoolId poolId, ShareClassId scId, address hook) external;\n\n    /// @notice Updates the restrictions on a share class token for a specific user\n    /// @param  poolId The centrifuge pool id\n    /// @param  scId The share class id\n    /// @param  update The restriction update in the form of a bytes array indicating\n    ///                the restriction to be updated, the user to be updated, and a validUntil timestamp.\n    function updateRestriction(PoolId poolId, ShareClassId scId, bytes memory update) external;\n\n    /// @notice Mints share class tokens to a recipient\n    /// @dev    The function can only be executed internally or by the gateway contract.\n    function handleTransferShares(PoolId poolId, ShareClassId scId, address destinationAddress, uint128 amount)\n        external;\n\n    /// @notice Updates the target address. Generic update function from CP to CV\n    /// @param  poolId The centrifuge pool id\n    /// @param  scId The share class id\n    /// @param  target The target address to be called\n    /// @param  update The payload to be processed by the target address\n    function updateContract(PoolId poolId, ShareClassId scId, address target, bytes memory update) external;\n}\n\n/// @notice Interface for CV methods related to async investments called by messages\ninterface IRequestManagerGatewayHandler {\n    /// @notice Signal from the Hub that an asynchronous investment order has been approved\n    ///\n    /// @dev This message needs to trigger making the asset amounts available to the pool-share-class.\n    function approvedDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        D18 pricePoolPerAsset\n    ) external;\n\n    /// @notice Signal from the Hub that an asynchronous investment order has been finalized. Shares have been issued.\n    ///\n    /// @dev This message needs to trigger minting the new amount of shares.\n    function issuedShares(PoolId poolId, ShareClassId scId, uint128 shareAmount, D18 pricePoolPerShare) external;\n\n    /// @notice Signal from the Hub that an asynchronous redeem order has been finalized.\n    ///\n    /// @dev This messages needs to trigger reserving the asset amount for claims of redemptions by users.\n    function revokedShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) external;\n\n    // --- Deposits ---\n    /// @notice Fulfills pending deposit requests after successful epoch execution on CP.\n    ///         The amount of shares that can be claimed by the user is minted and moved to the escrow contract.\n    ///         The MaxMint bookkeeping value is updated.\n    ///         The request fulfillment can be partial.\n    /// @dev    The shares in the escrow are reserved for the user and are transferred to the user on deposit\n    ///         and mint calls.\n    function fulfillDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        address user,\n        AssetId assetId,\n        uint128 assets,\n        uint128 shares\n    ) external;\n\n    /// @notice Fulfills deposit request cancellation after successful epoch execution on CP.\n    ///         The amount of assets that can be claimed by the user is locked in the escrow contract.\n    ///         Updates claimableCancelDepositRequest bookkeeping value. The cancellation order execution can be\n    ///         partial.\n    /// @dev    The assets in the escrow are reserved for the user and are transferred to the user during\n    ///         claimCancelDepositRequest calls.\n    ///         `fulfillment` represents the decrease in `pendingDepositRequest`.\n    ///         This is a separate parameter from `assets` since there can be some precision loss when calculating this,\n    ///         which would lead to having dust in the pendingDepositRequest value and\n    ///         never closing out the request even after it is technically fulfilled.\n    ///\n    ///         Example:\n    ///         User deposits 100 units of the vaults underlying asset.\n    ///         - At some point they make cancellation request. The order in which is not guaranteed\n    ///         Both requests arrive at CentrifugeChain. If the cancellation is first then all of the\n    ///         deposited amount will be cancelled.\n    ///\n    ///         - There is the case where the deposit event is first and it gets completely fulfilled then\n    ///         No amount of the deposited asset will be cancelled.\n    ///\n    ///         - There is the case where partially the deposit request is fulfilled. Let's say 40 units.\n    ///         Then the cancel request arrives.\n    ///         The remaining amount of deposited funds which is 60 units will cancelled.\n    ///         There is a scenario where the deposit funds might different from the pool currency so some\n    ///         swapping might happen. Either during this swapping or some fee collection or rounding there will be\n    ///         difference between the actual amount that will be returned to the user.\n    ///         `fulfillment` in this case will be 60 units but assets will be some lower amount because of the\n    ///         aforementioned reasons\n    ///         Let's assume the `asset` is 59. The user will be able to take back these 59 but\n    ///         in order to not let any dust, we use `fulfillment` in our calculations.\n    ///\n    ///         `pendingDepositRequest` not necessary gets zeroed during this cancellation event.\n    ///         When CentrifugeChain process the cancel event on its side, part of the deposit might be fulfilled.\n    ///         In such case the chain will send two messages, one `fulfillDepositRequest` and one\n    ///         `fulfillCancelDepositRequest`. In the example above, given the 100 units\n    ///         deposited, 40 units are fulfilled and 60 can be cancelled.\n    ///         The two messages sent from CentrifugeChain are not guaranteed to arrive in order.\n    ///\n    ///         Assuming first is the `fulfillCancelDepositRequest` the `pendingDepositRequest` here will be reduced to\n    ///         60 units only. Then the `fulfillCancelDepositRequest` arrives with `fulfillment` 60. This amount is\n    ///         removed from `pendingDepositRequests`. Since there are not more pendingDepositRequest` the\n    ///         `pendingCancelDepositRequest` gets deleted.\n    ///\n    ///         Assuming first the `fulfillCancelDepositRequest` arrives then the `pendingDepositRequest` will be 100.\n    ///         `fulfillment` is 60 so we are left with `pendingDepositRequest` equals to 40 ( 100 - 60 ).\n    ///         Then the second message arrives which is `fulfillDepositRequest`. ( Check `fulfillDepositRequest`\n    ///         implementation for details.)\n    ///         When it arrives the `pendingDepositRequest` is 40 and the assets is 40\n    ///         so there are no more `pendingDepositRequest` and right there the `pendingCancelDepositRequest will be\n    ///         deleted.\n    function fulfillCancelDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        address user,\n        AssetId assetId,\n        uint128 assets,\n        uint128 fulfillment\n    ) external;\n\n    // --- Redeems ---\n    /// @notice Fulfills pending redeem requests after successful epoch execution on CP.\n    ///         The amount of redeemed shares is burned. The amount of assets that can be claimed by the user in\n    ///         return is locked in the escrow contract. The MaxWithdraw bookkeeping value is updated.\n    ///         The request fulfillment can be partial.\n    /// @dev    The assets in the escrow are reserved for the user and are transferred to the user on redeem\n    ///         and withdraw calls.\n    function fulfillRedeemRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        address user,\n        AssetId assetId,\n        uint128 assets,\n        uint128 shares\n    ) external;\n\n    /// @notice Fulfills redeem request cancellation after successful epoch execution on CP.\n    ///         The amount of shares that can be claimed by the user is locked in the escrow contract.\n    ///         Updates claimableCancelRedeemRequest bookkeeping value. The cancellation order execution can also be\n    ///         partial.\n    /// @dev    The shares in the escrow are reserved for the user and are transferred to the user during\n    ///         claimCancelRedeemRequest calls.\n    function fulfillCancelRedeemRequest(PoolId poolId, ShareClassId scId, address user, AssetId assetId, uint128 shares)\n        external;\n}\n\n/// @notice Interface for CV methods related to epoch called by messages\ninterface IBalanceSheetGatewayHandler {\n    function triggerDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, address provider, uint128 amount)\n        external;\n\n    function triggerWithdraw(PoolId poolId, ShareClassId scId, AssetId assetId, address receiver, uint128 amount)\n        external;\n\n    function triggerIssueShares(PoolId poolId, ShareClassId scId, address to, uint128 shares) external;\n\n    function submitQueuedShares(PoolId poolId, ShareClassId scId) external;\n\n    function submitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) external;\n\n    function setQueue(PoolId poolId, ShareClassId scId, bool enabled) external;\n}\n"
    },
    "src/common/interfaces/IGatewaySenders.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {D18} from \"src/misc/types/D18.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\ninterface ILocalCentrifugeId {\n    function localCentrifugeId() external view returns (uint16);\n}\n\n/// @notice Interface for dispatch-only gateway\ninterface IRootMessageSender {\n    /// @notice Creates and send the message\n    function sendScheduleUpgrade(uint16 centrifugeId, bytes32 target) external;\n\n    /// @notice Creates and send the message\n    function sendCancelUpgrade(uint16 centrifugeId, bytes32 target) external;\n\n    /// @notice Creates and send the message\n    function sendRecoverTokens(\n        uint16 centrifugeId,\n        bytes32 target,\n        bytes32 token,\n        uint256 tokenId,\n        bytes32 to,\n        uint256 amount\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendInitiateRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, bytes32 adapter, bytes32 hash)\n        external;\n\n    /// @notice Creates and send the message\n    function sendDisputeRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, bytes32 adapter, bytes32 hash)\n        external;\n}\n\n/// @notice Interface for dispatch-only gateway\ninterface IPoolMessageSender is ILocalCentrifugeId {\n    /// @notice Creates and send the message\n    function sendNotifyPool(uint16 centrifugeId, PoolId poolId) external;\n\n    /// @notice Creates and send the message\n    function sendNotifyShareClass(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 salt,\n        bytes32 hook\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendNotifyShareMetadata(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        string memory name,\n        string memory symbol\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendUpdateShareHook(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes32 hook) external;\n\n    /// @notice Creates and send the message\n    function sendNotifyPricePoolPerShare(uint16 chainId, PoolId poolId, ShareClassId scId, D18 pricePerShare)\n        external;\n\n    /// @notice Creates and send the message\n    function sendNotifyPricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 pricePerShare)\n        external;\n\n    /// @notice Creates and send the message\n    function sendFulfilledDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 assetAmount,\n        uint128 shareAmount\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendFulfilledRedeemRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 assetAmount,\n        uint128 shareAmount\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendFulfilledCancelDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 cancelledAmount\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendFulfilledCancelRedeemRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        bytes32 investor,\n        uint128 cancelledShares\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendUpdateRestriction(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes calldata payload)\n        external;\n\n    /// @notice Creates and send the message\n    function sendUpdateContract(\n        uint16 centrifugeId,\n        PoolId poolId,\n        ShareClassId scId,\n        bytes32 target,\n        bytes calldata payload\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendApprovedDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        D18 pricePoolPerAsset\n    ) external;\n\n    // @notice Creates and send the message\n    function sendIssuedShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendRevokedShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendTriggerIssueShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, address who, uint128 shares)\n        external;\n\n    /// @notice Creates and send the message\n    function sendTriggerSubmitQueuedShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId) external;\n\n    /// @notice Creates and send the message\n    function sendTriggerSubmitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) external;\n\n    /// @notice Creates and send the message\n    function sendSetQueue(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bool enabled) external;\n}\n\n/// @notice Interface for dispatch-only gateway\ninterface IVaultMessageSender is ILocalCentrifugeId {\n    /// @notice Creates and send the message\n    function sendTransferShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes32 receiver, uint128 amount)\n        external;\n\n    /// @notice Creates and send the message\n    function sendDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId, uint128 amount)\n        external;\n\n    /// @notice Creates and send the message\n    function sendRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId, uint128 amount)\n        external;\n\n    /// @notice Creates and send the message\n    function sendCancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId) external;\n\n    /// @notice Creates and send the message\n    function sendCancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId assetId) external;\n\n    /// @notice Creates and send the message\n    function sendRegisterAsset(uint16 centrifugeId, AssetId assetId, uint8 decimals) external;\n\n    /// @notice Creates and send the message\n    function sendUpdateHoldingAmount(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address provider,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease\n    ) external;\n\n    /// @notice Creates and send the message\n    function sendUpdateShares(PoolId poolId, ShareClassId scId, uint128 shares, bool isIssuance) external;\n}\n"
    },
    "src/common/interfaces/IGuardian.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\ninterface ISafe {\n    function isOwner(address signer) external view returns (bool);\n}\n\ninterface IGuardian {\n    error NotTheAuthorizedSafe();\n    error NotTheAuthorizedSafeOrItsOwner();\n\n    /// @notice Dispatched when the `what` parameter of `file()` is not supported by the implementation.\n    error FileUnrecognizedParam();\n\n    /// @notice Emitted when a call to `file()` was performed.\n    event File(bytes32 indexed what, address addr);\n\n    /// @notice Return the linked Safe\n    function safe() external view returns (ISafe);\n\n    /// @notice Updates a contract parameter.\n    /// @param what Name of the parameter to update.\n    /// Accepts a `bytes32` representation of 'sender' string value.\n    /// @param data New value given to the `what` parameter\n    function file(bytes32 what, address data) external;\n\n    /// @notice Registers a new pool\n    function createPool(PoolId poolId, address admin, AssetId currency) external;\n\n    /// @notice Pause the protocol\n    /// @dev callable by both safe and owners\n    function pause() external;\n\n    /// @notice Unpause the protocol\n    /// @dev callable by safe only\n    function unpause() external;\n\n    /// @notice Schedule relying a target address on Root\n    /// @dev callable by safe only\n    function scheduleRely(address target) external;\n\n    /// @notice Cancel a scheduled rely\n    /// @dev callable by safe only\n    function cancelRely(address target) external;\n\n    /// @notice Schedule an upgrade (scheduled rely) on a specific chain\n    /// @dev    Only supports EVM targets today\n    function scheduleUpgrade(uint16 centrifugeId, address target) external;\n\n    /// @notice Cancel an upgrade (scheduled rely) on a specific chain\n    /// @dev    Only supports EVM targets today\n    function cancelUpgrade(uint16 centrifugeId, address target) external;\n\n    /// @notice Recover tokens on a specific chain\n    /// @dev    Only supports EVM targets today\n    function recoverTokens(\n        uint16 centrifugeId,\n        address target,\n        address token,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) external;\n\n    /// @notice Initiate a gateway payload recovery on a specific chain\n    /// @dev    Only supports EVM targets today\n    function initiateRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, IAdapter adapter, bytes32 hash)\n        external;\n\n    /// @notice Dispute a gateway paylaod recovery on a specific chain\n    /// @dev    Only supports EVM targets today\n    function disputeRecovery(uint16 centrifugeId, uint16 adapterCentrifugeId, IAdapter adapter, bytes32 hash)\n        external;\n}\n"
    },
    "src/common/interfaces/IGuardianActions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\ninterface IHubGuardianActions {\n    /// @notice Creates a new pool. `msg.sender` will be the admin of the created pool.\n    /// @param currency The pool currency. Usually an AssetId identifying by a ISO4217 code.\n    function createPool(PoolId poolId, address admin, AssetId currency) external payable;\n}\n"
    },
    "src/common/interfaces/IHook.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nstruct HookData {\n    bytes16 from;\n    bytes16 to;\n}\n\nuint8 constant SUCCESS_CODE_ID = 0;\nstring constant SUCCESS_MESSAGE = \"transfer-allowed\";\n\nuint8 constant ERROR_CODE_ID = 1;\nstring constant ERROR_MESSAGE = \"transfer-blocked\";\n\n/// @dev Magic address denoting a transfer to the escrow\n/// @dev Solely used for gas saving since escrow is per pool\naddress constant ESCROW_HOOK_ID = address(uint160(uint8(0xce)));\n\n/// @notice Hook interface to customize share token behaviour\n/// @dev    To detect specific system actions:\n///           Deposit request:      address(0)      -> address(user)\n///           Deposit claim:        ESCROW_HOOK_ID  -> address(user)\n///           Redeem request:       address(user)   -> ESCROW_HOOK_ID\n///           Redeem claim:         address(user)   -> address(0)\n///           Cross-chain transfer: address(user)   -> address(uint160(chainId))\ninterface IHook is IERC165 {\n    // --- Errors ---\n    error TransferBlocked();\n    error InvalidUpdate();\n\n    /// @notice Callback on standard ERC20 transfer.\n    /// @dev    MUST return bytes4(keccak256(\"onERC20Transfer(address,address,uint256,(bytes16,bytes16))\"))\n    ///         if successful\n    function onERC20Transfer(address from, address to, uint256 value, HookData calldata hookdata)\n        external\n        returns (bytes4);\n\n    /// @notice Callback on authorized ERC20 transfer.\n    /// @dev    Cannot be blocked, can only be used to update state.\n    ///         Return value is ignored, only kept for compatibility with V2 share tokens.\n    function onERC20AuthTransfer(address sender, address from, address to, uint256 value, HookData calldata hookdata)\n        external\n        returns (bytes4);\n\n    /// @notice Check if given transfer can be performed\n    function checkERC20Transfer(address from, address to, uint256 value, HookData calldata hookData)\n        external\n        view\n        returns (bool);\n\n    /// @notice Update a set of restriction for a token\n    /// @dev    MAY be user specific, which would be included in the encoded `update` value\n    function updateRestriction(address token, bytes memory update) external;\n}\n"
    },
    "src/common/interfaces/IMessageDispatcher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IVaultMessageSender, IPoolMessageSender, IRootMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\n\ninterface IMessageDispatcher is IRootMessageSender, IVaultMessageSender, IPoolMessageSender {\n    /// @notice Emitted when a call to `file()` was performed.\n    event File(bytes32 indexed what, address addr);\n\n    /// @notice Dispatched when the `what` parameter of `file()` is not supported by the implementation.\n    error FileUnrecognizedParam();\n\n    /// @notice Updates a contract parameter.\n    /// @param what Name of the parameter to update.\n    /// Accepts a `bytes32` representation of 'hubRegistry' string value.\n    /// @param data New value given to the `what` parameter\n    function file(bytes32 what, address data) external;\n\n    /// @notice Estimate sending a message through the gateway.\n    /// If the message is to the same centrifugeId, then the estimation is 0.\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256 amount);\n}\n"
    },
    "src/common/interfaces/IMessageHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/// @notice Generic interface for entities that handle incoming messages\ninterface IMessageHandler {\n    /// @notice Dispatched when an invalid message is trying to handle\n    error InvalidMessage(uint8 code);\n\n    /// @notice Handling incoming messages.\n    /// @param centrifugeId Source chain\n    /// @param message Incoming message\n    function handle(uint16 centrifugeId, bytes calldata message) external;\n}\n"
    },
    "src/common/interfaces/IMessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {IMessageProperties} from \"src/common/interfaces/IMessageProperties.sol\";\n\ninterface IMessageProcessor is IMessageHandler, IMessageProperties {\n    /// @notice Emitted when a call to `file()` was performed.\n    event File(bytes32 indexed what, address addr);\n\n    /// @notice Dispatched when the `what` parameter of `file()` is not supported by the implementation.\n    error FileUnrecognizedParam();\n\n    /// @notice Updates a contract parameter.\n    /// @param what Name of the parameter to update.\n    /// Accepts a `bytes32` representation of 'hubRegistry' string value.\n    /// @param data New value given to the `what` parameter\n    function file(bytes32 what, address data) external;\n}\n"
    },
    "src/common/interfaces/IMessageProperties.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\n/// @notice Defines methods to get properties from raw messages\ninterface IMessageProperties {\n    /// @notice Inspect the message to tell if the message is recovery message\n    function isMessageRecovery(bytes calldata message) external pure returns (bool);\n\n    /// @notice Inspect the message to return the length\n    function messageLength(bytes calldata message) external pure returns (uint16);\n\n    /// @notice Inspect the message to return the associated PoolId if any\n    function messagePoolId(bytes calldata message) external pure returns (PoolId);\n}\n"
    },
    "src/common/interfaces/IMessageSender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/// @notice Generic interface for entities that handles outgoing messages\ninterface IMessageSender {\n    /// @notice Handling outgoing messages.\n    /// @param centrifugeId Destination chain\n    function send(uint16 centrifugeId, bytes calldata message) external;\n}\n"
    },
    "src/common/interfaces/IRoot.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\n\ninterface IRoot {\n    // --- Events ---\n    event File(bytes32 indexed what, uint256 data);\n    event Pause();\n    event Unpause();\n    event ScheduleRely(address indexed target, uint256 indexed scheduledTime);\n    event CancelRely(address indexed target);\n    event RelyContract(address indexed target, address indexed user);\n    event DenyContract(address indexed target, address indexed user);\n    event Endorse(address indexed user);\n    event Veto(address indexed user);\n\n    error DelayTooLong();\n    error FileUnrecognizedParam();\n    error TargetNotScheduled();\n    error TargetNotReady();\n\n    /// @notice Returns whether the root is paused\n    function paused() external view returns (bool);\n\n    /// @notice Returns the current timelock for adding new wards\n    function delay() external view returns (uint256);\n\n    /// @notice Trusted contracts within the system\n    function endorsements(address target) external view returns (uint256);\n\n    /// @notice Returns when `relyTarget` has passed the timelock\n    function schedule(address relyTarget) external view returns (uint256 timestamp);\n\n    // --- Administration ---\n    /// @notice Updates a contract parameter\n    /// @param what Accepts a bytes32 representation of 'delay'\n    function file(bytes32 what, uint256 data) external;\n\n    /// --- Endorsements ---\n    /// @notice Endorses the `user`\n    /// @dev    Endorsed users are trusted contracts in the system. They are allowed to bypass\n    ///         token restrictions (e.g. the Escrow can automatically receive share class tokens by being endorsed), and\n    ///         can automatically set operators in ERC-7540 vaults (e.g. the VaultRouter) is always an operator.\n    function endorse(address user) external;\n\n    /// @notice Removes the endorsed user\n    function veto(address user) external;\n\n    /// @notice Returns whether the user is endorsed\n    function endorsed(address user) external view returns (bool);\n\n    // --- Pause management ---\n    /// @notice Pause any contracts that depend on `Root.paused()`\n    function pause() external;\n\n    /// @notice Unpause any contracts that depend on `Root.paused()`\n    function unpause() external;\n\n    /// --- Timelocked ward management ---\n    /// @notice Schedule relying a new ward after the delay has passed\n    function scheduleRely(address target) external;\n\n    /// @notice Cancel a pending scheduled rely\n    function cancelRely(address target) external;\n\n    /// @notice Execute a scheduled rely\n    /// @dev    Can be triggered by anyone since the scheduling is protected\n    function executeScheduledRely(address target) external;\n\n    /// --- External contract ward management ---\n    /// @notice Make an address a ward on any contract that Root is a ward on\n    function relyContract(address target, address user) external;\n\n    /// @notice Removes an address as a ward on any contract that Root is a ward on\n    function denyContract(address target, address user) external;\n}\n"
    },
    "src/common/interfaces/ITokenRecoverer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\ninterface ITokenRecoverer {\n    event RecoverTokens(\n        IRecoverable indexed target, address indexed token, uint256 tokenId, address indexed to, uint256 amount\n    );\n\n    function recoverTokens(IRecoverable target, address token, uint256 tokenId, address to, uint256 amount) external;\n}\n"
    },
    "src/common/interfaces/IWormholeAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\n// From https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/main/src/interfaces/IWormholeRelayer.sol#L75\ninterface IWormholeRelayer {\n    /**\n     * @notice Publishes an instruction for the default delivery provider\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\n     *\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\n     * `targetAddress` must implement the IWormholeReceiver interface\n     *\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue,\n     * gasLimit)`\n     *\n     * @param targetChain in Wormhole Chain ID format\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain\n     * currency units)\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according\n     * to the\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\n     * @param refundAddress The address on `refundChain` to deliver any refund to\n     * @return sequence sequence number of published VAA containing delivery instructions\n     */\n    function sendPayloadToEvm(\n        uint16 targetChain,\n        address targetAddress,\n        bytes memory payload,\n        uint256 receiverValue,\n        uint256 gasLimit,\n        uint16 refundChain,\n        address refundAddress\n    ) external payable returns (uint64 sequence);\n\n    /**\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\n     *\n     * @param targetChain in Wormhole Chain ID format\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain\n     * currency units)\n     * @param gasLimit gas limit with which to call `targetAddress`.\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform\n     * the relay\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas\n     * unused,\n     *         if a refundAddress is specified.\n     *         Note: This value can be overridden by the delivery provider on the target chain. The returned value here\n     * should be considered to be a\n     *         promise by the delivery provider of the amount of refund per gas unused that will be returned to the\n     * refundAddress at the target chain.\n     *         If a delivery provider decides to override, this will be visible as part of the emitted Delivery event on\n     * the target chain.\n     */\n    function quoteEVMDeliveryPrice(uint16 targetChain, uint256 receiverValue, uint256 gasLimit)\n        external\n        view\n        returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\n\n    /**\n     * @notice Returns the address of the current default delivery provider\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\n     *   chain. This must be a contract that implements IDeliveryProvider.\n     */\n    function getDefaultDeliveryProvider() external view returns (address deliveryProvider);\n}\n\ninterface IWormholeDeliveryProvider {\n    /// @notice Returns the chain ID.\n    function chainId() external view returns (uint16);\n}\n\n// From\n// https://github.com/wormhole-foundation/wormhole/blob/main/relayer/ethereum/contracts/interfaces/relayer/IWormholeReceiver.sol\ninterface IWormholeReceiver {\n    /**\n     * @notice When a `send` is performed with this contract as the target, this function will be\n     *     invoked by the WormholeRelayer contract\n     *\n     * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\n     *\n     * We also recommend that this function checks that `sourceChain` and `sourceAddress` are indeed who\n     *       you expect to have requested the calling of `send` on the source chain\n     *\n     * The invocation of this function corresponding to the `send` request will have msg.value equal\n     *   to the receiverValue specified in the send request.\n     *\n     * If the invocation of this function reverts or exceeds the gas limit\n     *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\n     *\n     * @param payload - an arbitrary message which was included in the delivery by the\n     *     requester. This message's signature will already have been verified (as long as msg.sender is the Wormhole\n     * Relayer contract)\n     * @param additionalMessages - Additional messages which were requested to be included in this delivery.\n     *      Note: There are no contract-level guarantees that the messages in this array are what was requested\n     *      so **you should verify any sensitive information given here!**\n     *\n     *      For example, if a 'VaaKey' was specified on the source chain, then MAKE SURE the corresponding message here\n     *      has valid signatures (by calling `parseAndVerifyVM(message)` on the Wormhole core contract)\n     *\n     *      This field can be used to perform and relay TokenBridge or CCTP transfers, and there are example\n     *      usages of this at\n     *         https://github.com/wormhole-foundation/hello-token\n     *         https://github.com/wormhole-foundation/hello-cctp\n     *\n     * @param sourceAddress - the (wormhole format) address on the sending chain which requested\n     *     this delivery.\n     * @param sourceChain - the wormhole chain ID where this delivery was requested.\n     * @param deliveryHash - the VAA hash of the deliveryVAA.\n     *\n     */\n    function receiveWormholeMessages(\n        bytes memory payload,\n        bytes[] memory additionalMessages,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32 deliveryHash\n    ) external payable;\n}\n\nstruct WormholeSource {\n    uint16 centrifugeId;\n    address addr;\n}\n\nstruct WormholeDestination {\n    uint16 wormholeId;\n    address addr;\n}\n\ninterface IWormholeAdapter is IAdapter, IWormholeReceiver {\n    /// @dev see file() method\n    event File(bytes32 indexed what, uint16 fromChainId, uint16 toChainId, address addr);\n\n    error FileUnrecognizedParam();\n    error NotWormholeRelayer();\n    error InvalidSource();\n\n    /// @dev Configures the adapter\n    /// @param what Can be \"sources\" or \"destinations\".\n    /// @param addr if what == \"sources\", it represents the source\n    /// @param addr if what == \"destinations\", it represents the destination\n    function file(bytes32 what, uint16 centrifugeId, uint16 wormholeId, address addr) external;\n}\n"
    },
    "src/common/libraries/MessageLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nenum MessageType {\n    /// @dev Placeholder for null message type\n    _Invalid,\n    /// @dev Placeholder for proof message type\n    _MessageProof,\n    // -- Gateway messages\n    InitiateRecovery,\n    DisputeRecovery,\n    // -- Root messages\n    ScheduleUpgrade,\n    CancelUpgrade,\n    RecoverTokens,\n    // -- Pool manager messages\n    RegisterAsset,\n    NotifyPool,\n    NotifyShareClass,\n    NotifyPricePoolPerShare,\n    NotifyPricePoolPerAsset,\n    NotifyShareMetadata,\n    UpdateShareHook,\n    TransferShares,\n    UpdateRestriction,\n    UpdateContract,\n    ApprovedDeposits,\n    IssuedShares,\n    RevokedShares,\n    // -- Investment manager messages\n    DepositRequest,\n    RedeemRequest,\n    FulfilledDepositRequest,\n    FulfilledRedeemRequest,\n    CancelDepositRequest,\n    CancelRedeemRequest,\n    FulfilledCancelDepositRequest,\n    FulfilledCancelRedeemRequest,\n    // -- BalanceSheet messages\n    UpdateHoldingAmount,\n    UpdateShares,\n    TriggerIssueShares,\n    TriggerSubmitQueuedShares,\n    TriggerSubmitQueuedAssets,\n    SetQueue\n}\n\nenum UpdateRestrictionType {\n    /// @dev Placeholder for null update restriction type\n    Invalid,\n    Member,\n    Freeze,\n    Unfreeze\n}\n\nenum UpdateContractType {\n    /// @dev Placeholder for null update restriction type\n    Invalid,\n    VaultUpdate,\n    UpdateManager,\n    MaxAssetPriceAge,\n    MaxSharePriceAge,\n    Valuation,\n    SyncDepositMaxReserve\n}\n\n/// @dev Used internally in the VaultUpdateMessage (not represent a submessage)\nenum VaultUpdateKind {\n    DeployAndLink,\n    Link,\n    Unlink\n}\n\nlibrary MessageLib {\n    using MessageLib for bytes;\n    using BytesLib for bytes;\n    using CastLib for *;\n\n    error UnknownMessageType();\n\n    /// @dev Encode all message lengths in this constant to avoid a large list of if/elseif checks\n    /// and reduce generated bytecode.\n    /// If the message has some dynamic part, will be added later in `messageLength()`.\n    // forgefmt: disable-next-item\n    uint256 constant MESSAGE_LENGTHS_1 =\n        (67  << uint8(MessageType.InitiateRecovery) * 8) +\n        (67  << uint8(MessageType.DisputeRecovery) * 8) +\n        (33  << uint8(MessageType.ScheduleUpgrade) * 8) +\n        (33  << uint8(MessageType.CancelUpgrade) * 8) +\n        (161 << uint8(MessageType.RecoverTokens) * 8) +\n        (18  << uint8(MessageType.RegisterAsset) * 8) +\n        (9   << uint8(MessageType.NotifyPool) * 8) +\n        (250 << uint8(MessageType.NotifyShareClass) * 8) +\n        (49  << uint8(MessageType.NotifyPricePoolPerShare) * 8) +\n        (65  << uint8(MessageType.NotifyPricePoolPerAsset) * 8) +\n        (185 << uint8(MessageType.NotifyShareMetadata) * 8) +\n        (57  << uint8(MessageType.UpdateShareHook) * 8) +\n        (73  << uint8(MessageType.TransferShares) * 8) +\n        (25  << uint8(MessageType.UpdateRestriction) * 8) +\n        (57  << uint8(MessageType.UpdateContract) * 8) +\n        (73  << uint8(MessageType.ApprovedDeposits) * 8) +\n        (57  << uint8(MessageType.IssuedShares) * 8) +\n        (89  << uint8(MessageType.RevokedShares) * 8) +\n        (89  << uint8(MessageType.DepositRequest) * 8) +\n        (89  << uint8(MessageType.RedeemRequest) * 8) +\n        (105 << uint8(MessageType.FulfilledDepositRequest) * 8) +\n        (105 << uint8(MessageType.FulfilledRedeemRequest) * 8) +\n        (73  << uint8(MessageType.CancelDepositRequest) * 8) +\n        (73  << uint8(MessageType.CancelRedeemRequest) * 8) +\n        (89  << uint8(MessageType.FulfilledCancelDepositRequest) * 8) +\n        (89  << uint8(MessageType.FulfilledCancelRedeemRequest) * 8) +\n        (114 << uint8(MessageType.UpdateHoldingAmount) * 8) +\n        (50  << uint8(MessageType.UpdateShares) * 8) +\n        (73  << uint8(MessageType.TriggerIssueShares) * 8) +\n        (25  << uint8(MessageType.TriggerSubmitQueuedShares) * 8);\n\n    // forgefmt: disable-next-item\n    uint256 constant MESSAGE_LENGTHS_2 =\n        (41 << (uint8(MessageType.TriggerSubmitQueuedAssets) - 32) * 8) +\n        (26 << (uint8(MessageType.SetQueue) - 32) * 8);\n\n    function messageType(bytes memory message) internal pure returns (MessageType) {\n        return MessageType(message.toUint8(0));\n    }\n\n    function messageCode(bytes memory message) internal pure returns (uint8) {\n        return message.toUint8(0);\n    }\n\n    function messageLength(bytes memory message) internal pure returns (uint16 length) {\n        uint8 kind = message.toUint8(0);\n        require(kind <= uint8(type(MessageType).max), UnknownMessageType());\n\n        length = (kind <= 31)\n            ? uint16(uint8(bytes32(MESSAGE_LENGTHS_1)[31 - kind]))\n            : uint16(uint8(bytes32(MESSAGE_LENGTHS_2)[63 - kind]));\n\n        // Spetial treatment for messages with dynamic size:\n        if (kind == uint8(MessageType.UpdateRestriction)) {\n            length += 2 + message.toUint16(length); //payloadLength\n        } else if (kind == uint8(MessageType.UpdateContract)) {\n            length += 2 + message.toUint16(length); //payloadLength\n        }\n    }\n\n    function messagePoolId(bytes memory message) internal pure returns (PoolId poolId) {\n        uint8 kind = message.toUint8(0);\n\n        // All messages from NotifyPool to SetQueue contains a PoolId in position 1.\n        if (kind >= uint8(MessageType.NotifyPool) && kind <= uint8(MessageType.SetQueue)) {\n            return PoolId.wrap(message.toUint64(1));\n        } else {\n            return PoolId.wrap(0);\n        }\n    }\n\n    function updateRestrictionType(bytes memory message) internal pure returns (UpdateRestrictionType) {\n        return UpdateRestrictionType(message.toUint8(0));\n    }\n\n    function updateContractType(bytes memory message) internal pure returns (UpdateContractType) {\n        return UpdateContractType(message.toUint8(0));\n    }\n\n    //---------------------------------------\n    //    InitiateRecovery\n    //---------------------------------------\n\n    struct InitiateRecovery {\n        bytes32 hash;\n        bytes32 adapter;\n        uint16 centrifugeId;\n    }\n\n    function deserializeInitiateRecovery(bytes memory data) internal pure returns (InitiateRecovery memory) {\n        require(messageType(data) == MessageType.InitiateRecovery, UnknownMessageType());\n        return InitiateRecovery({hash: data.toBytes32(1), adapter: data.toBytes32(33), centrifugeId: data.toUint16(65)});\n    }\n\n    function serialize(InitiateRecovery memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.InitiateRecovery, t.hash, t.adapter, t.centrifugeId);\n    }\n\n    //---------------------------------------\n    //    DisputeRecovery\n    //---------------------------------------\n\n    struct DisputeRecovery {\n        bytes32 hash;\n        bytes32 adapter;\n        uint16 centrifugeId;\n    }\n\n    function deserializeDisputeRecovery(bytes memory data) internal pure returns (DisputeRecovery memory) {\n        require(messageType(data) == MessageType.DisputeRecovery, UnknownMessageType());\n        return DisputeRecovery({hash: data.toBytes32(1), adapter: data.toBytes32(33), centrifugeId: data.toUint16(65)});\n    }\n\n    function serialize(DisputeRecovery memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.DisputeRecovery, t.hash, t.adapter, t.centrifugeId);\n    }\n\n    //---------------------------------------\n    //    ScheduleUpgrade\n    //---------------------------------------\n\n    struct ScheduleUpgrade {\n        bytes32 target;\n    }\n\n    function deserializeScheduleUpgrade(bytes memory data) internal pure returns (ScheduleUpgrade memory) {\n        require(messageType(data) == MessageType.ScheduleUpgrade, UnknownMessageType());\n        return ScheduleUpgrade({target: data.toBytes32(1)});\n    }\n\n    function serialize(ScheduleUpgrade memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.ScheduleUpgrade, t.target);\n    }\n\n    //---------------------------------------\n    //    CancelUpgrade\n    //---------------------------------------\n\n    struct CancelUpgrade {\n        bytes32 target;\n    }\n\n    function deserializeCancelUpgrade(bytes memory data) internal pure returns (CancelUpgrade memory) {\n        require(messageType(data) == MessageType.CancelUpgrade, UnknownMessageType());\n        return CancelUpgrade({target: data.toBytes32(1)});\n    }\n\n    function serialize(CancelUpgrade memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.CancelUpgrade, t.target);\n    }\n\n    //---------------------------------------\n    //    RecoverTokens\n    //---------------------------------------\n\n    struct RecoverTokens {\n        bytes32 target;\n        bytes32 token;\n        uint256 tokenId;\n        bytes32 to;\n        uint256 amount;\n    }\n\n    function deserializeRecoverTokens(bytes memory data) internal pure returns (RecoverTokens memory) {\n        require(messageType(data) == MessageType.RecoverTokens, UnknownMessageType());\n        return RecoverTokens({\n            target: data.toBytes32(1),\n            token: data.toBytes32(33),\n            tokenId: data.toUint256(65),\n            to: data.toBytes32(97),\n            amount: data.toUint256(129)\n        });\n    }\n\n    function serialize(RecoverTokens memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.RecoverTokens, t.target, t.token, t.tokenId, t.to, t.amount);\n    }\n\n    //---------------------------------------\n    //    RegisterAsset\n    //---------------------------------------\n\n    struct RegisterAsset {\n        uint128 assetId;\n        uint8 decimals;\n    }\n\n    function deserializeRegisterAsset(bytes memory data) internal pure returns (RegisterAsset memory) {\n        require(messageType(data) == MessageType.RegisterAsset, UnknownMessageType());\n        return RegisterAsset({assetId: data.toUint128(1), decimals: data.toUint8(17)});\n    }\n\n    function serialize(RegisterAsset memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.RegisterAsset, t.assetId, t.decimals);\n    }\n\n    //---------------------------------------\n    //    NotifyPool\n    //---------------------------------------\n\n    struct NotifyPool {\n        uint64 poolId;\n    }\n\n    function deserializeNotifyPool(bytes memory data) internal pure returns (NotifyPool memory) {\n        require(messageType(data) == MessageType.NotifyPool, UnknownMessageType());\n        return NotifyPool({poolId: data.toUint64(1)});\n    }\n\n    function serialize(NotifyPool memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.NotifyPool, t.poolId);\n    }\n\n    //---------------------------------------\n    //    NotifyShareClass\n    //---------------------------------------\n\n    struct NotifyShareClass {\n        uint64 poolId;\n        bytes16 scId;\n        string name; // Fixed to 128 bytes\n        bytes32 symbol; // utf8\n        uint8 decimals;\n        bytes32 salt;\n        bytes32 hook;\n    }\n\n    function deserializeNotifyShareClass(bytes memory data) internal pure returns (NotifyShareClass memory) {\n        require(messageType(data) == MessageType.NotifyShareClass, UnknownMessageType());\n        return NotifyShareClass({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            name: data.slice(25, 128).bytes128ToString(),\n            symbol: data.toBytes32(153),\n            decimals: data.toUint8(185),\n            salt: data.toBytes32(186),\n            hook: data.toBytes32(218)\n        });\n    }\n\n    function serialize(NotifyShareClass memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.NotifyShareClass,\n            t.poolId,\n            t.scId,\n            bytes(t.name).sliceZeroPadded(0, 128),\n            t.symbol,\n            t.decimals,\n            t.salt,\n            t.hook\n        );\n    }\n\n    //---------------------------------------\n    //    NotifyPricePoolPerShare\n    //---------------------------------------\n\n    struct NotifyPricePoolPerShare {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 price;\n        uint64 timestamp;\n    }\n\n    function deserializeNotifyPricePoolPerShare(bytes memory data)\n        internal\n        pure\n        returns (NotifyPricePoolPerShare memory)\n    {\n        require(messageType(data) == MessageType.NotifyPricePoolPerShare, UnknownMessageType());\n        return NotifyPricePoolPerShare({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            price: data.toUint128(25),\n            timestamp: data.toUint64(41)\n        });\n    }\n\n    function serialize(NotifyPricePoolPerShare memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.NotifyPricePoolPerShare, t.poolId, t.scId, t.price, t.timestamp);\n    }\n\n    //---------------------------------------\n    //    NotifyPricePoolPerAsset\n    //---------------------------------------\n\n    struct NotifyPricePoolPerAsset {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 assetId;\n        uint128 price;\n        uint64 timestamp;\n    }\n\n    function deserializeNotifyPricePoolPerAsset(bytes memory data)\n        internal\n        pure\n        returns (NotifyPricePoolPerAsset memory)\n    {\n        require(messageType(data) == MessageType.NotifyPricePoolPerAsset, UnknownMessageType());\n        return NotifyPricePoolPerAsset({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            assetId: data.toUint128(25),\n            price: data.toUint128(41),\n            timestamp: data.toUint64(57)\n        });\n    }\n\n    function serialize(NotifyPricePoolPerAsset memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.NotifyPricePoolPerAsset, t.poolId, t.scId, t.assetId, t.price, t.timestamp);\n    }\n\n    //---------------------------------------\n    //    NotifyShareMetadata\n    //---------------------------------------\n\n    struct NotifyShareMetadata {\n        uint64 poolId;\n        bytes16 scId;\n        string name; // Fixed to 128 bytes\n        bytes32 symbol; // utf8\n    }\n\n    function deserializeNotifyShareMetadata(bytes memory data) internal pure returns (NotifyShareMetadata memory) {\n        require(messageType(data) == MessageType.NotifyShareMetadata, UnknownMessageType());\n        return NotifyShareMetadata({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            name: data.slice(25, 128).bytes128ToString(),\n            symbol: data.toBytes32(153)\n        });\n    }\n\n    function serialize(NotifyShareMetadata memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.NotifyShareMetadata, t.poolId, t.scId, bytes(t.name).sliceZeroPadded(0, 128), t.symbol\n        );\n    }\n\n    //---------------------------------------\n    //    UpdateShareHook\n    //---------------------------------------\n\n    struct UpdateShareHook {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 hook;\n    }\n\n    function deserializeUpdateShareHook(bytes memory data) internal pure returns (UpdateShareHook memory) {\n        require(messageType(data) == MessageType.UpdateShareHook, UnknownMessageType());\n        return UpdateShareHook({poolId: data.toUint64(1), scId: data.toBytes16(9), hook: data.toBytes32(25)});\n    }\n\n    function serialize(UpdateShareHook memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.UpdateShareHook, t.poolId, t.scId, t.hook);\n    }\n\n    //---------------------------------------\n    //    TransferShares\n    //---------------------------------------\n\n    struct TransferShares {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 receiver;\n        uint128 amount;\n    }\n\n    function deserializeTransferShares(bytes memory data) internal pure returns (TransferShares memory) {\n        require(messageType(data) == MessageType.TransferShares, UnknownMessageType());\n        return TransferShares({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            receiver: data.toBytes32(25),\n            amount: data.toUint128(57)\n        });\n    }\n\n    function serialize(TransferShares memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.TransferShares, t.poolId, t.scId, t.receiver, t.amount);\n    }\n\n    //---------------------------------------\n    //    UpdateRestriction\n    //---------------------------------------\n\n    struct UpdateRestriction {\n        uint64 poolId;\n        bytes16 scId;\n        bytes payload; // As sequence of bytes\n    }\n\n    function deserializeUpdateRestriction(bytes memory data) internal pure returns (UpdateRestriction memory) {\n        require(messageType(data) == MessageType.UpdateRestriction, UnknownMessageType());\n\n        uint16 payloadLength = data.toUint16(25);\n        return UpdateRestriction({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            payload: data.slice(27, payloadLength)\n        });\n    }\n\n    function serialize(UpdateRestriction memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.UpdateRestriction, t.poolId, t.scId, uint16(t.payload.length), t.payload);\n    }\n\n    //---------------------------------------\n    //    UpdateRestrictionMember (submsg)\n    //---------------------------------------\n\n    struct UpdateRestrictionMember {\n        bytes32 user;\n        uint64 validUntil;\n    }\n\n    function deserializeUpdateRestrictionMember(bytes memory data)\n        internal\n        pure\n        returns (UpdateRestrictionMember memory)\n    {\n        require(updateRestrictionType(data) == UpdateRestrictionType.Member, UnknownMessageType());\n\n        return UpdateRestrictionMember({user: data.toBytes32(1), validUntil: data.toUint64(33)});\n    }\n\n    function serialize(UpdateRestrictionMember memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateRestrictionType.Member, t.user, t.validUntil);\n    }\n\n    //---------------------------------------\n    //    UpdateRestrictionFreeze (submsg)\n    //---------------------------------------\n\n    struct UpdateRestrictionFreeze {\n        bytes32 user;\n    }\n\n    function deserializeUpdateRestrictionFreeze(bytes memory data)\n        internal\n        pure\n        returns (UpdateRestrictionFreeze memory)\n    {\n        require(updateRestrictionType(data) == UpdateRestrictionType.Freeze, UnknownMessageType());\n\n        return UpdateRestrictionFreeze({user: data.toBytes32(1)});\n    }\n\n    function serialize(UpdateRestrictionFreeze memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateRestrictionType.Freeze, t.user);\n    }\n\n    //---------------------------------------\n    //    UpdateRestrictionUnfreeze (submsg)\n    //---------------------------------------\n\n    struct UpdateRestrictionUnfreeze {\n        bytes32 user;\n    }\n\n    function deserializeUpdateRestrictionUnfreeze(bytes memory data)\n        internal\n        pure\n        returns (UpdateRestrictionUnfreeze memory)\n    {\n        require(updateRestrictionType(data) == UpdateRestrictionType.Unfreeze, UnknownMessageType());\n\n        return UpdateRestrictionUnfreeze({user: data.toBytes32(1)});\n    }\n\n    function serialize(UpdateRestrictionUnfreeze memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateRestrictionType.Unfreeze, t.user);\n    }\n\n    //---------------------------------------\n    //    UpdateContract\n    //---------------------------------------\n\n    struct UpdateContract {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 target;\n        bytes payload; // As sequence of bytes\n    }\n\n    function deserializeUpdateContract(bytes memory data) internal pure returns (UpdateContract memory) {\n        require(messageType(data) == MessageType.UpdateContract, UnknownMessageType());\n        uint16 payloadLength = data.toUint16(57);\n        return UpdateContract({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            target: data.toBytes32(25),\n            payload: data.slice(59, payloadLength)\n        });\n    }\n\n    function serialize(UpdateContract memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.UpdateContract, t.poolId, t.scId, t.target, uint16(t.payload.length), t.payload\n        );\n    }\n\n    //---------------------------------------\n    //   UpdateContract.VaultUpdate (submsg)\n    //---------------------------------------\n\n    struct UpdateContractVaultUpdate {\n        bytes32 vaultOrFactory;\n        uint128 assetId;\n        uint8 kind;\n    }\n\n    function deserializeUpdateContractVaultUpdate(bytes memory data)\n        internal\n        pure\n        returns (UpdateContractVaultUpdate memory)\n    {\n        require(updateContractType(data) == UpdateContractType.VaultUpdate, UnknownMessageType());\n\n        return UpdateContractVaultUpdate({\n            vaultOrFactory: data.toBytes32(1),\n            assetId: data.toUint128(33),\n            kind: data.toUint8(49)\n        });\n    }\n\n    function serialize(UpdateContractVaultUpdate memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateContractType.VaultUpdate, t.vaultOrFactory, t.assetId, t.kind);\n    }\n\n    //---------------------------------------\n    //   UpdateContract.UpdateManager (submsg)\n    //---------------------------------------\n\n    struct UpdateContractUpdateManager {\n        bytes32 who;\n        bool canManage;\n    }\n\n    function deserializeUpdateContractUpdateManager(bytes memory data)\n        internal\n        pure\n        returns (UpdateContractUpdateManager memory)\n    {\n        require(updateContractType(data) == UpdateContractType.UpdateManager, UnknownMessageType());\n\n        return UpdateContractUpdateManager({who: data.toBytes32(1), canManage: data.toBool(33)});\n    }\n\n    function serialize(UpdateContractUpdateManager memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateContractType.UpdateManager, t.who, t.canManage);\n    }\n\n    //---------------------------------------\n    //   UpdateContract.MaxAssetPriceAge (submsg)\n    //---------------------------------------\n\n    struct UpdateContractMaxAssetPriceAge {\n        uint128 assetId;\n        uint64 maxPriceAge;\n    }\n\n    function deserializeUpdateContractMaxAssetPriceAge(bytes memory data)\n        internal\n        pure\n        returns (UpdateContractMaxAssetPriceAge memory)\n    {\n        require(updateContractType(data) == UpdateContractType.MaxAssetPriceAge, UnknownMessageType());\n\n        return UpdateContractMaxAssetPriceAge({assetId: data.toUint128(1), maxPriceAge: data.toUint64(17)});\n    }\n\n    function serialize(UpdateContractMaxAssetPriceAge memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateContractType.MaxAssetPriceAge, t.assetId, t.maxPriceAge);\n    }\n\n    //---------------------------------------\n    //   UpdateContract.MaxSharePriceAge (submsg)\n    //---------------------------------------\n\n    struct UpdateContractMaxSharePriceAge {\n        uint64 maxPriceAge;\n    }\n\n    function deserializeUpdateContractMaxSharePriceAge(bytes memory data)\n        internal\n        pure\n        returns (UpdateContractMaxSharePriceAge memory)\n    {\n        require(updateContractType(data) == UpdateContractType.MaxSharePriceAge, UnknownMessageType());\n\n        return UpdateContractMaxSharePriceAge({maxPriceAge: data.toUint64(1)});\n    }\n\n    function serialize(UpdateContractMaxSharePriceAge memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateContractType.MaxSharePriceAge, t.maxPriceAge);\n    }\n\n    //---------------------------------------\n    //   UpdateContract.Valuation (submsg)\n    //---------------------------------------\n\n    struct UpdateContractValuation {\n        bytes32 valuation;\n    }\n\n    function deserializeUpdateContractValuation(bytes memory data)\n        internal\n        pure\n        returns (UpdateContractValuation memory)\n    {\n        require(updateContractType(data) == UpdateContractType.Valuation, UnknownMessageType());\n\n        return UpdateContractValuation({valuation: data.toBytes32(1)});\n    }\n\n    function serialize(UpdateContractValuation memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateContractType.Valuation, t.valuation);\n    }\n\n    //---------------------------------------\n    //   UpdateContract.SyncDepositMaxReserve (submsg)\n    //---------------------------------------\n\n    struct UpdateContractSyncDepositMaxReserve {\n        uint128 assetId;\n        uint128 maxReserve;\n    }\n\n    function deserializeUpdateContractSyncDepositMaxReserve(bytes memory data)\n        internal\n        pure\n        returns (UpdateContractSyncDepositMaxReserve memory)\n    {\n        require(updateContractType(data) == UpdateContractType.SyncDepositMaxReserve, UnknownMessageType());\n\n        return UpdateContractSyncDepositMaxReserve({assetId: data.toUint128(1), maxReserve: data.toUint128(17)});\n    }\n\n    function serialize(UpdateContractSyncDepositMaxReserve memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(UpdateContractType.SyncDepositMaxReserve, t.assetId, t.maxReserve);\n    }\n\n    //---------------------------------------\n    //    DepositRequest\n    //---------------------------------------\n\n    struct DepositRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n        uint128 amount;\n    }\n\n    function deserializeDepositRequest(bytes memory data) internal pure returns (DepositRequest memory) {\n        require(messageType(data) == MessageType.DepositRequest, UnknownMessageType());\n        return DepositRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57),\n            amount: data.toUint128(73)\n        });\n    }\n\n    function serialize(DepositRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.DepositRequest, t.poolId, t.scId, t.investor, t.assetId, t.amount);\n    }\n\n    //---------------------------------------\n    //    RedeemRequest\n    //---------------------------------------\n\n    struct RedeemRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n        uint128 amount;\n    }\n\n    function deserializeRedeemRequest(bytes memory data) internal pure returns (RedeemRequest memory) {\n        require(messageType(data) == MessageType.RedeemRequest, UnknownMessageType());\n        return RedeemRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57),\n            amount: data.toUint128(73)\n        });\n    }\n\n    function serialize(RedeemRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.RedeemRequest, t.poolId, t.scId, t.investor, t.assetId, t.amount);\n    }\n\n    //---------------------------------------\n    //    CancelDepositRequest\n    //---------------------------------------\n\n    struct CancelDepositRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n    }\n\n    function deserializeCancelDepositRequest(bytes memory data) internal pure returns (CancelDepositRequest memory) {\n        require(messageType(data) == MessageType.CancelDepositRequest, UnknownMessageType());\n        return CancelDepositRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57)\n        });\n    }\n\n    function serialize(CancelDepositRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.CancelDepositRequest, t.poolId, t.scId, t.investor, t.assetId);\n    }\n\n    //---------------------------------------\n    //    CancelRedeemRequest\n    //---------------------------------------\n\n    struct CancelRedeemRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n    }\n\n    function deserializeCancelRedeemRequest(bytes memory data) internal pure returns (CancelRedeemRequest memory) {\n        require(messageType(data) == MessageType.CancelRedeemRequest, UnknownMessageType());\n        return CancelRedeemRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57)\n        });\n    }\n\n    function serialize(CancelRedeemRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.CancelRedeemRequest, t.poolId, t.scId, t.investor, t.assetId);\n    }\n\n    //---------------------------------------\n    //    FulfilledDepositRequest\n    //---------------------------------------\n\n    struct FulfilledDepositRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n        uint128 assetAmount;\n        uint128 shareAmount;\n    }\n\n    function deserializeFulfilledDepositRequest(bytes memory data)\n        internal\n        pure\n        returns (FulfilledDepositRequest memory)\n    {\n        require(messageType(data) == MessageType.FulfilledDepositRequest, UnknownMessageType());\n        return FulfilledDepositRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57),\n            assetAmount: data.toUint128(73),\n            shareAmount: data.toUint128(89)\n        });\n    }\n\n    function serialize(FulfilledDepositRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.FulfilledDepositRequest, t.poolId, t.scId, t.investor, t.assetId, t.assetAmount, t.shareAmount\n        );\n    }\n\n    //---------------------------------------\n    //    FulfilledRedeemRequest\n    //---------------------------------------\n\n    struct FulfilledRedeemRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n        uint128 assetAmount;\n        uint128 shareAmount;\n    }\n\n    function deserializeFulfilledRedeemRequest(bytes memory data)\n        internal\n        pure\n        returns (FulfilledRedeemRequest memory)\n    {\n        require(messageType(data) == MessageType.FulfilledRedeemRequest, UnknownMessageType());\n        return FulfilledRedeemRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57),\n            assetAmount: data.toUint128(73),\n            shareAmount: data.toUint128(89)\n        });\n    }\n\n    function serialize(FulfilledRedeemRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.FulfilledRedeemRequest, t.poolId, t.scId, t.investor, t.assetId, t.assetAmount, t.shareAmount\n        );\n    }\n\n    //---------------------------------------\n    //    FulfilledCancelDepositRequest\n    //---------------------------------------\n\n    struct FulfilledCancelDepositRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n        uint128 cancelledAmount;\n    }\n\n    function deserializeFulfilledCancelDepositRequest(bytes memory data)\n        internal\n        pure\n        returns (FulfilledCancelDepositRequest memory)\n    {\n        require(messageType(data) == MessageType.FulfilledCancelDepositRequest, UnknownMessageType());\n        return FulfilledCancelDepositRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57),\n            cancelledAmount: data.toUint128(73)\n        });\n    }\n\n    function serialize(FulfilledCancelDepositRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.FulfilledCancelDepositRequest, t.poolId, t.scId, t.investor, t.assetId, t.cancelledAmount\n        );\n    }\n\n    //---------------------------------------\n    //    FulfilledCancelRedeemRequest\n    //---------------------------------------\n\n    struct FulfilledCancelRedeemRequest {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 investor;\n        uint128 assetId;\n        uint128 cancelledShares;\n    }\n\n    function deserializeFulfilledCancelRedeemRequest(bytes memory data)\n        internal\n        pure\n        returns (FulfilledCancelRedeemRequest memory)\n    {\n        require(messageType(data) == MessageType.FulfilledCancelRedeemRequest, UnknownMessageType());\n        return FulfilledCancelRedeemRequest({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            investor: data.toBytes32(25),\n            assetId: data.toUint128(57),\n            cancelledShares: data.toUint128(73)\n        });\n    }\n\n    function serialize(FulfilledCancelRedeemRequest memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.FulfilledCancelRedeemRequest, t.poolId, t.scId, t.investor, t.assetId, t.cancelledShares\n        );\n    }\n\n    //---------------------------------------\n    //    UpdateHoldingAmount\n    //---------------------------------------\n\n    struct UpdateHoldingAmount {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 assetId;\n        bytes32 who;\n        uint128 amount;\n        uint128 pricePerUnit;\n        uint64 timestamp;\n        bool isIncrease; // Signals whether this is an increase or a decrease\n    }\n\n    function deserializeUpdateHoldingAmount(bytes memory data) internal pure returns (UpdateHoldingAmount memory h) {\n        require(messageType(data) == MessageType.UpdateHoldingAmount, \"UnknownMessageType\");\n\n        return UpdateHoldingAmount({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            assetId: data.toUint128(25),\n            who: data.toBytes32(41),\n            amount: data.toUint128(73),\n            pricePerUnit: data.toUint128(89),\n            timestamp: data.toUint64(105),\n            isIncrease: data.toBool(113)\n        });\n    }\n\n    function serialize(UpdateHoldingAmount memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.UpdateHoldingAmount,\n            t.poolId,\n            t.scId,\n            t.assetId,\n            t.who,\n            t.amount,\n            t.pricePerUnit,\n            t.timestamp,\n            t.isIncrease\n        );\n    }\n\n    //---------------------------------------\n    //    UpdateShares\n    //---------------------------------------\n\n    struct UpdateShares {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 shares;\n        uint64 timestamp;\n        bool isIssuance;\n    }\n\n    function deserializeUpdateShares(bytes memory data) internal pure returns (UpdateShares memory) {\n        require(messageType(data) == MessageType.UpdateShares, UnknownMessageType());\n\n        return UpdateShares({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            shares: data.toUint128(25),\n            timestamp: data.toUint64(41),\n            isIssuance: data.toBool(49)\n        });\n    }\n\n    function serialize(UpdateShares memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.UpdateShares, t.poolId, t.scId, t.shares, t.timestamp, t.isIssuance);\n    }\n\n    //---------------------------------------\n    //    ApprovedDeposits\n    //---------------------------------------\n\n    struct ApprovedDeposits {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 assetId;\n        uint128 assetAmount;\n        uint128 pricePoolPerAsset;\n    }\n\n    function deserializeApprovedDeposits(bytes memory data) internal pure returns (ApprovedDeposits memory) {\n        require(messageType(data) == MessageType.ApprovedDeposits, UnknownMessageType());\n\n        return ApprovedDeposits({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            assetId: data.toUint128(25),\n            assetAmount: data.toUint128(41),\n            pricePoolPerAsset: data.toUint128(57)\n        });\n    }\n\n    function serialize(ApprovedDeposits memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.ApprovedDeposits, t.poolId, t.scId, t.assetId, t.assetAmount, t.pricePoolPerAsset\n        );\n    }\n\n    //---------------------------------------\n    //    IssuedShares\n    //---------------------------------------\n\n    struct IssuedShares {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 shareAmount;\n        uint128 pricePoolPerShare;\n    }\n\n    function deserializeIssuedShares(bytes memory data) internal pure returns (IssuedShares memory) {\n        require(messageType(data) == MessageType.IssuedShares, UnknownMessageType());\n\n        return IssuedShares({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            shareAmount: data.toUint128(25),\n            pricePoolPerShare: data.toUint128(41)\n        });\n    }\n\n    function serialize(IssuedShares memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.IssuedShares, t.poolId, t.scId, t.shareAmount, t.pricePoolPerShare);\n    }\n\n    //---------------------------------------\n    //    RevokedShares\n    //---------------------------------------\n\n    struct RevokedShares {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 assetId;\n        uint128 shareAmount;\n        uint128 pricePoolPerShare;\n        uint128 assetAmount;\n    }\n\n    function deserializeRevokedShares(bytes memory data) internal pure returns (RevokedShares memory) {\n        require(messageType(data) == MessageType.RevokedShares, UnknownMessageType());\n\n        return RevokedShares({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            assetId: data.toUint128(25),\n            assetAmount: data.toUint128(41),\n            shareAmount: data.toUint128(57),\n            pricePoolPerShare: data.toUint128(73)\n        });\n    }\n\n    function serialize(RevokedShares memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            MessageType.RevokedShares, t.poolId, t.scId, t.assetId, t.assetAmount, t.shareAmount, t.pricePoolPerShare\n        );\n    }\n\n    //---------------------------------------\n    //    TriggerIssueShares\n    //---------------------------------------\n\n    struct TriggerIssueShares {\n        uint64 poolId;\n        bytes16 scId;\n        bytes32 who;\n        uint128 shares;\n    }\n\n    function deserializeTriggerIssueShares(bytes memory data) internal pure returns (TriggerIssueShares memory) {\n        require(messageType(data) == MessageType.TriggerIssueShares, UnknownMessageType());\n\n        return TriggerIssueShares({\n            poolId: data.toUint64(1),\n            scId: data.toBytes16(9),\n            who: data.toBytes32(25),\n            shares: data.toUint128(57)\n        });\n    }\n\n    function serialize(TriggerIssueShares memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.TriggerIssueShares, t.poolId, t.scId, t.who, t.shares);\n    }\n\n    //---------------------------------------\n    //    TriggerSubmitQueuedShares\n    //---------------------------------------\n\n    struct TriggerSubmitQueuedShares {\n        uint64 poolId;\n        bytes16 scId;\n    }\n\n    function deserializeTriggerSubmitQueuedShares(bytes memory data)\n        internal\n        pure\n        returns (TriggerSubmitQueuedShares memory)\n    {\n        require(messageType(data) == MessageType.TriggerSubmitQueuedShares, UnknownMessageType());\n        return TriggerSubmitQueuedShares({poolId: data.toUint64(1), scId: data.toBytes16(9)});\n    }\n\n    function serialize(TriggerSubmitQueuedShares memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.TriggerSubmitQueuedShares, t.poolId, t.scId);\n    }\n\n    //---------------------------------------\n    //    TriggerSubmitQueuedAssets\n    //---------------------------------------\n\n    struct TriggerSubmitQueuedAssets {\n        uint64 poolId;\n        bytes16 scId;\n        uint128 assetId;\n    }\n\n    function deserializeTriggerSubmitQueuedAssets(bytes memory data)\n        internal\n        pure\n        returns (TriggerSubmitQueuedAssets memory)\n    {\n        require(messageType(data) == MessageType.TriggerSubmitQueuedAssets, UnknownMessageType());\n        return\n            TriggerSubmitQueuedAssets({poolId: data.toUint64(1), scId: data.toBytes16(9), assetId: data.toUint128(25)});\n    }\n\n    function serialize(TriggerSubmitQueuedAssets memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.TriggerSubmitQueuedAssets, t.poolId, t.scId, t.assetId);\n    }\n\n    //---------------------------------------\n    //    SetQueue\n    //---------------------------------------\n\n    struct SetQueue {\n        uint64 poolId;\n        bytes16 scId;\n        bool enabled;\n    }\n\n    function deserializeSetQueue(bytes memory data) internal pure returns (SetQueue memory) {\n        require(messageType(data) == MessageType.SetQueue, UnknownMessageType());\n        return SetQueue({poolId: data.toUint64(1), scId: data.toBytes16(9), enabled: data.toBool(25)});\n    }\n\n    function serialize(SetQueue memory t) internal pure returns (bytes memory) {\n        return abi.encodePacked(MessageType.SetQueue, t.poolId, t.scId, t.enabled);\n    }\n}\n"
    },
    "src/common/libraries/MessageProofLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\n\nlibrary MessageProofLib {\n    using BytesLib for bytes;\n\n    uint8 constant MESSAGE_PROOF_ID = 1;\n\n    error UnknownMessageProofType();\n\n    function deserializeMessageProof(bytes memory data) internal pure returns (bytes32) {\n        require(data.toUint8(0) == MESSAGE_PROOF_ID, UnknownMessageProofType());\n        return data.toBytes32(1);\n    }\n\n    function serializeMessageProof(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(MESSAGE_PROOF_ID, hash);\n    }\n}\n"
    },
    "src/common/libraries/PricingLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IERC20Metadata} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC6909MetadataExt} from \"src/misc/interfaces/IERC6909.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nlibrary PricingLib {\n    using MathLib for *;\n\n    /// @dev Prices are fixed-point integers with 18 decimals\n    uint8 internal constant PRICE_DECIMALS = 18;\n\n    /// -----------------------------------------------------\n    ///  View Methods\n    /// -----------------------------------------------------\n\n    /// @dev Converts the given asset amount to share amount. Returned value is in share decimals.\n    ///\n    /// @dev NOTE: MUST ONLY be used in AsyncRequestManager which rely on priceAssetPerShare that is derived from\n    /// Fulfilled*\n    /// message amounts. Any other codepath must use the variant with pricePoolPerAsset and pricePoolPerShare\n    function assetToShareAmount(\n        address shareToken,\n        address asset,\n        uint256 tokenId,\n        uint128 assetAmount,\n        D18 priceAssetPerShare_,\n        MathLib.Rounding rounding\n    ) internal view returns (uint128 shares) {\n        if (assetAmount == 0 || priceAssetPerShare_.raw() == 0) {\n            return 0;\n        }\n\n        uint8 assetDecimals = getAssetDecimals(asset, tokenId);\n        uint8 shareDecimals = IERC20Metadata(shareToken).decimals();\n\n        return PricingLib.convertWithReciprocalPrice(\n            assetAmount, assetDecimals, shareDecimals, priceAssetPerShare_, rounding\n        ).toUint128();\n    }\n\n    /// @dev Converts the given asset amount to share amount. Returned value is in share decimals.\n    function assetToShareAmount(\n        address shareToken,\n        address asset,\n        uint256 tokenId,\n        uint128 assetAmount,\n        D18 pricePoolPerAsset,\n        D18 pricePoolPerShare,\n        MathLib.Rounding rounding\n    ) internal view returns (uint128 shares) {\n        if (assetAmount == 0 || pricePoolPerShare.raw() == 0 || pricePoolPerAsset.raw() == 0) {\n            return 0;\n        }\n\n        uint8 assetDecimals = getAssetDecimals(asset, tokenId);\n        uint8 shareDecimals = IERC20Metadata(shareToken).decimals();\n\n        return PricingLib.assetToShareAmount(\n            assetAmount, assetDecimals, shareDecimals, pricePoolPerAsset, pricePoolPerShare, rounding\n        ).toUint128();\n    }\n\n    /// @dev Converts the given share amount to asset amount. Returned value is in share decimals.\n    ///\n    /// @dev NOTE: MUST ONLY be used in AsyncRequestManager which rely on priceAssetPerShare that is derived from\n    /// Fulfilled*\n    /// message amounts. Any other codepath must use the variant with pricePoolPerAsset and pricePoolPerShare\n    function shareToAssetAmount(\n        address shareToken,\n        uint128 shareAmount,\n        address asset,\n        uint256 tokenId,\n        D18 priceAssetPerShare_,\n        MathLib.Rounding rounding\n    ) internal view returns (uint128 shares) {\n        if (shareAmount == 0 || priceAssetPerShare_.raw() == 0) {\n            return 0;\n        }\n\n        uint8 assetDecimals = getAssetDecimals(asset, tokenId);\n        uint8 shareDecimals = IERC20Metadata(shareToken).decimals();\n\n        return PricingLib.convertWithPrice(shareAmount, shareDecimals, assetDecimals, priceAssetPerShare_, rounding)\n            .toUint128();\n    }\n\n    /// @dev Converts the given share amount to asset amount. Returned value is in share decimals.\n    function shareToAssetAmount(\n        address shareToken,\n        uint128 shareAmount,\n        address asset,\n        uint256 tokenId,\n        D18 pricePoolPerAsset,\n        D18 pricePoolPerShare,\n        MathLib.Rounding rounding\n    ) internal view returns (uint128 shares) {\n        if (shareAmount == 0 || pricePoolPerShare.raw() == 0 || pricePoolPerAsset.raw() == 0) {\n            return 0;\n        }\n\n        uint8 assetDecimals = getAssetDecimals(asset, tokenId);\n        uint8 shareDecimals = IERC20Metadata(shareToken).decimals();\n\n        return PricingLib.shareToAssetAmount(\n            shareAmount, shareDecimals, assetDecimals, pricePoolPerAsset, pricePoolPerShare, rounding\n        ).toUint128();\n    }\n\n    /// @dev Calculates the asset price per share returns the value in price decimals\n    /// Denominated in ASSET_UNIT/SHARE_UNIT\n    function calculatePriceAssetPerShare(\n        address shareToken,\n        uint128 shares,\n        address asset,\n        uint256 tokenId,\n        uint128 assets,\n        MathLib.Rounding rounding\n    ) internal view returns (uint256 priceAssetPerShare_) {\n        if (assets == 0 || shares == 0) {\n            return 0;\n        }\n\n        uint8 assetDecimals = getAssetDecimals(asset, tokenId);\n        uint8 shareDecimals = IERC20Metadata(shareToken).decimals();\n\n        // NOTE: More precise than d18(assets * 10 ** assetDecimals, shares * 10 ** shareDecimals)\n        return toPriceDecimals(assets, assetDecimals).mulDiv(\n            10 ** PRICE_DECIMALS, toPriceDecimals(shares, shareDecimals), rounding\n        );\n    }\n\n    /// -----------------------------------------------------\n    ///  Pure Methods\n    /// -----------------------------------------------------\n\n    /// @dev Converts an amount using decimals and price with implicit rounding down\n    function convertWithPrice(uint256 baseAmount, uint8 baseDecimals, uint8 quoteDecimals, D18 priceQuotePerBase)\n        internal\n        pure\n        returns (uint256 quoteAmount)\n    {\n        return convertWithPrice(baseAmount, baseDecimals, quoteDecimals, priceQuotePerBase, MathLib.Rounding.Down);\n    }\n\n    /// @dev Converts an amount using decimals and price with explicit rounding.\n    function convertWithPrice(\n        uint256 baseAmount,\n        uint8 baseDecimals,\n        uint8 quoteDecimals,\n        D18 priceQuotePerBase,\n        MathLib.Rounding rounding\n    ) internal pure returns (uint256 quoteAmount) {\n        if (baseDecimals == quoteDecimals) {\n            return priceQuotePerBase.mulUint256(baseAmount, rounding);\n        }\n\n        return\n            priceQuotePerBase.mulUint256(MathLib.mulDiv(baseAmount, 10 ** quoteDecimals, 10 ** baseDecimals), rounding);\n    }\n\n    /// @dev Converts an amount using decimals and reciprocal price.\n    ///\n    /// NOTE: More precise than convertWithPrice(,,,price.reciprocal,)\n    function convertWithReciprocalPrice(\n        uint256 baseAmount,\n        uint8 baseDecimals,\n        uint8 quoteDecimals,\n        D18 priceBasePerQuote,\n        MathLib.Rounding rounding\n    ) internal pure returns (uint256 quoteAmount) {\n        if (baseDecimals == quoteDecimals) {\n            return priceBasePerQuote.reciprocalMulUint256(baseAmount, rounding);\n        }\n\n        return priceBasePerQuote.reciprocalMulUint256(\n            MathLib.mulDiv(baseAmount, 10 ** quoteDecimals, 10 ** baseDecimals), rounding\n        );\n    }\n\n    /// @dev Converts asset amount to share amount.\n    function assetToShareAmount(\n        uint256 assetAmount,\n        uint8 assetDecimals,\n        uint8 shareDecimals,\n        D18 pricePoolPerAsset,\n        D18 pricePoolPerShare,\n        MathLib.Rounding rounding\n    ) internal pure returns (uint256 shareAmount) {\n        return pricePoolPerShare.reciprocalMulUint256(\n            convertWithPrice(assetAmount, assetDecimals, shareDecimals, pricePoolPerAsset, MathLib.Rounding.Down),\n            rounding\n        );\n    }\n\n    /// @dev Converts share amount to asset asset amount.\n    function shareToAssetAmount(\n        uint256 shareAmount,\n        uint8 shareDecimals,\n        uint8 assetDecimals,\n        D18 pricePoolPerAsset,\n        D18 pricePoolPerShare,\n        MathLib.Rounding rounding\n    ) internal pure returns (uint256 assetAmount) {\n        return convertWithReciprocalPrice(\n            pricePoolPerShare.mulUint256(shareAmount, MathLib.Rounding.Down),\n            shareDecimals,\n            assetDecimals,\n            pricePoolPerAsset,\n            rounding\n        );\n    }\n\n    /// @dev Converts pool amount to asset amount.\n    function poolToAssetAmount(\n        uint256 poolAmount,\n        uint8 poolDecimals,\n        uint8 assetDecimals,\n        D18 pricePoolPerAsset,\n        MathLib.Rounding rounding\n    ) internal pure returns (uint256 assetAmount) {\n        return convertWithReciprocalPrice(poolAmount, poolDecimals, assetDecimals, pricePoolPerAsset, rounding);\n    }\n\n    /// @dev Returns the asset price per share denominated in ASSET_UNIT/SHARE_UNIT\n    ///\n    /// @dev NOTE: Should never be used for calculating amounts due to precision loss. Instead, please refer to\n    /// conversion relying on pricePoolPerShare and pricePoolPerAsset.\n    function priceAssetPerShare(D18 pricePoolPerShare, D18 pricePoolPerAsset)\n        internal\n        pure\n        returns (D18 priceAssetPerShare_)\n    {\n        return pricePoolPerShare / pricePoolPerAsset;\n    }\n\n    /// -----------------------------------------------------\n    ///  Private Methods\n    /// -----------------------------------------------------\n\n    /// @dev Returns the asset decimals\n    function getAssetDecimals(address asset, uint256 tokenId) private view returns (uint8 assetDecimals) {\n        return tokenId == 0 ? IERC20Metadata(asset).decimals() : IERC6909MetadataExt(asset).decimals(tokenId);\n    }\n\n    /// @dev When converting assets to shares using the price, all values are normalized to PRICE_DECIMALS\n    /// @dev NOTE: We require all assets to have 2 <= decimals <= 18, see `PoolManager.registerAsset`\n    function toPriceDecimals(uint128 _value, uint8 decimals) private pure returns (uint256) {\n        if (PRICE_DECIMALS == decimals) return uint256(_value);\n        return uint256(_value) * 10 ** (PRICE_DECIMALS - decimals);\n    }\n\n    /// @dev Converts decimals of the value from the price decimals back to the intended decimals\n    /// @dev NOTE: We require all assets to have 2 <= decimals <= 18, see `PoolManager.registerAsset`\n    function fromPriceDecimals(uint256 _value, uint8 decimals) private pure returns (uint128) {\n        if (PRICE_DECIMALS == decimals) return _value.toUint128();\n        return (_value / 10 ** (PRICE_DECIMALS - decimals)).toUint128();\n    }\n}\n"
    },
    "src/common/types/AccountId.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\ntype AccountId is uint32;\n\nfunction raw(AccountId accountId_) pure returns (uint32) {\n    return AccountId.unwrap(accountId_);\n}\n\nusing {raw} for AccountId global;\n"
    },
    "src/common/types/AssetId.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @dev Composite Id of the centrifugeId (uint16) where the asset resides\n///      and a local counter (uint64) that is part of the contract that registers the asset.\ntype AssetId is uint128;\n\nfunction isNull(AssetId assetId) pure returns (bool) {\n    return AssetId.unwrap(assetId) == 0;\n}\n\nfunction addr(AssetId assetId) pure returns (address) {\n    return address(uint160(AssetId.unwrap(assetId)));\n}\n\nfunction raw(AssetId assetId) pure returns (uint128) {\n    return AssetId.unwrap(assetId);\n}\n\nfunction centrifugeId(AssetId assetId) pure returns (uint16) {\n    return uint16(AssetId.unwrap(assetId) >> 112);\n}\n\nfunction newAssetId(uint16 centrifugeId_, uint64 counter) pure returns (AssetId) {\n    return AssetId.wrap((uint128(centrifugeId_) << 112) + counter);\n}\n\nfunction newAssetId(uint32 isoCode) pure returns (AssetId) {\n    return AssetId.wrap(isoCode);\n}\n\nfunction eq(AssetId a, AssetId b) pure returns (bool) {\n    return a.raw() == b.raw();\n}\n\nusing {isNull, addr, raw, centrifugeId, eq} for AssetId global;\n"
    },
    "src/common/types/PoolId.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\n\nusing MathLib for uint256;\n\ntype PoolId is uint64;\n\nfunction centrifugeId(PoolId poolId) pure returns (uint16) {\n    return uint16(PoolId.unwrap(poolId) >> 48);\n}\n\nfunction newPoolId(uint16 centrifugeId_, uint48 localPoolId) pure returns (PoolId) {\n    return PoolId.wrap((uint64(centrifugeId_) << 48) | uint64(localPoolId));\n}\n\nfunction isNull(PoolId poolId) pure returns (bool) {\n    return PoolId.unwrap(poolId) == 0;\n}\n\nfunction raw(PoolId poolId) pure returns (uint64) {\n    return PoolId.unwrap(poolId);\n}\n\nusing {centrifugeId, isNull, raw} for PoolId global;\n"
    },
    "src/common/types/ShareClassId.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\ntype ShareClassId is bytes16;\n\nfunction isNull(ShareClassId scId) pure returns (bool) {\n    return ShareClassId.unwrap(scId) == 0;\n}\n\nfunction equals(ShareClassId left, ShareClassId right) pure returns (bool) {\n    return ShareClassId.unwrap(left) == ShareClassId.unwrap(right);\n}\n\nfunction raw(ShareClassId scId) pure returns (bytes16) {\n    return ShareClassId.unwrap(scId);\n}\n\nfunction newShareClassId(PoolId poolId, uint32 index) pure returns (ShareClassId scId) {\n    return ShareClassId.wrap(bytes16((uint128(PoolId.unwrap(poolId)) << 64) + index));\n}\n\nusing {isNull, raw, equals as ==} for ShareClassId global;\n"
    },
    "src/hooks/FreezeOnly.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {BitmapLib} from \"src/misc/libraries/BitmapLib.sol\";\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {UpdateRestrictionType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\n\nimport {IHook, HookData} from \"src/common/interfaces/IHook.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\nimport {IFreezable} from \"src/hooks/interfaces/IFreezable.sol\";\n\n/// @title  Freeze Only\n/// @notice Hook implementation that:\n///         * Allows any non-frozen account to receive tokens and transfer tokens\n///         * Supports freezing accounts which blocks transfers both to and from them\n///         * Allows authTransferFrom calls\n///\n/// @dev    The last bit of hookData is used to denote whether the account is frozen.\ncontract FreezeOnly is Auth, IFreezable, IHook {\n    using BitmapLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using CastLib for bytes32;\n\n    /// @dev Least significant bit\n    uint8 public constant FREEZE_BIT = 0;\n\n    IRoot public immutable root;\n\n    constructor(address root_, address deployer) Auth(deployer) {\n        root = IRoot(root_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Callback from share token\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHook\n    function onERC20Transfer(address from, address to, uint256 value, HookData calldata hookData)\n        external\n        virtual\n        returns (bytes4)\n    {\n        require(checkERC20Transfer(from, to, value, hookData), TransferBlocked());\n        return IHook.onERC20Transfer.selector;\n    }\n\n    /// @inheritdoc IHook\n    function onERC20AuthTransfer(\n        address, /* sender */\n        address, /* from */\n        address, /* to */\n        uint256, /* value */\n        HookData calldata /* hookData */\n    ) external pure returns (bytes4) {\n        return IHook.onERC20AuthTransfer.selector;\n    }\n\n    /// @inheritdoc IHook\n    function checkERC20Transfer(address from, address, /* to */ uint256, /* value */ HookData calldata hookData)\n        public\n        view\n        returns (bool)\n    {\n        uint128 fromHookData = uint128(hookData.from);\n        if (fromHookData.getBit(FREEZE_BIT) == true && !root.endorsed(from)) {\n            // Source is frozen and not endorsed\n            return false;\n        }\n\n        uint128 toHookData = uint128(hookData.to);\n        if (toHookData.getBit(FREEZE_BIT) == true) {\n            // Destination is frozen\n            return false;\n        }\n\n        return true;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Restriction updates\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHook\n    function updateRestriction(address token, bytes memory payload) external auth {\n        UpdateRestrictionType updateId = payload.updateRestrictionType();\n\n        if (updateId == UpdateRestrictionType.Freeze) {\n            MessageLib.UpdateRestrictionFreeze memory m = payload.deserializeUpdateRestrictionFreeze();\n            freeze(token, m.user.toAddress());\n        } else if (updateId == UpdateRestrictionType.Unfreeze) {\n            MessageLib.UpdateRestrictionUnfreeze memory m = payload.deserializeUpdateRestrictionUnfreeze();\n            unfreeze(token, m.user.toAddress());\n        } else {\n            revert InvalidUpdate();\n        }\n    }\n\n    /// @inheritdoc IFreezable\n    function freeze(address token, address user) public auth {\n        require(user != address(0), CannotFreezeZeroAddress());\n        require(!root.endorsed(user), EndorsedUserCannotBeFrozen());\n\n        uint128 hookData = uint128(IShareToken(token).hookDataOf(user));\n        IShareToken(token).setHookData(user, bytes16(hookData.setBit(FREEZE_BIT, true)));\n\n        emit Freeze(token, user);\n    }\n\n    /// @inheritdoc IFreezable\n    function unfreeze(address token, address user) public auth {\n        uint128 hookData = uint128(IShareToken(token).hookDataOf(user));\n        IShareToken(token).setHookData(user, bytes16(hookData.setBit(FREEZE_BIT, false)));\n\n        emit Unfreeze(token, user);\n    }\n\n    /// @inheritdoc IFreezable\n    function isFrozen(address token, address user) public view returns (bool) {\n        return uint128(IShareToken(token).hookDataOf(user)).getBit(FREEZE_BIT);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(IHook).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "src/hooks/FullRestrictions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BitmapLib} from \"src/misc/libraries/BitmapLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {UpdateRestrictionType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\n\nimport {IHook, HookData, ESCROW_HOOK_ID} from \"src/common/interfaces/IHook.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\nimport {IFreezable} from \"src/hooks/interfaces/IFreezable.sol\";\nimport {IMemberlist} from \"src/hooks/interfaces/IMemberlist.sol\";\n\n/// @title  Full Restrictions\n/// @notice Hook implementation that:\n///         * Requires adding accounts to the memberlist before they can receive tokens\n///         * Supports freezing accounts which blocks transfers both to and from them\n///         * Allows authTransferFrom calls\n///\n/// @dev    The first 8 bytes (uint64) of hookData is used for the memberlist valid until date,\n///         the last bit is used to denote whether the account is frozen.\ncontract FullRestrictions is Auth, IMemberlist, IFreezable, IHook {\n    using BitmapLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using CastLib for bytes32;\n\n    /// @dev Least significant bit\n    uint8 public constant FREEZE_BIT = 0;\n\n    IRoot public immutable root;\n\n    constructor(address root_, address deployer) Auth(deployer) {\n        root = IRoot(root_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Callback from share token\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHook\n    function onERC20Transfer(address from, address to, uint256 value, HookData calldata hookData)\n        external\n        virtual\n        returns (bytes4)\n    {\n        require(checkERC20Transfer(from, to, value, hookData), TransferBlocked());\n        return IHook.onERC20Transfer.selector;\n    }\n\n    /// @inheritdoc IHook\n    function onERC20AuthTransfer(\n        address, /* sender */\n        address, /* from */\n        address, /* to */\n        uint256, /* value */\n        HookData calldata /* hookData */\n    ) external pure returns (bytes4) {\n        return IHook.onERC20AuthTransfer.selector;\n    }\n\n    /// @inheritdoc IHook\n    function checkERC20Transfer(address from, address to, uint256, /* value */ HookData calldata hookData)\n        public\n        view\n        returns (bool)\n    {\n        if (uint128(hookData.from).getBit(FREEZE_BIT) == true && !root.endorsed(from) && from != ESCROW_HOOK_ID) {\n            // Source is frozen and not endorsed\n            return false;\n        }\n\n        if (root.endorsed(to) || to == address(0) || to == ESCROW_HOOK_ID) {\n            // Destination is endorsed or escrow and source was already checked, so the transfer is allowed\n            return true;\n        }\n\n        uint128 toHookData = uint128(hookData.to);\n        if (toHookData.getBit(FREEZE_BIT) == true) {\n            // Destination is frozen\n            return false;\n        }\n\n        if (toHookData >> 64 < block.timestamp) {\n            // Destination is not a member\n            return false;\n        }\n\n        return true;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Restriction updates\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHook\n    function updateRestriction(address token, bytes memory payload) external auth {\n        UpdateRestrictionType updateId = payload.updateRestrictionType();\n\n        if (updateId == UpdateRestrictionType.Member) {\n            MessageLib.UpdateRestrictionMember memory m = payload.deserializeUpdateRestrictionMember();\n            updateMember(token, m.user.toAddress(), m.validUntil);\n        } else if (updateId == UpdateRestrictionType.Freeze) {\n            MessageLib.UpdateRestrictionFreeze memory m = payload.deserializeUpdateRestrictionFreeze();\n            freeze(token, m.user.toAddress());\n        } else if (updateId == UpdateRestrictionType.Unfreeze) {\n            MessageLib.UpdateRestrictionUnfreeze memory m = payload.deserializeUpdateRestrictionUnfreeze();\n            unfreeze(token, m.user.toAddress());\n        } else {\n            revert InvalidUpdate();\n        }\n    }\n\n    /// @inheritdoc IFreezable\n    function freeze(address token, address user) public auth {\n        require(user != address(0), CannotFreezeZeroAddress());\n        require(!root.endorsed(user), EndorsedUserCannotBeFrozen());\n\n        uint128 hookData = uint128(IShareToken(token).hookDataOf(user));\n        IShareToken(token).setHookData(user, bytes16(hookData.setBit(FREEZE_BIT, true)));\n\n        emit Freeze(token, user);\n    }\n\n    /// @inheritdoc IFreezable\n    function unfreeze(address token, address user) public auth {\n        uint128 hookData = uint128(IShareToken(token).hookDataOf(user));\n        IShareToken(token).setHookData(user, bytes16(hookData.setBit(FREEZE_BIT, false)));\n\n        emit Unfreeze(token, user);\n    }\n\n    /// @inheritdoc IFreezable\n    function isFrozen(address token, address user) public view returns (bool) {\n        return uint128(IShareToken(token).hookDataOf(user)).getBit(FREEZE_BIT);\n    }\n\n    /// @inheritdoc IMemberlist\n    function updateMember(address token, address user, uint64 validUntil) public auth {\n        require(block.timestamp <= validUntil, InvalidValidUntil());\n        require(!root.endorsed(user), EndorsedUserCannotBeUpdated());\n\n        uint128 hookData = uint128(validUntil) << 64;\n        hookData.setBit(FREEZE_BIT, isFrozen(token, user));\n        IShareToken(token).setHookData(user, bytes16(hookData));\n\n        emit UpdateMember(token, user, validUntil);\n    }\n\n    /// @inheritdoc IMemberlist\n    function isMember(address token, address user) external view returns (bool isValid, uint64 validUntil) {\n        validUntil = abi.encodePacked(IShareToken(token).hookDataOf(user)).toUint64(0);\n        isValid = validUntil >= block.timestamp;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(IHook).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "src/hooks/RedemptionRestrictions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {BitmapLib} from \"src/misc/libraries/BitmapLib.sol\";\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {UpdateRestrictionType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\n\nimport {IHook, HookData, ESCROW_HOOK_ID} from \"src/common/interfaces/IHook.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\nimport {IFreezable} from \"src/hooks/interfaces/IFreezable.sol\";\nimport {IMemberlist} from \"src/hooks/interfaces/IMemberlist.sol\";\n\n/// @title  Redemption Restrictions\n/// @notice Hook implementation that:\n///         * Allows any non-frozen account to receive tokens and transfer tokens\n///         * Requires accounts to be added as a member before submitting a redemption request\n///         * Supports freezing accounts which blocks transfers both to and from them\n///         * Allows authTransferFrom calls\n///\n/// @dev    The first 8 bytes (uint64) of hookData is used for the memberlist valid until date,\n///         the last bit is used to denote whether the account is frozen.\ncontract RedemptionRestrictions is Auth, IMemberlist, IFreezable, IHook {\n    using BitmapLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using CastLib for bytes32;\n\n    /// @dev Least significant bit\n    uint8 public constant FREEZE_BIT = 0;\n\n    IRoot public immutable root;\n\n    constructor(address root_, address deployer) Auth(deployer) {\n        root = IRoot(root_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Callback from share token\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHook\n    function onERC20Transfer(address from, address to, uint256 value, HookData calldata hookData)\n        external\n        virtual\n        returns (bytes4)\n    {\n        require(checkERC20Transfer(from, to, value, hookData), TransferBlocked());\n        return IHook.onERC20Transfer.selector;\n    }\n\n    /// @inheritdoc IHook\n    function onERC20AuthTransfer(\n        address, /* sender */\n        address, /* from */\n        address, /* to */\n        uint256, /* value */\n        HookData calldata /* hookData */\n    ) external pure returns (bytes4) {\n        return IHook.onERC20AuthTransfer.selector;\n    }\n\n    /// @inheritdoc IHook\n    function checkERC20Transfer(address from, address to, uint256, /* value */ HookData calldata hookData)\n        public\n        view\n        returns (bool)\n    {\n        uint128 fromHookData = uint128(hookData.from);\n        if (fromHookData.getBit(FREEZE_BIT) == true && !root.endorsed(from)) {\n            // Source is frozen and not endorsed\n            return false;\n        }\n\n        uint128 toHookData = uint128(hookData.to);\n        if (toHookData.getBit(FREEZE_BIT) == true) {\n            // Destination is frozen\n            return false;\n        }\n\n        if (from == address(0) && to == ESCROW_HOOK_ID) {\n            // Deposit request fulfillment\n            return true;\n        }\n\n        if (to == ESCROW_HOOK_ID && fromHookData >> 64 < block.timestamp) {\n            // Destination is escrow, so it's a redemption request, and the user is not a member\n            return false;\n        }\n\n        return true;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Restriction updates\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHook\n    function updateRestriction(address token, bytes memory payload) external auth {\n        UpdateRestrictionType updateId = payload.updateRestrictionType();\n\n        if (updateId == UpdateRestrictionType.Member) {\n            MessageLib.UpdateRestrictionMember memory m = payload.deserializeUpdateRestrictionMember();\n            updateMember(token, m.user.toAddress(), m.validUntil);\n        } else if (updateId == UpdateRestrictionType.Freeze) {\n            MessageLib.UpdateRestrictionFreeze memory m = payload.deserializeUpdateRestrictionFreeze();\n            freeze(token, m.user.toAddress());\n        } else if (updateId == UpdateRestrictionType.Unfreeze) {\n            MessageLib.UpdateRestrictionUnfreeze memory m = payload.deserializeUpdateRestrictionUnfreeze();\n            unfreeze(token, m.user.toAddress());\n        } else {\n            revert InvalidUpdate();\n        }\n    }\n\n    /// @inheritdoc IFreezable\n    function freeze(address token, address user) public auth {\n        require(user != address(0), CannotFreezeZeroAddress());\n        require(!root.endorsed(user), EndorsedUserCannotBeFrozen());\n\n        uint128 hookData = uint128(IShareToken(token).hookDataOf(user));\n        IShareToken(token).setHookData(user, bytes16(hookData.setBit(FREEZE_BIT, true)));\n\n        emit Freeze(token, user);\n    }\n\n    /// @inheritdoc IFreezable\n    function unfreeze(address token, address user) public auth {\n        uint128 hookData = uint128(IShareToken(token).hookDataOf(user));\n        IShareToken(token).setHookData(user, bytes16(hookData.setBit(FREEZE_BIT, false)));\n\n        emit Unfreeze(token, user);\n    }\n\n    /// @inheritdoc IFreezable\n    function isFrozen(address token, address user) public view returns (bool) {\n        return uint128(IShareToken(token).hookDataOf(user)).getBit(FREEZE_BIT);\n    }\n\n    /// @inheritdoc IMemberlist\n    function updateMember(address token, address user, uint64 validUntil) public auth {\n        require(block.timestamp <= validUntil, InvalidValidUntil());\n        require(!root.endorsed(user), EndorsedUserCannotBeUpdated());\n\n        uint128 hookData = uint128(validUntil) << 64;\n        hookData.setBit(FREEZE_BIT, isFrozen(token, user));\n        IShareToken(token).setHookData(user, bytes16(hookData));\n\n        emit UpdateMember(token, user, validUntil);\n    }\n\n    /// @inheritdoc IMemberlist\n    function isMember(address token, address user) external view returns (bool isValid, uint64 validUntil) {\n        validUntil = abi.encodePacked(IShareToken(token).hookDataOf(user)).toUint64(0);\n        isValid = validUntil >= block.timestamp;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(IHook).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "src/hooks/interfaces/IFreezable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\ninterface IFreezable {\n    // --- Events ---\n    event Freeze(address indexed token, address indexed user);\n    event Unfreeze(address indexed token, address indexed user);\n\n    // --- Errors ---\n    error CannotFreezeZeroAddress();\n    error EndorsedUserCannotBeFrozen();\n\n    // --- Handling freezes ---\n    /// @notice Freeze a user balance. Frozen users cannot receive nor send tokens\n    function freeze(address token, address user) external;\n\n    /// @notice Unfreeze a user balance\n    function unfreeze(address token, address user) external;\n\n    /// @notice Returns whether the user's tokens are frozen\n    function isFrozen(address token, address user) external view returns (bool);\n}\n"
    },
    "src/hooks/interfaces/IMemberlist.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\ninterface IMemberlist {\n    // --- Events ---\n    event UpdateMember(address indexed token, address indexed user, uint64 validUntil);\n\n    // --- Errors ---\n    error InvalidValidUntil();\n    error EndorsedUserCannotBeUpdated();\n\n    // --- Managing members ---\n    /// @notice Add a member. Non-members cannot receive tokens, but can send tokens to valid members\n    /// @param  validUntil Timestamp until which the user will be a valid member\n    function updateMember(address token, address user, uint64 validUntil) external;\n\n    /// @notice Returns whether the user is a valid member of the token\n    function isMember(address token, address user) external view returns (bool isValid, uint64 validUntil);\n}\n"
    },
    "src/hub/Accounting.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {IAccounting, JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\n/// @notice In a transaction there can be multiple journal entries for different pools,\n/// which can be interleaved. We want entries for the same pool to share the same journal ID.\n/// So we're keeping a journal ID per pool in transient storage.\nlibrary TransientJournal {\n    function journalId(PoolId poolId) internal view returns (uint256) {\n        return TransientStorageLib.tloadUint256(keccak256(abi.encode(\"journalId\", poolId)));\n    }\n\n    function setJournalId(PoolId poolId, uint256 value) internal {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"journalId\", poolId)), value);\n    }\n}\n\n/// @title  Accounting\n/// @notice Double-entry bookkeeping system.\n/// @dev    To add entries, a specific pool needs to be unlocked.\n///         When locking, the debited and credited amounts need to match.\ncontract Accounting is Auth, IAccounting {\n    mapping(PoolId => mapping(AccountId => Account)) public accounts;\n\n    uint128 public transient debited;\n    uint128 public transient credited;\n    PoolId internal transient _currentPoolId;\n    mapping(PoolId => uint64) internal _poolJournalIdCounter;\n\n    constructor(address deployer) Auth(deployer) {}\n\n    //----------------------------------------------------------------------------------------------\n    // Lock/unlock\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAccounting\n    function unlock(PoolId poolId) external auth {\n        require(PoolId.unwrap(_currentPoolId) == 0, AccountingAlreadyUnlocked());\n        debited = 0;\n        credited = 0;\n        _currentPoolId = poolId;\n\n        if (TransientJournal.journalId(poolId) == 0) {\n            TransientJournal.setJournalId(poolId, _generateJournalId(poolId));\n        }\n        emit StartJournalId(poolId, TransientJournal.journalId(poolId));\n    }\n\n    /// @inheritdoc IAccounting\n    function lock() external auth {\n        require(debited == credited, Unbalanced());\n\n        emit EndJournalId(_currentPoolId, TransientJournal.journalId(_currentPoolId));\n        _currentPoolId = PoolId.wrap(0);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Account creation & metadata\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAccounting\n    function createAccount(PoolId poolId, AccountId account, bool isDebitNormal) external auth {\n        require(accounts[poolId][account].lastUpdated == 0, AccountExists());\n        accounts[poolId][account] = Account(0, 0, isDebitNormal, uint64(block.timestamp), \"\");\n        emit CreateAccount(poolId, account, isDebitNormal);\n    }\n\n    /// @inheritdoc IAccounting\n    function setAccountMetadata(PoolId poolId, AccountId account, bytes calldata metadata) external auth {\n        require(accounts[poolId][account].lastUpdated != 0, AccountDoesNotExist());\n        accounts[poolId][account].metadata = metadata;\n        emit SetAccountMetadata(poolId, account, metadata);\n    }\n    \n    //----------------------------------------------------------------------------------------------\n    // Account updates\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAccounting\n    function addDebit(AccountId account, uint128 value) public auth {\n        require(!_currentPoolId.isNull(), AccountingLocked());\n\n        Account storage acc = accounts[_currentPoolId][account];\n        require(acc.lastUpdated != 0, AccountDoesNotExist());\n\n        acc.totalDebit += value;\n        debited += value;\n        acc.lastUpdated = uint64(block.timestamp);\n        emit Debit(_currentPoolId, account, value);\n    }\n\n    /// @inheritdoc IAccounting\n    function addCredit(AccountId account, uint128 value) public auth {\n        require(!_currentPoolId.isNull(), AccountingLocked());\n\n        Account storage acc = accounts[_currentPoolId][account];\n        require(acc.lastUpdated != 0, AccountDoesNotExist());\n\n        acc.totalCredit += value;\n        credited += value;\n        acc.lastUpdated = uint64(block.timestamp);\n        emit Credit(_currentPoolId, account, value);\n    }\n\n    /// @inheritdoc IAccounting\n    function addJournal(JournalEntry[] memory debits, JournalEntry[] memory credits) external auth {\n        for (uint256 i; i < debits.length; i++) {\n            addDebit(debits[i].accountId, debits[i].value);\n        }\n\n        for (uint256 i; i < credits.length; i++) {\n            addCredit(credits[i].accountId, credits[i].value);\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAccounting\n    function accountValue(PoolId poolId, AccountId account) external view returns (bool /* isPositive */, uint128) {\n        Account storage acc = accounts[poolId][account];\n        require(acc.lastUpdated != 0, AccountDoesNotExist());\n\n        if (acc.isDebitNormal) {\n            // For debit-normal accounts: Value = Total Debit - Total Credit\n            if (acc.totalDebit >= acc.totalCredit) {\n                return (true, acc.totalDebit - acc.totalCredit);\n            } else {\n                return (false, acc.totalCredit - acc.totalDebit);\n            }\n        } else {\n            // For credit-normal accounts: Value = Total Credit - Total Debit\n            if (acc.totalCredit >= acc.totalDebit) {\n                return (true, acc.totalCredit - acc.totalDebit);\n            } else {\n                return (false, acc.totalDebit - acc.totalCredit);\n            }\n        }\n    }\n\n    /// @inheritdoc IAccounting\n    function exists(PoolId poolId, AccountId account) external view returns (bool) {\n        return accounts[poolId][account].lastUpdated != 0;\n    }\n\n    function _generateJournalId(PoolId poolId) internal returns (uint256) {\n        return uint256((uint256(poolId.raw()) << 128) | ++_poolJournalIdCounter[poolId]);\n    }\n}\n"
    },
    "src/hub/Holdings.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {d18, D18} from \"src/misc/types/D18.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {IHoldings, Holding} from \"src/hub/interfaces/IHoldings.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {IHoldings, Holding, HoldingAccount} from \"src/hub/interfaces/IHoldings.sol\";\n\n/// @title  Holdings\n/// @notice Bookkeeping of the holdings and its associated accounting IDs for each pool.\ncontract Holdings is Auth, IHoldings {\n    using MathLib for uint256;\n\n    IHubRegistry public immutable hubRegistry;\n\n    mapping(PoolId => mapping(ShareClassId => mapping(AssetId => Holding))) public holding;\n    mapping(PoolId => mapping(ShareClassId => mapping(AssetId => mapping(uint8 kind => AccountId)))) public accountId;\n\n    constructor(IHubRegistry hubRegistry_, address deployer) Auth(deployer) {\n        hubRegistry = hubRegistry_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Holding creation & updates\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHoldings\n    function create(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation_,\n        bool isLiability_,\n        HoldingAccount[] memory accounts\n    ) external auth {\n        require(!scId.isNull(), WrongShareClassId());\n        require(address(valuation_) != address(0), WrongValuation());\n\n        holding[poolId][scId][assetId] = Holding(0, 0, valuation_, isLiability_);\n\n        for (uint256 i; i < accounts.length; i++) {\n            accountId[poolId][scId][assetId][accounts[i].kind] = accounts[i].accountId;\n        }\n\n        emit Create(poolId, scId, assetId, valuation_, isLiability_, accounts);\n    }\n\n    /// @inheritdoc IHoldings\n    function setAccountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind, AccountId accountId_)\n        external\n        auth\n    {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        accountId[poolId][scId][assetId][kind] = accountId_;\n\n        emit SetAccountId(poolId, scId, assetId, kind, accountId_);\n    }\n\n    /// @inheritdoc IHoldings\n    function updateValuation(PoolId poolId, ShareClassId scId, AssetId assetId, IERC7726 valuation_) external auth {\n        require(address(valuation_) != address(0), WrongValuation());\n\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        holding_.valuation = valuation_;\n\n        emit UpdateValuation(poolId, scId, assetId, valuation_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Value updates\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHoldings\n    function increase(PoolId poolId, ShareClassId scId, AssetId assetId, D18 pricePoolPerAsset, uint128 amount_)\n        external\n        auth\n        returns (uint128 amountValue)\n    {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        amountValue = PricingLib.convertWithPrice(\n            amount_, hubRegistry.decimals(assetId), hubRegistry.decimals(poolId), pricePoolPerAsset\n        ).toUint128();\n\n        holding_.assetAmount += amount_;\n        holding_.assetAmountValue += amountValue;\n\n        emit Increase(poolId, scId, assetId, pricePoolPerAsset, amount_, amountValue);\n    }\n\n    /// @inheritdoc IHoldings\n    function decrease(PoolId poolId, ShareClassId scId, AssetId assetId, D18 pricePoolPerAsset, uint128 amount_)\n        external\n        auth\n        returns (uint128 amountValue)\n    {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        amountValue = PricingLib.convertWithPrice(\n            amount_, hubRegistry.decimals(assetId), hubRegistry.decimals(poolId), pricePoolPerAsset\n        ).toUint128();\n\n        holding_.assetAmount -= amount_;\n        holding_.assetAmountValue -= amountValue;\n\n        emit Decrease(poolId, scId, assetId, pricePoolPerAsset, amount_, amountValue);\n    }\n\n    /// @inheritdoc IHoldings\n    function update(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        auth\n        returns (bool isPositive, uint128 diffValue)\n    {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        uint128 currentAmountValue = holding_.valuation.getQuote(\n            holding_.assetAmount, assetId.addr(), hubRegistry.currency(poolId).addr()\n        ).toUint128();\n\n        isPositive = currentAmountValue >= holding_.assetAmountValue;\n        diffValue =\n            isPositive ? currentAmountValue - holding_.assetAmountValue : holding_.assetAmountValue - currentAmountValue;\n\n        holding_.assetAmountValue = currentAmountValue;\n\n        emit Update(poolId, scId, assetId, isPositive, diffValue);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHoldings\n    function value(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (uint128 value_) {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        return holding_.assetAmountValue;\n    }\n\n    /// @inheritdoc IHoldings\n    function amount(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (uint128 amount_) {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        return holding_.assetAmount;\n    }\n\n    /// @inheritdoc IHoldings\n    function valuation(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (IERC7726) {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        return holding_.valuation;\n    }\n\n    /// @inheritdoc IHoldings\n    function isLiability(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (bool) {\n        Holding storage holding_ = holding[poolId][scId][assetId];\n        require(address(holding_.valuation) != address(0), HoldingNotFound());\n\n        return holding_.isLiability;\n    }\n\n    /// @inheritdoc IHoldings\n    function exists(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (bool) {\n        return address(holding[poolId][scId][assetId].valuation) != address(0);\n    }\n}\n"
    },
    "src/hub/Hub.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {Multicall, IMulticall} from \"src/misc/Multicall.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\n\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IHubGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {IPoolMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\nimport {IHubGuardianActions} from \"src/common/interfaces/IGuardianActions.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {IAccounting, JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\nimport {IHoldings, HoldingAccount} from \"src/hub/interfaces/IHoldings.sol\";\nimport {IHub, AccountType} from \"src/hub/interfaces/IHub.sol\";\n\n/// @title  Hub\n/// @notice Central pool management contract, that brings together all functions in one place.\n///         Pools can assign hub managers which have full rights over all actions.\n///\n///         Also acts as the central contract that routes messages from other chains to the Hub contracts.\ncontract Hub is Multicall, Auth, Recoverable, IHub, IHubGatewayHandler, IHubGuardianActions {\n    using MathLib for uint256;\n\n    IHubRegistry public immutable hubRegistry;\n\n    IGateway public gateway;\n    IHoldings public holdings;\n    IAccounting public accounting;\n    IPoolMessageSender public sender;\n    IShareClassManager public shareClassManager;\n\n    constructor(\n        IShareClassManager shareClassManager_,\n        IHubRegistry hubRegistry_,\n        IAccounting accounting_,\n        IHoldings holdings_,\n        IGateway gateway_,\n        address deployer\n    ) Auth(deployer) {\n        shareClassManager = shareClassManager_;\n        hubRegistry = hubRegistry_;\n        accounting = accounting_;\n        holdings = holdings_;\n        gateway = gateway_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // System methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function file(bytes32 what, address data) external {\n        _auth();\n\n        if (what == \"sender\") sender = IPoolMessageSender(data);\n        else if (what == \"holdings\") holdings = IHoldings(data);\n        else if (what == \"accounting\") accounting = IAccounting(data);\n        else if (what == \"shareClassManager\") shareClassManager = IShareClassManager(data);\n        else if (what == \"gateway\") gateway = IGateway(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IMulticall\n    /// @notice performs a multicall but all messages sent in the process will be batched\n    function multicall(bytes[] calldata data) public payable override {\n        bool wasBatching = gateway.isBatching();\n        if (!wasBatching) {\n            gateway.startBatching();\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n\n        super.multicall(data);\n\n        if (!wasBatching) {\n            gateway.endBatching();\n        }\n    }\n\n    /// @inheritdoc IHubGuardianActions\n    function createPool(PoolId poolId, address admin, AssetId currency) external payable {\n        _auth();\n\n        require(poolId.centrifugeId() == sender.localCentrifugeId(), InvalidPoolId());\n        hubRegistry.registerPool(poolId, admin, currency);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Permissionless methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function notifyDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable\n    {\n        _pay();\n\n        uint128 totalPayoutShareAmount;\n        uint128 totalPaymentAssetAmount;\n        uint128 cancelledAssetAmount;\n\n        for (uint32 i = 0; i < maxClaims; i++) {\n            (uint128 payoutShareAmount, uint128 paymentAssetAmount, uint128 cancelled, bool canClaimAgain) =\n                shareClassManager.claimDeposit(poolId, scId, investor, assetId);\n\n            totalPayoutShareAmount += payoutShareAmount;\n            totalPaymentAssetAmount += paymentAssetAmount;\n\n            // Should be written at most once with non-zero amount iff the last claimable epoch was processed and\n            // the user had a pending cancellation\n            // NOTE: Purposely delaying corresponding message dispatch after deposit fulfillment message\n            if (cancelled > 0) {\n                cancelledAssetAmount = cancelled;\n            }\n\n            if (!canClaimAgain) {\n                break;\n            }\n        }\n\n        sender.sendFulfilledDepositRequest(\n            poolId, scId, assetId, investor, totalPaymentAssetAmount, totalPayoutShareAmount\n        );\n\n        // If cancellation was queued, notify about delayed cancellation\n        if (cancelledAssetAmount > 0) {\n            sender.sendFulfilledCancelDepositRequest(poolId, scId, assetId, investor, cancelledAssetAmount);\n        }\n    }\n\n    /// @inheritdoc IHub\n    function notifyRedeem(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable\n    {\n        _pay();\n\n        uint128 totalPayoutAssetAmount;\n        uint128 totalPaymentShareAmount;\n        uint128 cancelledShareAmount;\n\n        for (uint32 i = 0; i < maxClaims; i++) {\n            (uint128 payoutAssetAmount, uint128 paymentShareAmount, uint128 cancelled, bool canClaimAgain) =\n                shareClassManager.claimRedeem(poolId, scId, investor, assetId);\n\n            totalPayoutAssetAmount += payoutAssetAmount;\n            totalPaymentShareAmount += paymentShareAmount;\n\n            // Should be written at most once with non-zero amount iff the last claimable epoch was processed and\n            // the user had a pending cancellation\n            // NOTE: Purposely delaying corresponding message dispatch after redemption fulfillment message\n            if (cancelled > 0) {\n                cancelledShareAmount = cancelled;\n            }\n\n            if (!canClaimAgain) {\n                break;\n            }\n        }\n\n        sender.sendFulfilledRedeemRequest(\n            poolId, scId, assetId, investor, totalPayoutAssetAmount, totalPaymentShareAmount\n        );\n\n        // If cancellation was queued, notify about delayed cancellation\n        if (cancelledShareAmount > 0) {\n            sender.sendFulfilledCancelRedeemRequest(poolId, scId, assetId, investor, cancelledShareAmount);\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Pool admin methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHub\n    function notifyPool(PoolId poolId, uint16 centrifugeId) external payable {\n        _isManagerAndPaid(poolId);\n\n        emit NotifyPool(centrifugeId, poolId);\n        sender.sendNotifyPool(centrifugeId, poolId);\n    }\n\n    /// @inheritdoc IHub\n    function notifyShareClass(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook) external payable {\n        _isManagerAndPaid(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        (string memory name, string memory symbol, bytes32 salt) = shareClassManager.metadata(scId);\n        uint8 decimals = hubRegistry.decimals(poolId);\n\n        emit NotifyShareClass(centrifugeId, poolId, scId);\n        sender.sendNotifyShareClass(centrifugeId, poolId, scId, name, symbol, decimals, salt, hook);\n    }\n\n    /// @inheritdoc IHub\n    function notifyShareMetadata(PoolId poolId, ShareClassId scId, uint16 centrifugeId) public payable {\n        _isManagerAndPaid(poolId);\n\n        (string memory name, string memory symbol,) = shareClassManager.metadata(scId);\n\n        emit NotifyShareMetadata(centrifugeId, poolId, scId, name, symbol);\n        sender.sendNotifyShareMetadata(centrifugeId, poolId, scId, name, symbol);\n    }\n\n    /// @inheritdoc IHub\n    function updateShareHook(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook) public payable {\n        _isManagerAndPaid(poolId);\n\n        emit UpdateShareHook(centrifugeId, poolId, scId, hook);\n        sender.sendUpdateShareHook(centrifugeId, poolId, scId, hook);\n    }\n\n    /// @inheritdoc IHub\n    function notifySharePrice(PoolId poolId, ShareClassId scId, uint16 centrifugeId) public payable {\n        _isManagerAndPaid(poolId);\n\n        (, D18 poolPerShare) = shareClassManager.metrics(scId);\n\n        emit NotifySharePrice(centrifugeId, poolId, scId, poolPerShare);\n        sender.sendNotifyPricePoolPerShare(centrifugeId, poolId, scId, poolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function notifyAssetPrice(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManagerAndPaid(poolId);\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, assetId);\n        emit NotifyAssetPrice(assetId.centrifugeId(), poolId, scId, assetId, pricePoolPerAsset);\n        sender.sendNotifyPricePoolPerAsset(poolId, scId, assetId, pricePoolPerAsset);\n    }\n\n    /// @inheritdoc IHub\n    function triggerIssueShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, address who, uint128 shares)\n        public\n        payable\n    {\n        _isManagerAndPaid(poolId);\n\n        sender.sendTriggerIssueShares(centrifugeId, poolId, scId, who, shares);\n    }\n\n    /// @inheritdoc IHub\n    function triggerSubmitQueuedShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId) public payable {\n        _isManagerAndPaid(poolId);\n\n        sender.sendTriggerSubmitQueuedShares(centrifugeId, poolId, scId);\n    }\n\n    /// @inheritdoc IHub\n    function triggerSubmitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManagerAndPaid(poolId);\n\n        sender.sendTriggerSubmitQueuedAssets(poolId, scId, assetId);\n    }\n\n    /// @inheritdoc IHub\n    function setQueue(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bool enabled) public payable {\n        _isManagerAndPaid(poolId);\n\n        sender.sendSetQueue(centrifugeId, poolId, scId, enabled);\n    }\n\n    /// @inheritdoc IHub\n    function setPoolMetadata(PoolId poolId, bytes calldata metadata) external payable {\n        _isManager(poolId);\n\n        hubRegistry.setMetadata(poolId, metadata);\n    }\n\n    /// @inheritdoc IHub\n    function updateShareClassMetadata(PoolId poolId, ShareClassId scId, string calldata name, string calldata symbol)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        shareClassManager.updateMetadata(poolId, scId, name, symbol);\n    }\n\n    /// @inheritdoc IHub\n    function updateManager(PoolId poolId, address who, bool canManage) external payable {\n        _isManager(poolId);\n\n        hubRegistry.updateManager(poolId, who, canManage);\n    }\n\n    /// @inheritdoc IHub\n    function addShareClass(PoolId poolId, string calldata name, string calldata symbol, bytes32 salt)\n        external\n        payable\n        returns (ShareClassId scId)\n    {\n        _isManager(poolId);\n\n        return shareClassManager.addShareClass(poolId, name, symbol, salt);\n    }\n\n    /// @inheritdoc IHub\n    function approveDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowDepositEpochId,\n        uint128 approvedAssetAmount\n    ) external payable returns (uint128 pendingAssetAmount, uint128 approvedPoolAmount) {\n        _isManagerAndPaid(poolId);\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, depositAssetId);\n        (pendingAssetAmount, approvedPoolAmount) = shareClassManager.approveDeposits(\n            poolId, scId, depositAssetId, nowDepositEpochId, approvedAssetAmount, pricePoolPerAsset\n        );\n\n        sender.sendApprovedDeposits(poolId, scId, depositAssetId, approvedAssetAmount, pricePoolPerAsset);\n    }\n\n    /// @inheritdoc IHub\n    function approveRedeems(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRedeemEpochId,\n        uint128 approvedShareAmount\n    ) external payable returns (uint128 pendingShareAmount) {\n        _isManager(poolId);\n\n        D18 price = _pricePoolPerAsset(poolId, scId, payoutAssetId);\n        (pendingShareAmount) =\n            shareClassManager.approveRedeems(poolId, scId, payoutAssetId, nowRedeemEpochId, approvedShareAmount, price);\n    }\n\n    /// @inheritdoc IHub\n    function issueShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowIssueEpochId,\n        D18 navPoolPerShare\n    ) external payable returns (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount) {\n        _isManagerAndPaid(poolId);\n\n        (issuedShareAmount, depositAssetAmount, depositPoolAmount) =\n            shareClassManager.issueShares(poolId, scId, depositAssetId, nowIssueEpochId, navPoolPerShare);\n\n        sender.sendIssuedShares(poolId, scId, depositAssetId, issuedShareAmount, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function revokeShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRevokeEpochId,\n        D18 navPoolPerShare\n    ) external payable returns (uint128 revokedShareAmount, uint128 payoutAssetAmount, uint128 payoutPoolAmount) {\n        _isManagerAndPaid(poolId);\n\n        (revokedShareAmount, payoutAssetAmount, payoutPoolAmount) =\n            shareClassManager.revokeShares(poolId, scId, payoutAssetId, nowRevokeEpochId, navPoolPerShare);\n\n        sender.sendRevokedShares(poolId, scId, payoutAssetId, payoutAssetAmount, revokedShareAmount, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function updateRestriction(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes calldata payload)\n        external\n        payable\n    {\n        _isManagerAndPaid(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateRestriction(centrifugeId, poolId, scId, payload);\n        sender.sendUpdateRestriction(centrifugeId, poolId, scId, payload);\n    }\n\n    /// @inheritdoc IHub\n    function updateContract(\n        PoolId poolId,\n        ShareClassId scId,\n        uint16 centrifugeId,\n        bytes32 target,\n        bytes calldata payload\n    ) external payable {\n        _isManagerAndPaid(poolId);\n\n        require(shareClassManager.exists(poolId, scId), IShareClassManager.ShareClassNotFound());\n\n        emit UpdateContract(centrifugeId, poolId, scId, target, payload);\n        sender.sendUpdateContract(centrifugeId, poolId, scId, target, payload);\n    }\n\n    /// @inheritdoc IHub\n    function updatePricePerShare(PoolId poolId, ShareClassId scId, D18 navPoolPerShare) public payable {\n        _isManager(poolId);\n\n        shareClassManager.updatePricePerShare(poolId, scId, navPoolPerShare);\n    }\n\n    /// @inheritdoc IHub\n    function createHolding(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        AccountId assetAccount,\n        AccountId equityAccount,\n        AccountId gainAccount,\n        AccountId lossAccount\n    ) external payable {\n        _isManager(poolId);\n\n        require(hubRegistry.isRegistered(assetId), IHubRegistry.AssetNotFound());\n        require(\n            accounting.exists(poolId, assetAccount) && accounting.exists(poolId, equityAccount)\n                && accounting.exists(poolId, lossAccount) && accounting.exists(poolId, gainAccount),\n            IAccounting.AccountDoesNotExist()\n        );\n\n        HoldingAccount[] memory accounts = new HoldingAccount[](4);\n        accounts[0] = HoldingAccount(assetAccount, uint8(AccountType.Asset));\n        accounts[1] = HoldingAccount(equityAccount, uint8(AccountType.Equity));\n        accounts[3] = HoldingAccount(gainAccount, uint8(AccountType.Gain));\n        accounts[2] = HoldingAccount(lossAccount, uint8(AccountType.Loss));\n\n        holdings.create(poolId, scId, assetId, valuation, false, accounts);\n    }\n\n    /// @inheritdoc IHub\n    function createLiability(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        AccountId expenseAccount,\n        AccountId liabilityAccount\n    ) external payable {\n        _isManager(poolId);\n\n        require(hubRegistry.isRegistered(assetId), IHubRegistry.AssetNotFound());\n        require(\n            accounting.exists(poolId, expenseAccount) && accounting.exists(poolId, liabilityAccount),\n            IAccounting.AccountDoesNotExist()\n        );\n\n        HoldingAccount[] memory accounts = new HoldingAccount[](2);\n        accounts[0] = HoldingAccount(expenseAccount, uint8(AccountType.Expense));\n        accounts[1] = HoldingAccount(liabilityAccount, uint8(AccountType.Liability));\n\n        holdings.create(poolId, scId, assetId, valuation, true, accounts);\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingValue(PoolId poolId, ShareClassId scId, AssetId assetId) public payable {\n        _isManager(poolId);\n\n        accounting.unlock(poolId);\n\n        (bool isPositive, uint128 diff) = holdings.update(poolId, scId, assetId);\n\n        // Save a diff=0 update gas cost\n        if (isPositive && diff > 0) {\n            if (holdings.isLiability(poolId, scId, assetId)) {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Liability)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Expense)), diff);\n            } else {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Gain)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Asset)), diff);\n            }\n        } else if (diff > 0) {\n            if (holdings.isLiability(poolId, scId, assetId)) {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Expense)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Liability)), diff);\n            } else {\n                accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Asset)), diff);\n                accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(AccountType.Loss)), diff);\n            }\n        }\n\n        accounting.lock();\n    }\n\n    /// @inheritdoc IHub\n    function updateHoldingValuation(PoolId poolId, ShareClassId scId, AssetId assetId, IERC7726 valuation)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        holdings.updateValuation(poolId, scId, assetId, valuation);\n    }\n\n    /// @inheritdoc IHub\n    function setHoldingAccountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind, AccountId accountId)\n        external\n        payable\n    {\n        _isManager(poolId);\n\n        holdings.setAccountId(poolId, scId, assetId, kind, accountId);\n    }\n\n    /// @inheritdoc IHub\n    function createAccount(PoolId poolId, AccountId account, bool isDebitNormal) public payable {\n        _isManager(poolId);\n\n        accounting.createAccount(poolId, account, isDebitNormal);\n    }\n\n    /// @inheritdoc IHub\n    function setAccountMetadata(PoolId poolId, AccountId account, bytes calldata metadata) external payable {\n        _isManager(poolId);\n\n        accounting.setAccountMetadata(poolId, account, metadata);\n    }\n\n    /// @inheritdoc IHub\n    function updateJournal(PoolId poolId, JournalEntry[] memory debits, JournalEntry[] memory credits) external {\n        _isManager(poolId);\n\n        accounting.unlock(poolId);\n        accounting.addJournal(debits, credits);\n        accounting.lock();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway owner methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHubGatewayHandler\n    function registerAsset(AssetId assetId, uint8 decimals) external {\n        _auth();\n\n        hubRegistry.registerAsset(assetId, decimals);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function depositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId, uint128 amount)\n        external\n    {\n        _auth();\n\n        shareClassManager.requestDeposit(poolId, scId, amount, investor, depositAssetId);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function redeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId, uint128 amount)\n        external\n    {\n        _auth();\n\n        shareClassManager.requestRedeem(poolId, scId, amount, investor, payoutAssetId);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function cancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external\n    {\n        _auth();\n\n        uint128 cancelledAssetAmount = shareClassManager.cancelDepositRequest(poolId, scId, investor, depositAssetId);\n\n        // Cancellation might have been queued such that it will be executed in the future during claiming\n        if (cancelledAssetAmount > 0) {\n            sender.sendFulfilledCancelDepositRequest(poolId, scId, depositAssetId, investor, cancelledAssetAmount);\n        }\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function cancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId) external {\n        _auth();\n\n        uint128 cancelledShareAmount = shareClassManager.cancelRedeemRequest(poolId, scId, investor, payoutAssetId);\n\n        // Cancellation might have been queued such that it will be executed in the future during claiming\n        if (cancelledShareAmount > 0) {\n            sender.sendFulfilledCancelRedeemRequest(poolId, scId, payoutAssetId, investor, cancelledShareAmount);\n        }\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function updateHoldingAmount(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease\n    ) external {\n        _auth();\n\n        accounting.unlock(poolId);\n\n        bool isLiability = holdings.isLiability(poolId, scId, assetId);\n        AccountType debitAccountType = isLiability ? AccountType.Expense : AccountType.Asset;\n        AccountType creditAccountType = isLiability ? AccountType.Liability : AccountType.Equity;\n\n        if (isIncrease) {\n            uint128 value = holdings.increase(poolId, scId, assetId, pricePoolPerAsset, amount);\n            accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(debitAccountType)), value);\n            accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(creditAccountType)), value);\n        } else {\n            uint128 value = holdings.decrease(poolId, scId, assetId, pricePoolPerAsset, amount);\n            accounting.addDebit(holdings.accountId(poolId, scId, assetId, uint8(creditAccountType)), value);\n            accounting.addCredit(holdings.accountId(poolId, scId, assetId, uint8(debitAccountType)), value);\n        }\n\n        accounting.lock();\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function increaseShareIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external {\n        _auth();\n\n        shareClassManager.increaseShareClassIssuance(poolId, scId, amount);\n    }\n\n    /// @inheritdoc IHubGatewayHandler\n    function decreaseShareIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external {\n        _auth();\n\n        shareClassManager.decreaseShareClassIssuance(poolId, scId, amount);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    //  Internal methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev Ensure the sender is authorized\n    function _auth() internal auth {}\n\n    /// @dev Ensure the method can be used without reentrancy issues, and the sender is a pool admin\n    function _isManager(PoolId poolId) internal protected {\n        require(hubRegistry.manager(poolId, msg.sender), IHub.NotManager());\n    }\n\n    /// @dev Ensure the sender is authorized\n    function _isManagerAndPaid(PoolId poolId) internal {\n        _isManager(poolId);\n        _pay();\n    }\n\n    /// @notice Send native tokens to the gateway for transaction payment if it's not in a multicall.\n    function _pay() internal {\n        if (!gateway.isBatching()) {\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n    }\n\n    function _pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId) internal view returns (D18) {\n        AssetId poolCurrency = hubRegistry.currency(poolId);\n        // NOTE: We assume symmetric prices are provided by holdings valuation\n        IERC7726 valuation = holdings.valuation(poolId, scId, assetId);\n\n        // Retrieve amount of 1 asset unit in pool currency\n        uint128 assetUnitAmount = (10 ** hubRegistry.decimals(assetId.raw())).toUint128();\n        uint128 poolUnitAmount = (10 ** hubRegistry.decimals(poolCurrency.raw())).toUint128();\n        uint128 poolAmountPerAsset =\n            valuation.getQuote(assetUnitAmount, assetId.addr(), poolCurrency.addr()).toUint128();\n\n        // Retrieve price by normalizing by pool denomination\n        return d18(poolAmountPerAsset, poolUnitAmount);\n    }\n}\n"
    },
    "src/hub/HubRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IERC6909Decimals} from \"src/misc/interfaces/IERC6909.sol\";\n\nimport {PoolId, newPoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\n\n/// @title  Hub Registry\n/// @notice Registry of all known pools, currencies, and assets.\ncontract HubRegistry is Auth, IHubRegistry {\n    using MathLib for uint256;\n\n    mapping(AssetId => uint8) internal _decimals;\n\n    mapping(PoolId => bytes) public metadata;\n    mapping(PoolId => AssetId) public currency;\n    mapping(bytes32 => address) public dependency;\n    mapping(PoolId => mapping(address => bool)) public manager;\n\n    constructor(address deployer) Auth(deployer) {}\n\n    //----------------------------------------------------------------------------------------------\n    // Registration methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHubRegistry\n    function registerAsset(AssetId assetId, uint8 decimals_) external auth {\n        require(_decimals[assetId] == 0, AssetAlreadyRegistered());\n\n        _decimals[assetId] = decimals_;\n\n        emit NewAsset(assetId, decimals_);\n    }\n\n    /// @inheritdoc IHubRegistry\n    function registerPool(PoolId poolId_, address manager_, AssetId currency_) external auth {\n        require(manager_ != address(0), EmptyAccount());\n        require(!currency_.isNull(), EmptyCurrency());\n        require(currency[poolId_].isNull(), PoolAlreadyRegistered());\n\n        manager[poolId_][manager_] = true;\n        currency[poolId_] = currency_;\n\n        emit NewPool(poolId_, manager_, currency_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Update methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHubRegistry\n    function updateManager(PoolId poolId_, address manager_, bool canManage) external auth {\n        require(exists(poolId_), NonExistingPool(poolId_));\n        require(manager_ != address(0), EmptyAccount());\n\n        manager[poolId_][manager_] = canManage;\n\n        emit UpdateManager(poolId_, manager_, canManage);\n    }\n\n    /// @inheritdoc IHubRegistry\n    function setMetadata(PoolId poolId_, bytes calldata metadata_) external auth {\n        require(exists(poolId_), NonExistingPool(poolId_));\n\n        metadata[poolId_] = metadata_;\n\n        emit SetMetadata(poolId_, metadata_);\n    }\n\n    /// @inheritdoc IHubRegistry\n    function updateDependency(bytes32 what, address dependency_) external auth {\n        dependency[what] = dependency_;\n\n        emit UpdateDependency(what, dependency_);\n    }\n\n    /// @inheritdoc IHubRegistry\n    function updateCurrency(PoolId poolId_, AssetId currency_) external auth {\n        require(exists(poolId_), NonExistingPool(poolId_));\n        require(!currency_.isNull(), EmptyCurrency());\n\n        currency[poolId_] = currency_;\n\n        emit UpdateCurrency(poolId_, currency_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IHubRegistry\n    function poolId(uint16 centrifugeId, uint48 postfix) public pure returns (PoolId poolId_) {\n        poolId_ = newPoolId(centrifugeId, postfix);\n    }\n\n    /// @inheritdoc IHubRegistry\n    function decimals(AssetId assetId) public view returns (uint8 decimals_) {\n        decimals_ = _decimals[assetId];\n        require(decimals_ > 0, AssetNotFound());\n    }\n\n    /// @inheritdoc IHubRegistry\n    function decimals(PoolId poolId_) public view returns (uint8 decimals_) {\n        decimals_ = _decimals[currency[poolId_]];\n        require(decimals_ > 0, AssetNotFound());\n    }\n\n    /// @inheritdoc IERC6909Decimals\n    function decimals(uint256 asset_) external view returns (uint8 decimals_) {\n        decimals_ = _decimals[AssetId.wrap(asset_.toUint128())];\n        require(decimals_ > 0, AssetNotFound());\n    }\n\n    /// @inheritdoc IHubRegistry\n    function exists(PoolId poolId_) public view returns (bool) {\n        return !currency[poolId_].isNull();\n    }\n\n    /// @inheritdoc IHubRegistry\n    function isRegistered(AssetId assetId) public view returns (bool) {\n        return _decimals[assetId] != 0;\n    }\n}\n"
    },
    "src/hub/ShareClassManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {ShareClassId, newShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {\n    IShareClassManager,\n    EpochInvestAmounts,\n    EpochRedeemAmounts,\n    UserOrder,\n    ShareClassMetadata,\n    ShareClassMetrics,\n    QueuedOrder,\n    RequestType,\n    EpochId\n} from \"src/hub/interfaces/IShareClassManager.sol\";\n\n/// @title  Share Class Manager\n/// @notice Manager for the share classes of a pool, and the core logic for tracking, approving, and fulfilling\n///         requests.\ncontract ShareClassManager is Auth, IShareClassManager {\n    using MathLib for *;\n    using CastLib for *;\n    using BytesLib for bytes;\n\n    IHubRegistry public immutable hubRegistry;\n\n    // Share classes\n    mapping(bytes32 salt => bool) public salts;\n    mapping(PoolId poolId => uint32) public shareClassCount;\n    mapping(ShareClassId scId => ShareClassMetrics) public metrics;\n    mapping(ShareClassId scId => ShareClassMetadata) public metadata;\n    mapping(PoolId poolId => mapping(ShareClassId => bool)) public shareClassIds;\n\n    // Epochs\n    mapping(ShareClassId scId => mapping(AssetId assetId => EpochId)) public epochId;\n    mapping(ShareClassId scId => mapping(AssetId assetId => mapping(uint32 epochId_ => EpochInvestAmounts epoch)))\n        public epochInvestAmounts;\n    mapping(ShareClassId scId => mapping(AssetId assetId => mapping(uint32 epochId_ => EpochRedeemAmounts epoch)))\n        public epochRedeemAmounts;\n\n    // Pending requests\n    mapping(ShareClassId scId => mapping(AssetId payoutAssetId => uint128 pending)) public pendingRedeem;\n    mapping(ShareClassId scId => mapping(AssetId depositAssetId => uint128 pending)) public pendingDeposit;\n    mapping(ShareClassId scId => mapping(AssetId payoutAssetId => mapping(bytes32 investor => UserOrder pending)))\n        public redeemRequest;\n    mapping(ShareClassId scId => mapping(AssetId depositAssetId => mapping(bytes32 investor => UserOrder pending)))\n        public depositRequest;\n\n    // Queued requests\n    mapping(ShareClassId scId => mapping(AssetId payoutAssetId => mapping(bytes32 investor => QueuedOrder queued)))\n        public queuedRedeemRequest;\n    mapping(ShareClassId scId => mapping(AssetId depositAssetId => mapping(bytes32 investor => QueuedOrder queued)))\n        public queuedDepositRequest;\n\n    constructor(IHubRegistry hubRegistry_, address deployer) Auth(deployer) {\n        hubRegistry = hubRegistry_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareClassManager\n    function addShareClass(PoolId poolId, string calldata name, string calldata symbol, bytes32 salt)\n        external\n        auth\n        returns (ShareClassId scId_)\n    {\n        scId_ = previewNextShareClassId(poolId);\n\n        uint32 index = ++shareClassCount[poolId];\n        shareClassIds[poolId][scId_] = true;\n\n        _updateMetadata(scId_, name, symbol, salt);\n\n        emit AddShareClass(poolId, scId_, index, name, symbol, salt);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming requests\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareClassManager\n    function requestDeposit(PoolId poolId, ShareClassId scId_, uint128 amount, bytes32 investor, AssetId depositAssetId)\n        external\n        auth\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        // NOTE: CV ensures amount > 0\n        _updatePending(poolId, scId_, amount, true, investor, depositAssetId, RequestType.Deposit);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function cancelDepositRequest(PoolId poolId, ShareClassId scId_, bytes32 investor, AssetId depositAssetId)\n        external\n        auth\n        returns (uint128 cancelledAssetAmount)\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        uint128 cancellingAmount = depositRequest[scId_][depositAssetId][investor].pending;\n\n        return _updatePending(poolId, scId_, cancellingAmount, false, investor, depositAssetId, RequestType.Deposit);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function requestRedeem(PoolId poolId, ShareClassId scId_, uint128 amount, bytes32 investor, AssetId payoutAssetId)\n        external\n        auth\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        // NOTE: CV ensures amount > 0\n        _updatePending(poolId, scId_, amount, true, investor, payoutAssetId, RequestType.Redeem);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function cancelRedeemRequest(PoolId poolId, ShareClassId scId_, bytes32 investor, AssetId payoutAssetId)\n        external\n        auth\n        returns (uint128 cancelledShareAmount)\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        uint128 cancellingAmount = redeemRequest[scId_][payoutAssetId][investor].pending;\n\n        return _updatePending(poolId, scId_, cancellingAmount, false, investor, payoutAssetId, RequestType.Redeem);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Manager actions\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareClassManager\n    function approveDeposits(\n        PoolId poolId,\n        ShareClassId scId_,\n        AssetId depositAssetId,\n        uint32 nowDepositEpochId,\n        uint128 approvedAssetAmount,\n        D18 pricePoolPerAsset\n    ) external auth returns (uint128 pendingAssetAmount, uint128 approvedPoolAmount) {\n        require(exists(poolId, scId_), ShareClassNotFound());\n        require(\n            nowDepositEpochId == nowDepositEpoch(scId_, depositAssetId),\n            EpochNotInSequence(nowDepositEpochId, nowDepositEpoch(scId_, depositAssetId))\n        );\n\n        // Limit in case approved > pending due to race condition of FM approval and async incoming requests\n        pendingAssetAmount = pendingDeposit[scId_][depositAssetId];\n        require(approvedAssetAmount <= pendingAssetAmount, InsufficientPending());\n        require(approvedAssetAmount > 0, ZeroApprovalAmount());\n\n        approvedPoolAmount = PricingLib.convertWithPrice(\n            approvedAssetAmount, hubRegistry.decimals(depositAssetId), hubRegistry.decimals(poolId), pricePoolPerAsset\n        ).toUint128();\n\n        // Update epoch data\n        EpochInvestAmounts storage epochAmounts = epochInvestAmounts[scId_][depositAssetId][nowDepositEpochId];\n        epochAmounts.approvedAssetAmount = approvedAssetAmount;\n        epochAmounts.approvedPoolAmount = approvedPoolAmount;\n        epochAmounts.pendingAssetAmount = pendingAssetAmount;\n        epochAmounts.pricePoolPerAsset = pricePoolPerAsset;\n\n        // Reduce pending\n        pendingDeposit[scId_][depositAssetId] -= approvedAssetAmount;\n        pendingAssetAmount -= approvedAssetAmount;\n\n        epochId[scId_][depositAssetId].deposit = nowDepositEpochId;\n        emit ApproveDeposits(\n            poolId,\n            scId_,\n            depositAssetId,\n            nowDepositEpochId,\n            approvedPoolAmount,\n            approvedAssetAmount,\n            pendingAssetAmount\n        );\n    }\n\n    /// @inheritdoc IShareClassManager\n    function approveRedeems(\n        PoolId poolId,\n        ShareClassId scId_,\n        AssetId payoutAssetId,\n        uint32 nowRedeemEpochId,\n        uint128 approvedShareAmount,\n        D18 pricePoolPerAsset\n    ) external auth returns (uint128 pendingShareAmount) {\n        require(exists(poolId, scId_), ShareClassNotFound());\n        require(\n            nowRedeemEpochId == nowRedeemEpoch(scId_, payoutAssetId),\n            EpochNotInSequence(nowRedeemEpochId, nowRedeemEpoch(scId_, payoutAssetId))\n        );\n\n        // Limit in case approved > pending due to race condition of FM approval and async incoming requests\n        pendingShareAmount = pendingRedeem[scId_][payoutAssetId];\n        require(approvedShareAmount <= pendingShareAmount, InsufficientPending());\n        require(approvedShareAmount > 0, ZeroApprovalAmount());\n\n        // Update epoch data\n        EpochRedeemAmounts storage epochAmounts = epochRedeemAmounts[scId_][payoutAssetId][nowRedeemEpochId];\n        epochAmounts.approvedShareAmount = approvedShareAmount;\n        epochAmounts.pendingShareAmount = pendingShareAmount;\n        epochAmounts.pricePoolPerAsset = pricePoolPerAsset;\n\n        // Reduce pending\n        pendingRedeem[scId_][payoutAssetId] -= approvedShareAmount;\n        pendingShareAmount -= approvedShareAmount;\n        epochId[scId_][payoutAssetId].redeem = nowRedeemEpochId;\n        emit ApproveRedeems(poolId, scId_, payoutAssetId, nowRedeemEpochId, approvedShareAmount, pendingShareAmount);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function issueShares(\n        PoolId poolId,\n        ShareClassId scId_,\n        AssetId depositAssetId,\n        uint32 nowIssueEpochId,\n        D18 navPoolPerShare\n    ) external auth returns (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount) {\n        require(exists(poolId, scId_), ShareClassNotFound());\n        require(nowIssueEpochId <= epochId[scId_][depositAssetId].deposit, EpochNotFound());\n        require(\n            nowIssueEpochId == nowIssueEpoch(scId_, depositAssetId),\n            EpochNotInSequence(nowIssueEpochId, nowIssueEpoch(scId_, depositAssetId))\n        );\n\n        EpochInvestAmounts storage epochAmounts = epochInvestAmounts[scId_][depositAssetId][nowIssueEpochId];\n        epochAmounts.navPoolPerShare = navPoolPerShare;\n\n        issuedShareAmount = PricingLib.assetToShareAmount(\n            epochAmounts.approvedAssetAmount,\n            hubRegistry.decimals(depositAssetId),\n            hubRegistry.decimals(poolId),\n            epochAmounts.pricePoolPerAsset,\n            navPoolPerShare,\n            MathLib.Rounding.Down\n        ).toUint128();\n\n        metrics[scId_].totalIssuance += issuedShareAmount;\n        epochAmounts.issuedAt = block.timestamp.toUint64();\n        epochId[scId_][depositAssetId].issue = nowIssueEpochId;\n\n        depositAssetAmount = epochAmounts.approvedAssetAmount;\n        depositPoolAmount = epochAmounts.approvedPoolAmount;\n\n        emit IssueShares(\n            poolId,\n            scId_,\n            depositAssetId,\n            nowIssueEpochId,\n            navPoolPerShare,\n            PricingLib.priceAssetPerShare(epochAmounts.navPoolPerShare, epochAmounts.pricePoolPerAsset),\n            issuedShareAmount\n        );\n    }\n\n    /// @inheritdoc IShareClassManager\n    function revokeShares(\n        PoolId poolId,\n        ShareClassId scId_,\n        AssetId payoutAssetId,\n        uint32 nowRevokeEpochId,\n        D18 navPoolPerShare\n    ) external auth returns (uint128 revokedShareAmount, uint128 payoutAssetAmount, uint128 payoutPoolAmount) {\n        require(exists(poolId, scId_), ShareClassNotFound());\n        require(nowRevokeEpochId <= epochId[scId_][payoutAssetId].redeem, EpochNotFound());\n        require(\n            nowRevokeEpochId == nowRevokeEpoch(scId_, payoutAssetId),\n            EpochNotInSequence(nowRevokeEpochId, nowRevokeEpoch(scId_, payoutAssetId))\n        );\n\n        EpochRedeemAmounts storage epochAmounts = epochRedeemAmounts[scId_][payoutAssetId][nowRevokeEpochId];\n        epochAmounts.navPoolPerShare = navPoolPerShare;\n\n        require(epochAmounts.approvedShareAmount <= metrics[scId_].totalIssuance, RevokeMoreThanIssued());\n\n        // NOTE: shares and pool currency have the same decimals - no conversion needed!\n        payoutPoolAmount = navPoolPerShare.mulUint128(epochAmounts.approvedShareAmount, MathLib.Rounding.Down);\n\n        payoutAssetAmount = PricingLib.poolToAssetAmount(\n            payoutPoolAmount,\n            hubRegistry.decimals(poolId),\n            hubRegistry.decimals(payoutAssetId),\n            epochAmounts.pricePoolPerAsset,\n            MathLib.Rounding.Down\n        ).toUint128();\n        revokedShareAmount = epochAmounts.approvedShareAmount;\n\n        metrics[scId_].totalIssuance -= epochAmounts.approvedShareAmount;\n        epochAmounts.payoutAssetAmount = payoutAssetAmount;\n        epochAmounts.revokedAt = block.timestamp.toUint64();\n        epochId[scId_][payoutAssetId].revoke = nowRevokeEpochId;\n\n        emit RevokeShares(\n            poolId,\n            scId_,\n            payoutAssetId,\n            nowRevokeEpochId,\n            navPoolPerShare,\n            PricingLib.priceAssetPerShare(epochAmounts.navPoolPerShare, epochAmounts.pricePoolPerAsset),\n            epochAmounts.approvedShareAmount,\n            payoutAssetAmount,\n            payoutPoolAmount\n        );\n    }\n\n    /// @inheritdoc IShareClassManager\n    function updatePricePerShare(PoolId poolId, ShareClassId scId_, D18 navPoolPerShare) external auth {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        ShareClassMetrics storage m = metrics[scId_];\n        m.navPerShare = navPoolPerShare;\n        emit UpdateShareClass(poolId, scId_, navPoolPerShare);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function updateMetadata(PoolId poolId, ShareClassId scId_, string calldata name, string calldata symbol)\n        external\n        auth\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        _updateMetadata(scId_, name, symbol, bytes32(0));\n\n        emit UpdateMetadata(poolId, scId_, name, symbol);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function increaseShareClassIssuance(PoolId poolId, ShareClassId scId_, uint128 amount) external auth {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        uint128 newIssuance = metrics[scId_].totalIssuance + amount;\n        metrics[scId_].totalIssuance = newIssuance;\n\n        emit RemoteIssueShares(poolId, scId_, amount);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function decreaseShareClassIssuance(PoolId poolId, ShareClassId scId_, uint128 amount) external auth {\n        require(exists(poolId, scId_), ShareClassNotFound());\n        require(metrics[scId_].totalIssuance >= amount, DecreaseMoreThanIssued());\n\n        uint128 newIssuance = metrics[scId_].totalIssuance - amount;\n        metrics[scId_].totalIssuance = newIssuance;\n\n        emit RemoteRevokeShares(poolId, scId_, amount);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Claiming methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareClassManager\n    function claimDeposit(PoolId poolId, ShareClassId scId_, bytes32 investor, AssetId depositAssetId)\n        public\n        auth\n        returns (\n            uint128 payoutShareAmount,\n            uint128 paymentAssetAmount,\n            uint128 cancelledAssetAmount,\n            bool canClaimAgain\n        )\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        UserOrder storage userOrder = depositRequest[scId_][depositAssetId][investor];\n        require(userOrder.pending > 0, NoOrderFound());\n        require(userOrder.lastUpdate <= epochId[scId_][depositAssetId].issue, IssuanceRequired());\n        canClaimAgain = userOrder.lastUpdate < epochId[scId_][depositAssetId].issue;\n        EpochInvestAmounts storage epochAmounts = epochInvestAmounts[scId_][depositAssetId][userOrder.lastUpdate];\n\n        paymentAssetAmount = epochAmounts.approvedAssetAmount == 0\n            ? 0\n            : userOrder.pending.mulDiv(epochAmounts.approvedAssetAmount, epochAmounts.pendingAssetAmount).toUint128();\n\n        // NOTE: Due to precision loss, the sum of claimable user amounts is leq than the amount of minted share class\n        // tokens corresponding to the approved share amount (instead of equality). I.e., it is possible for an epoch to\n        // have an excess of a share class tokens which cannot be claimed by anyone.\n        // This excess is at most n-1 share tokens for an epoch with n claimable users.\n        if (paymentAssetAmount > 0) {\n            uint256 paymentPoolAmount = PricingLib.convertWithPrice(\n                paymentAssetAmount,\n                hubRegistry.decimals(depositAssetId),\n                hubRegistry.decimals(poolId),\n                epochAmounts.pricePoolPerAsset\n            );\n            payoutShareAmount =\n                epochAmounts.navPoolPerShare.reciprocalMulUint256(paymentPoolAmount, MathLib.Rounding.Down).toUint128();\n\n            userOrder.pending -= paymentAssetAmount;\n        }\n\n        emit ClaimDeposit(\n            poolId,\n            scId_,\n            userOrder.lastUpdate,\n            investor,\n            depositAssetId,\n            paymentAssetAmount,\n            userOrder.pending,\n            payoutShareAmount,\n            epochAmounts.issuedAt\n        );\n\n        // If there is nothing to claim anymore we can short circuit to the latest epoch\n        if (userOrder.pending == 0) {\n            // The current epoch is always one step ahead of the stored one\n            userOrder.lastUpdate = nowDepositEpoch(scId_, depositAssetId);\n            canClaimAgain = false;\n        } else {\n            userOrder.lastUpdate += 1;\n        }\n\n        // If user claimed up to latest approval epoch, move queued to pending\n        if (userOrder.lastUpdate == nowDepositEpoch(scId_, depositAssetId)) {\n            cancelledAssetAmount =\n                _postClaimUpdateQueued(poolId, scId_, investor, depositAssetId, userOrder, RequestType.Deposit);\n        }\n    }\n\n    /// @inheritdoc IShareClassManager\n    function claimRedeem(PoolId poolId, ShareClassId scId_, bytes32 investor, AssetId payoutAssetId)\n        public\n        auth\n        returns (\n            uint128 payoutAssetAmount,\n            uint128 paymentShareAmount,\n            uint128 cancelledShareAmount,\n            bool canClaimAgain\n        )\n    {\n        require(exists(poolId, scId_), ShareClassNotFound());\n\n        UserOrder storage userOrder = redeemRequest[scId_][payoutAssetId][investor];\n        require(userOrder.pending > 0, NoOrderFound());\n        require(userOrder.lastUpdate <= epochId[scId_][payoutAssetId].revoke, RevocationRequired());\n        canClaimAgain = userOrder.lastUpdate < epochId[scId_][payoutAssetId].revoke;\n\n        EpochRedeemAmounts storage epochAmounts = epochRedeemAmounts[scId_][payoutAssetId][userOrder.lastUpdate];\n\n        paymentShareAmount = epochAmounts.approvedShareAmount == 0\n            ? 0\n            : userOrder.pending.mulDiv(epochAmounts.approvedShareAmount, epochAmounts.pendingShareAmount).toUint128();\n\n        // NOTE: Due to precision loss, the sum of claimable user amounts is leq than the amount of minted share class\n        // tokens corresponding to the approved share amount (instead of equality). I.e., it is possible for an epoch to\n        // have an excess of a share class tokens which cannot be claimed by anyone.\n        // This excess is at most n-1 share tokens for an epoch with n claimable users.\n        if (paymentShareAmount > 0) {\n            payoutAssetAmount = PricingLib.shareToAssetAmount(\n                paymentShareAmount,\n                hubRegistry.decimals(poolId),\n                hubRegistry.decimals(payoutAssetId),\n                epochAmounts.pricePoolPerAsset,\n                epochAmounts.navPoolPerShare,\n                MathLib.Rounding.Down\n            ).toUint128();\n\n            userOrder.pending -= paymentShareAmount;\n        }\n\n        emit ClaimRedeem(\n            poolId,\n            scId_,\n            userOrder.lastUpdate,\n            investor,\n            payoutAssetId,\n            paymentShareAmount,\n            userOrder.pending,\n            payoutAssetAmount,\n            epochAmounts.revokedAt\n        );\n\n        // If there is nothing to claim anymore we can short circuit the in between epochs\n        if (userOrder.pending == 0) {\n            // The current epoch is always one step ahead of the stored one\n            userOrder.lastUpdate = nowRedeemEpoch(scId_, payoutAssetId);\n            canClaimAgain = false;\n        } else {\n            userOrder.lastUpdate += 1;\n        }\n\n        if (userOrder.lastUpdate == nowRedeemEpoch(scId_, payoutAssetId)) {\n            cancelledShareAmount =\n                _postClaimUpdateQueued(poolId, scId_, investor, payoutAssetId, userOrder, RequestType.Redeem);\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareClassManager\n    function previewNextShareClassId(PoolId poolId) public view returns (ShareClassId scId) {\n        return newShareClassId(poolId, shareClassCount[poolId] + 1);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function previewShareClassId(PoolId poolId, uint32 index) public pure returns (ShareClassId scId) {\n        return newShareClassId(poolId, index);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function exists(PoolId poolId, ShareClassId scId_) public view returns (bool) {\n        return shareClassIds[poolId][scId_];\n    }\n\n    /// @inheritdoc IShareClassManager\n    function nowDepositEpoch(ShareClassId scId_, AssetId depositAssetId) public view returns (uint32) {\n        return epochId[scId_][depositAssetId].deposit + 1;\n    }\n\n    /// @inheritdoc IShareClassManager\n    function nowIssueEpoch(ShareClassId scId_, AssetId depositAssetId) public view returns (uint32) {\n        return epochId[scId_][depositAssetId].issue + 1;\n    }\n\n    /// @inheritdoc IShareClassManager\n    function nowRedeemEpoch(ShareClassId scId_, AssetId depositAssetId) public view returns (uint32) {\n        return epochId[scId_][depositAssetId].redeem + 1;\n    }\n\n    /// @inheritdoc IShareClassManager\n    function nowRevokeEpoch(ShareClassId scId_, AssetId depositAssetId) public view returns (uint32) {\n        return epochId[scId_][depositAssetId].revoke + 1;\n    }\n\n    /// @inheritdoc IShareClassManager\n    function maxDepositClaims(ShareClassId scId_, bytes32 investor, AssetId depositAssetId)\n        public\n        view\n        returns (uint32)\n    {\n        return _maxClaims(depositRequest[scId_][depositAssetId][investor], epochId[scId_][depositAssetId].deposit);\n    }\n\n    /// @inheritdoc IShareClassManager\n    function maxRedeemClaims(ShareClassId scId_, bytes32 investor, AssetId payoutAssetId)\n        public\n        view\n        returns (uint32)\n    {\n        return _maxClaims(redeemRequest[scId_][payoutAssetId][investor], epochId[scId_][payoutAssetId].redeem);\n    }\n\n    function _maxClaims(UserOrder memory userOrder, uint32 lastEpoch) private pure returns (uint32) {\n        // User order either not set or not processed\n        if (userOrder.pending == 0 || userOrder.lastUpdate > lastEpoch) {\n            return 0;\n        }\n\n        return lastEpoch - userOrder.lastUpdate + 1;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal methods\n    //----------------------------------------------------------------------------------------------\n\n    function _updateMetadata(ShareClassId scId_, string calldata name, string calldata symbol, bytes32 salt) private {\n        uint256 nameLen = bytes(name).length;\n        require(nameLen > 0 && nameLen <= 128, InvalidMetadataName());\n\n        uint256 symbolLen = bytes(symbol).length;\n        require(symbolLen > 0 && symbolLen <= 32, InvalidMetadataSymbol());\n\n        ShareClassMetadata storage meta = metadata[scId_];\n\n        // Ensure that the salt is not being updated or is being set for the first time\n        require(\n            (salt == bytes32(0) && meta.salt != bytes32(0)) || (salt != bytes32(0) && meta.salt == bytes32(0)),\n            InvalidSalt()\n        );\n\n        if (salt != bytes32(0) && meta.salt == bytes32(0)) {\n            require(!salts[salt], AlreadyUsedSalt());\n            salts[salt] = true;\n            meta.salt = salt;\n        }\n\n        meta.name = name;\n        meta.symbol = symbol;\n    }\n\n    function _postClaimUpdateQueued(\n        PoolId poolId,\n        ShareClassId scId_,\n        bytes32 investor,\n        AssetId assetId,\n        UserOrder storage userOrder,\n        RequestType requestType\n    ) private returns (uint128 cancelledAmount) {\n        QueuedOrder storage queued = requestType == RequestType.Deposit\n            ? queuedDepositRequest[scId_][assetId][investor]\n            : queuedRedeemRequest[scId_][assetId][investor];\n\n        // Increment pending by queued or cancel everything\n        uint128 updatePendingAmount = queued.isCancelling ? userOrder.pending : queued.amount;\n        if (queued.isCancelling) {\n            cancelledAmount = userOrder.pending + queued.amount;\n            userOrder.pending = 0;\n        } else {\n            userOrder.pending += queued.amount;\n        }\n\n        if (requestType == RequestType.Deposit) {\n            _updatePendingDeposit(\n                poolId,\n                scId_,\n                updatePendingAmount,\n                !queued.isCancelling,\n                investor,\n                assetId,\n                userOrder,\n                QueuedOrder(false, 0)\n            );\n        } else {\n            _updatePendingRedeem(\n                poolId,\n                scId_,\n                updatePendingAmount,\n                !queued.isCancelling,\n                investor,\n                assetId,\n                userOrder,\n                QueuedOrder(false, 0)\n            );\n        }\n\n        // Clear queued\n        queued.isCancelling = false;\n        queued.amount = 0;\n    }\n\n    /// @notice Updates the amount of a deposit or redeem request.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId_ Identifier of the share class\n    /// @param amount Amount which is updated\n    /// @param isIncrement Whether the amount is positive (additional request) or negative (cancellation)\n    /// @param investor Address of the entity which is depositing\n    /// @param assetId Identifier of the asset which the investor either used as deposit or wants to redeem to\n    /// @param requestType Flag indicating whether the request is a deposit or redeem request\n    /// @return cancelledAmount Pending amount which was cancelled\n    function _updatePending(\n        PoolId poolId,\n        ShareClassId scId_,\n        uint128 amount,\n        bool isIncrement,\n        bytes32 investor,\n        AssetId assetId,\n        RequestType requestType\n    ) private returns (uint128 cancelledAmount) {\n        UserOrder storage userOrder = requestType == RequestType.Deposit\n            ? depositRequest[scId_][assetId][investor]\n            : redeemRequest[scId_][assetId][investor];\n        QueuedOrder storage queued = requestType == RequestType.Deposit\n            ? queuedDepositRequest[scId_][assetId][investor]\n            : queuedRedeemRequest[scId_][assetId][investor];\n\n        // We must only update either queued or pending\n        if (_updateQueued(poolId, scId_, amount, isIncrement, investor, assetId, userOrder, queued, requestType)) {\n            return 0;\n        }\n\n        cancelledAmount = isIncrement ? 0 : amount;\n        // NOTE: If we decrease the pending, we decrease usually by the full amount\n        //       We keep subtraction of amount over setting to zero on purpose to not limit future higher level logic\n        userOrder.pending = isIncrement ? userOrder.pending + amount : userOrder.pending - amount;\n\n        userOrder.lastUpdate =\n            requestType == RequestType.Deposit ? nowDepositEpoch(scId_, assetId) : nowRedeemEpoch(scId_, assetId);\n\n        if (requestType == RequestType.Deposit) {\n            _updatePendingDeposit(poolId, scId_, amount, isIncrement, investor, assetId, userOrder, queued);\n        } else {\n            _updatePendingRedeem(poolId, scId_, amount, isIncrement, investor, assetId, userOrder, queued);\n        }\n    }\n\n    /// @notice Checks whether the pending amount can be updated. If not, it updates the queued amount.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId_ Identifier of the share class\n    /// @param amount Amount which is updated\n    /// @param isIncrement Whether the amount is positive (additional request) or negative (cancellation)\n    /// @param investor Address of the entity which is depositing\n    /// @param assetId Identifier of the asset which the investor either used as deposit or wants to redeem to\n    /// @param userOrder User order storage for the deposit or redeem request\n    /// @param requestType Flag indicating whether the request is a deposit or redeem request\n    /// @return skipPendingUpdate Flag indicating whether the pending amount can be updated which is true if the user\n    /// does not need to claim\n    function _updateQueued(\n        PoolId poolId,\n        ShareClassId scId_,\n        uint128 amount,\n        bool isIncrement,\n        bytes32 investor,\n        AssetId assetId,\n        UserOrder storage userOrder,\n        QueuedOrder storage queued,\n        RequestType requestType\n    ) private returns (bool skipPendingUpdate) {\n        uint32 lastEpoch =\n            requestType == RequestType.Deposit ? epochId[scId_][assetId].deposit : epochId[scId_][assetId].redeem;\n        uint32 currentEpoch = lastEpoch + 1;\n\n        // Short circuit if user can mutate pending, i.e. last update happened after latest approval or is first update\n        if (userOrder.lastUpdate == currentEpoch || userOrder.pending == 0 || lastEpoch == 0) {\n            return false;\n        }\n\n        // Block increasing queued amount if cancelling is already queued\n        // NOTE: Can only happen due to race condition as CV blocks requests if cancellation is in progress\n        require(!(queued.isCancelling && amount > 0), CancellationQueued());\n\n        if (!isIncrement) {\n            queued.isCancelling = true;\n        } else {\n            queued.amount += amount;\n        }\n\n        if (requestType == RequestType.Deposit) {\n            uint128 pendingTotal = pendingDeposit[scId_][assetId];\n            emit UpdateDepositRequest(\n                poolId,\n                scId_,\n                assetId,\n                currentEpoch,\n                investor,\n                userOrder.pending,\n                pendingTotal,\n                queued.amount,\n                queued.isCancelling\n            );\n        } else {\n            uint128 pendingTotal = pendingRedeem[scId_][assetId];\n\n            emit UpdateRedeemRequest(\n                poolId,\n                scId_,\n                assetId,\n                currentEpoch,\n                investor,\n                userOrder.pending,\n                pendingTotal,\n                queued.amount,\n                queued.isCancelling\n            );\n        }\n\n        return true;\n    }\n\n    function _updatePendingDeposit(\n        PoolId poolId,\n        ShareClassId scId_,\n        uint128 amount,\n        bool isIncrement,\n        bytes32 investor,\n        AssetId assetId,\n        UserOrder storage userOrder,\n        QueuedOrder memory queued\n    ) private {\n        uint128 pendingTotal = pendingDeposit[scId_][assetId];\n        pendingTotal = isIncrement ? pendingTotal + amount : pendingTotal - amount;\n        pendingDeposit[scId_][assetId] = pendingTotal;\n\n        emit UpdateDepositRequest(\n            poolId,\n            scId_,\n            assetId,\n            nowDepositEpoch(scId_, assetId),\n            investor,\n            userOrder.pending,\n            pendingTotal,\n            queued.amount,\n            queued.isCancelling\n        );\n    }\n\n    function _updatePendingRedeem(\n        PoolId poolId,\n        ShareClassId scId_,\n        uint128 amount,\n        bool isIncrement,\n        bytes32 investor,\n        AssetId assetId,\n        UserOrder storage userOrder,\n        QueuedOrder memory queued\n    ) private {\n        uint128 pendingTotal = pendingRedeem[scId_][assetId];\n        pendingTotal = isIncrement ? pendingTotal + amount : pendingTotal - amount;\n        pendingRedeem[scId_][assetId] = pendingTotal;\n\n        emit UpdateRedeemRequest(\n            poolId,\n            scId_,\n            assetId,\n            nowRedeemEpoch(scId_, assetId),\n            investor,\n            userOrder.pending,\n            pendingTotal,\n            queued.amount,\n            queued.isCancelling\n        );\n    }\n}\n"
    },
    "src/hub/interfaces/IAccounting.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nstruct JournalEntry {\n    uint128 value;\n    AccountId accountId;\n}\n\ninterface IAccounting {\n    /// @notice Emitted when a an entry is done\n    event Credit(PoolId indexed poolId, AccountId indexed account, uint128 value);\n    event Debit(PoolId indexed poolId, AccountId indexed account, uint128 value);\n\n    /// @notice Emitted at the beginning and end of a journal entry\n    event StartJournalId(PoolId indexed poolId, uint256 journalId);\n    event EndJournalId(PoolId indexed poolId, uint256 journalId);\n\n    /// @notice Emitted when a new account is created\n    event CreateAccount(PoolId indexed poolId, AccountId indexed account, bool isDebitNormal);\n\n    /// @notice Emitted when metadata is set for an account\n    event SetAccountMetadata(PoolId indexed poolId, AccountId indexed account, bytes metadata);\n\n    /// @notice Dispatched when the pool is already unlocked.\n    error AccountingAlreadyUnlocked();\n\n    /// @notice Dispatched when the pool is not unlocked to interact with.\n    error AccountingLocked();\n\n    /// @notice Dispatched when the debit and credit side do not match at the end of a transaction.\n    error Unbalanced();\n\n    /// @notice Dispatched when trying to create an account that already exists.\n    error AccountExists();\n\n    /// @notice Dispatched when trying debit or credit an account that doesn't exists.\n    error AccountDoesNotExist();\n\n    /// @notice Represents an account\n    struct Account {\n        uint128 totalDebit;\n        uint128 totalCredit;\n        bool isDebitNormal;\n        uint64 lastUpdated;\n        bytes metadata;\n    }\n\n    /// @notice Debits an account. Increase the value of debit-normal accounts, decrease for credit-normal ones.\n    /// @param account The account to debit\n    /// @param value Amount being debited\n    function addDebit(AccountId account, uint128 value) external;\n\n    /// @notice Credits an account. Decrease the value of debit-normal accounts, increase for credit-normal ones.\n    /// @param account The account to credit\n    /// @param value Amount being credited\n    function addCredit(AccountId account, uint128 value) external;\n\n    /// @notice Apply addDebit and addCredit to each journal entry\n    function addJournal(JournalEntry[] memory debits, JournalEntry[] memory credits) external;\n\n    /// @notice Unlocks a pool for journal entries\n    /// @param poolId The pool to unlock\n    function unlock(PoolId poolId) external;\n\n    /// @notice Closes the transaction and checks if the entries are balanced.\n    function lock() external;\n\n    /// @notice Creates an account.\n    /// @param poolId The pool the account belongs to\n    /// @param account The account to create\n    /// @param isDebitNormal Whether the account is debit-normal or credit-normal\n    function createAccount(PoolId poolId, AccountId account, bool isDebitNormal) external;\n\n    /// @notice Sets metadata associated to an existent account.\n    /// @param poolId The pool the account belongs to\n    /// @param account The account to set metadata for\n    /// @param metadata The metadata to set\n    function setAccountMetadata(PoolId poolId, AccountId account, bytes calldata metadata) external;\n\n    /// @notice Returns the value of an account\n    /// @param poolId The pool the account belongs to\n    /// @param account The account to get the value of\n    /// @return isPositive Indicates whether value is a positive or negative value\n    /// @return value The value of the account\n    function accountValue(PoolId poolId, AccountId account) external view returns (bool isPositive, uint128 value);\n\n    /// @notice Returns whether an account exists\n    /// @param poolId The pool the account belongs to\n    /// @param account The account to check\n    /// @return True if the account exists, false otherwise\n    function exists(PoolId poolId, AccountId account) external view returns (bool);\n}\n"
    },
    "src/hub/interfaces/IHoldings.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {D18} from \"src/misc/types/D18.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nstruct Holding {\n    uint128 assetAmount;\n    uint128 assetAmountValue;\n    IERC7726 valuation; // Used for existence\n    bool isLiability;\n}\n\nstruct HoldingAccount {\n    AccountId accountId;\n    uint8 kind;\n}\n\ninterface IHoldings {\n    /// @notice Emitted when a holding is created\n    event Create(\n        PoolId indexed,\n        ShareClassId indexed scId,\n        AssetId indexed assetId,\n        IERC7726 valuation,\n        bool isLiability,\n        HoldingAccount[] accounts\n    );\n\n    /// @notice Emitted when a holding is increased\n    event Increase(\n        PoolId indexed,\n        ShareClassId indexed scId,\n        AssetId indexed assetId,\n        D18 pricePoolPerAsset,\n        uint128 amount,\n        uint128 increasedValue\n    );\n\n    /// @notice Emitted when a holding is decreased\n    event Decrease(\n        PoolId indexed,\n        ShareClassId indexed scId,\n        AssetId indexed assetId,\n        D18 pricePoolPerAsset,\n        uint128 amount,\n        uint128 decreasedValue\n    );\n\n    /// @notice Emitted when the holding is updated\n    event Update(\n        PoolId indexed, ShareClassId indexed scId, AssetId indexed assetId, bool isPositive, uint128 diffValue\n    );\n\n    /// @notice Emitted when a holding valuation is updated\n    event UpdateValuation(PoolId indexed, ShareClassId indexed scId, AssetId indexed assetId, IERC7726 valuation);\n\n    /// @notice Emitted when an account is for a holding is set\n    event SetAccountId(\n        PoolId indexed, ShareClassId indexed scId, AssetId indexed assetId, uint8 kind, AccountId accountId\n    );\n\n    /// @notice Item was not found for a required action\n    error HoldingNotFound();\n\n    /// @notice Valuation is not valid.\n    error WrongValuation();\n\n    /// @notice ShareClassId is not valid.\n    error WrongShareClassId();\n\n    /// @notice AssetId is not valid.\n    error WrongAssetId();\n\n    /// @notice Creates a new holding in a pool using a valuation\n    function create(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        bool isLiability,\n        HoldingAccount[] memory accounts\n    ) external;\n\n    /// @notice Increments the amount of a holding and updates the value for that increment.\n    /// @return value The value the holding has increment.\n    function increase(PoolId poolId, ShareClassId scId, AssetId assetId, D18 pricePoolPerAsset, uint128 amount)\n        external\n        returns (uint128 value);\n\n    /// @notice Decrements the amount of a holding and updates the value for that decrement.\n    /// @return value The value the holding has decrement.\n    function decrease(PoolId poolId, ShareClassId scId, AssetId assetId, D18 pricePoolPerAsset, uint128 amount)\n        external\n        returns (uint128 value);\n\n    /// @notice Reset the value of a holding using the current valuation.\n    /// @return isPositive Indicates whether the diffValue is positive or negative\n    /// @return diffValue The difference in value after the new valuation.\n    function update(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        returns (bool isPositive, uint128 diffValue);\n\n    /// @notice Updates the valuation method used for this holding.\n    function updateValuation(PoolId poolId, ShareClassId scId, AssetId assetId, IERC7726 valuation) external;\n\n    /// @notice Sets an account id for an specific kind\n    function setAccountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind, AccountId accountId)\n        external;\n\n    /// @notice Returns the value of this holding.\n    function value(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (uint128 value);\n\n    /// @notice Returns the amount of this holding.\n    function amount(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (uint128 amount);\n\n    /// @notice Returns the valuation method used for this holding.\n    function valuation(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (IERC7726);\n\n    /// @notice Returns if the holding is a liability\n    function isLiability(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (bool);\n\n    /// @notice Returns an account id for an specific kind\n    function accountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind)\n        external\n        view\n        returns (AccountId);\n\n    /// @notice Tells if the holding exists for an asset in a share class\n    function exists(PoolId poolId, ShareClassId scId, AssetId assetId) external view returns (bool);\n}\n"
    },
    "src/hub/interfaces/IHub.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {D18} from \"src/misc/types/D18.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\n\nimport {VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IPoolMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\nimport {IAccounting, JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {IHoldings} from \"src/hub/interfaces/IHoldings.sol\";\n\n/// @notice Account types used by Hub\nenum AccountType {\n    /// @notice Debit normal account for tracking assets\n    Asset,\n    /// @notice Credit normal account for tracking equities\n    Equity,\n    /// @notice Credit normal account for tracking losses\n    Loss,\n    /// @notice Credit normal account for tracking profits\n    Gain,\n    /// @notice Debit normal account for tracking expenses\n    Expense,\n    /// @notice Credit normal account for tracking liabilities\n    Liability\n}\n\n/// @notice Interface with all methods available in the system used by actors\ninterface IHub {\n    event NotifyPool(uint16 indexed centrifugeId, PoolId indexed poolId);\n    event NotifyShareClass(uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId);\n    event NotifyShareMetadata(\n        uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId, string name, string symbol\n    );\n    event UpdateShareHook(uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId, bytes32 hook);\n    event NotifySharePrice(uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId, D18 poolPerShare);\n    event NotifyAssetPrice(\n        uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId, AssetId assetId, D18 pricePoolPerAsset\n    );\n    event UpdateRestriction(uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId, bytes payload);\n    event UpdateContract(\n        uint16 indexed centrifugeId, PoolId indexed poolId, ShareClassId scId, bytes32 target, bytes payload\n    );\n\n    /// @notice Emitted when a call to `file()` was performed.\n    event File(bytes32 what, address addr);\n\n    /// @notice Dispatched when the `what` parameter of `file()` is not supported by the implementation.\n    error FileUnrecognizedParam();\n\n    /// @notice Dispatched when the pool is already unlocked.\n    /// It means when calling to `execute()` inside `execute()`.\n    error PoolAlreadyUnlocked();\n\n    /// @notice Dispatched when the pool can not be unlocked by the caller\n    error NotManager();\n\n    /// @notice Dispatched when an invalid centrifuge ID is set in the pool ID.\n    error InvalidPoolId();\n\n    function gateway() external view returns (IGateway);\n    function holdings() external view returns (IHoldings);\n    function accounting() external view returns (IAccounting);\n    function hubRegistry() external view returns (IHubRegistry);\n    function sender() external view returns (IPoolMessageSender);\n    function shareClassManager() external view returns (IShareClassManager);\n\n    /// @notice Updates a contract parameter.\n    /// @param what Name of the parameter to update.\n    /// Accepts a `bytes32` representation of 'hubRegistry', 'assetRegistry', 'accounting', 'holdings', 'gateway' and '\n    /// sender' as string value.\n    function file(bytes32 what, address data) external;\n\n    /// @notice Notify a deposit for an investor address located in the chain where the asset belongs\n    function notifyDeposit(PoolId poolId, ShareClassId scId, AssetId depositAssetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable;\n\n    /// @notice Notify a redemption for an investor address located in the chain where the asset belongs\n    function notifyRedeem(PoolId poolId, ShareClassId scId, AssetId payoutAssetId, bytes32 investor, uint32 maxClaims)\n        external\n        payable;\n\n    /// @notice Notify to a CV instance that a new pool is available\n    /// @param centrifugeId Chain where CV instance lives\n    function notifyPool(PoolId poolId, uint16 centrifugeId) external payable;\n\n    /// @notice Notify to a CV instance that a new share class is available\n    /// @param centrifugeId Chain where CV instance lives\n    /// @param hook The hook address of the share class\n    function notifyShareClass(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook) external payable;\n\n    /// @notice Notify to a CV instance that share metadata has updated\n    function notifyShareMetadata(PoolId poolId, ShareClassId scId, uint16 centrifugeId) external payable;\n\n    /// @notice Update on a CV instance the hook of a share token\n    function updateShareHook(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes32 hook) external payable;\n\n    /// @notice Notify to a CV instance the latest available price in POOL_UNIT / SHARE_UNIT\n    /// @dev The receiving centrifugeId is derived from the provided assetId\n    /// @param centrifugeId Chain to where the share price is notified\n    /// @param scId Identifier of the share class\n    function notifySharePrice(PoolId poolId, ShareClassId scId, uint16 centrifugeId) external payable;\n\n    /// @notice Notify to a CV instance the latest available price in POOL_UNIT / ASSET_UNIT\n    /// @dev The receiving centrifugeId is derived from the provided assetId\n    /// @param scId Identifier of the share class\n    /// @param assetId Identifier of the asset\n    function notifyAssetPrice(PoolId poolId, ShareClassId scId, AssetId assetId) external payable;\n\n    /// @notice Attach custom data to a pool\n    function setPoolMetadata(PoolId poolId, bytes calldata metadata) external payable;\n\n    /// @notice Update name & symbol of share class\n    function updateShareClassMetadata(PoolId poolId, ShareClassId scId, string calldata name, string calldata symbol)\n        external\n        payable;\n\n    /// @notice Allow/disallow an account to interact as pool manager\n    function updateManager(PoolId poolId, address who, bool canManage) external payable;\n\n    /// @notice Add a new share class to the pool\n    function addShareClass(PoolId poolId, string calldata name, string calldata symbol, bytes32 salt)\n        external\n        payable\n        returns (ShareClassId scId);\n\n    /// @notice Approves an asset amount of all deposit requests for the given triplet of pool id, share class id and\n    /// deposit asset id.\n    /// @param scId Identifier of the share class\n    /// @param depositAssetId Identifier of the asset locked for the deposit request\n    /// @param nowDepositEpochId The epoch for which deposits will be approved.\n    /// @param approvedAssetAmount Ampunt of assets that will be approved\n    function approveDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowDepositEpochId,\n        uint128 approvedAssetAmount\n    ) external payable returns (uint128 pendingAssetAmount, uint128 approvedPoolAmount);\n\n    /// @notice Approves a percentage of all redemption requests for the given triplet of pool id, share class id and\n    /// deposit asset id.\n    /// @param scId Identifier of the share class\n    /// @param payoutAssetId Identifier of the asset for which all requests want to exchange their share class tokens\n    /// @param nowRedeemEpochId The epoch for which redemptions will be approved.\n    /// @param approvedShareAmount Amount of shares that will be approved\n    function approveRedeems(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRedeemEpochId,\n        uint128 approvedShareAmount\n    ) external payable returns (uint128 pendingShareAmount);\n\n    /// @notice Emits new shares for the given identifier based on the provided NAV per share.\n    /// @param depositAssetId Identifier of the deposit asset for which shares should be issued\n    /// @param nowIssueEpochId The epoch for which shares will be issued.\n    /// @param navPoolPerShare Total value of assets of the share class per share\n    function issueShares(\n        PoolId poolId,\n        ShareClassId id,\n        AssetId depositAssetId,\n        uint32 nowIssueEpochId,\n        D18 navPoolPerShare\n    ) external payable returns (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount);\n\n    /// @notice Take back shares for the given identifier based on the provided NAV per share.\n    /// deposit asset id.\n    /// @param payoutAssetId Identifier of the asset for which all requests want to exchange their share class tokens\n    /// @param nowRevokeEpochId The epoch for which shares will be issued.\n    /// @param navPoolPerShare Total value of assets of the share class per share\n    function revokeShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRevokeEpochId,\n        D18 navPoolPerShare\n    ) external payable returns (uint128 revokedShareAmount, uint128 payoutAssetAmount, uint128 payoutPoolAmount);\n\n    /// @notice Tells the BalanceSheet to issue/revoke shares.\n    function triggerIssueShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, address who, uint128 shares)\n        external\n        payable;\n\n    /// @notice Tell the BalanceSheet to send a message back with the queued issued/revoked shares.\n    function triggerSubmitQueuedShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId) external payable;\n\n    /// @notice  Tell the BalanceSheet to send a message back with the queued deposits/withdrawals.\n    /// @param assetId Identifier of the asset which has queued deposits/withdrawals\n    function triggerSubmitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) external payable;\n\n    /// @notice Tell the BalanceSheet to enable or disable the shares queue.\n    function setQueue(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bool enabled) external payable;\n\n    /// @notice Update remotely a restriction.\n    /// @param centrifugeId Chain where CV instance lives.\n    /// @param payload content of the restriction update to execute.\n    function updateRestriction(PoolId poolId, ShareClassId scId, uint16 centrifugeId, bytes calldata payload)\n        external\n        payable;\n\n    /// @notice Update remotely an existing vault.\n    /// @param centrifugeId Chain where CV instance lives.\n    /// @param target contract where to execute in CV. Check IUpdateContract interface.\n    /// @param payload content of the update to execute.\n    function updateContract(\n        PoolId poolId,\n        ShareClassId scId,\n        uint16 centrifugeId,\n        bytes32 target,\n        bytes calldata payload\n    ) external payable;\n\n    /// @notice Update the price per share of a share class\n    /// @param scId The share class identifier\n    /// @param pricePoolPerShare The new price per share\n    function updatePricePerShare(PoolId poolId, ShareClassId scId, D18 pricePoolPerShare) external payable;\n\n    /// @notice Create a new holding associated to the asset in a share class.\n    /// It will register the different accounts used for holdings.\n    /// The accounts have to be created beforehand.\n    /// The same account can be used for different kinds.\n    /// e.g.: The equity, gain, and loss account can be the same account.\n    /// They can also be shared across assets.\n    /// e.g.: All assets can use the same equity account.\n    /// @param valuation Used to transform between payment assets and pool currency\n    /// @param assetAccount Used to track the asset value\n    /// @param equityAccount Used to track the equity value\n    /// @param gainAccount Used to track the gain value\n    /// @param lossAccount Used to track the loss value\n    function createHolding(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        AccountId assetAccount,\n        AccountId equityAccount,\n        AccountId gainAccount,\n        AccountId lossAccount\n    ) external payable;\n\n    /// @notice Create a new liablity associated to the asset in a share class.\n    /// It will register the different accounts used for holdings.\n    /// The accounts have to be created beforehand.\n    /// @param valuation Used to transform between the holding asset and pool currency\n    /// @param expenseAccount Used to track the expense value\n    /// @param liabilityAccount Used to track the liability value\n    function createLiability(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        IERC7726 valuation,\n        AccountId expenseAccount,\n        AccountId liabilityAccount\n    ) external payable;\n\n    /// @notice Updates the pool currency value of this holding based of the associated valuation.\n    function updateHoldingValue(PoolId poolId, ShareClassId scId, AssetId assetId) external payable;\n\n    /// @notice Updates the valuation used by a holding\n    /// @param valuation Used to transform between the holding asset and pool currency\n    function updateHoldingValuation(PoolId poolId, ShareClassId scId, AssetId assetId, IERC7726 valuation)\n        external\n        payable;\n\n    /// @notice Set an account of a holding\n    function setHoldingAccountId(PoolId poolId, ShareClassId scId, AssetId assetId, uint8 kind, AccountId accountId)\n        external\n        payable;\n\n    /// @notice Creates an account\n    /// @param accountId Then new AccountId used\n    /// @param isDebitNormal Determines if the account should be used as debit-normal or credit-normal\n    function createAccount(PoolId poolId, AccountId accountId, bool isDebitNormal) external payable;\n\n    /// @notice Attach custom data to an account\n    function setAccountMetadata(PoolId poolId, AccountId account, bytes calldata metadata) external payable;\n\n    /// @notice Perform an accounting entries update.\n    function updateJournal(PoolId poolId, JournalEntry[] memory debits, JournalEntry[] memory credits) external;\n}\n"
    },
    "src/hub/interfaces/IHubRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IERC6909Decimals} from \"src/misc/interfaces/IERC6909.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\n\ninterface IHubRegistry is IERC6909Decimals {\n    event NewAsset(AssetId indexed assetId, uint8 decimals);\n    event NewPool(PoolId poolId, address indexed manager, AssetId indexed currency);\n    event UpdateManager(PoolId indexed poolId, address indexed manager, bool canManage);\n    event SetMetadata(PoolId indexed poolId, bytes metadata);\n    event UpdateDependency(bytes32 indexed what, address dependency);\n    event UpdateCurrency(PoolId indexed poolId, AssetId currency);\n\n    error NonExistingPool(PoolId id);\n    error AssetAlreadyRegistered();\n    error PoolAlreadyRegistered();\n    error EmptyAccount();\n    error EmptyCurrency();\n    error EmptyShareClassManager();\n    error AssetNotFound();\n\n    /// @notice Register a new asset.\n    function registerAsset(AssetId assetId, uint8 decimals_) external;\n\n    /// @notice Register a new pool.\n    function registerPool(PoolId poolId, address manager, AssetId currency) external;\n\n    /// @notice allow/disallow an address as a manager for the pool\n    function updateManager(PoolId poolId, address newManager, bool canManage) external;\n\n    /// @notice sets metadata for this pool\n    function setMetadata(PoolId poolId, bytes calldata metadata) external;\n\n    /// @notice updates a dependency of the system\n    function updateDependency(bytes32 what, address dependency) external;\n\n    /// @notice updates the currency of the pool\n    function updateCurrency(PoolId poolId, AssetId currency) external;\n\n    /// @notice returns the metadata attached to the pool, if any.\n    function metadata(PoolId poolId) external view returns (bytes memory);\n\n    /// @notice returns the currency of the pool\n    function currency(PoolId poolId) external view returns (AssetId);\n\n    /// @notice returns the dependency used in the system\n    function dependency(bytes32 what) external view returns (address);\n\n    /// @notice returns whether the account is a manager\n    function manager(PoolId poolId, address who) external view returns (bool);\n\n    /// @notice compute a pool ID given an ID postfix\n    function poolId(uint16 centrifugeId, uint48 postfix) external view returns (PoolId poolId);\n\n    /// @notice returns the decimals for an asset\n    function decimals(AssetId assetId) external view returns (uint8);\n\n    /// @notice returns the decimals for a pool\n    function decimals(PoolId poolId) external view returns (uint8);\n\n    /// @notice checks the existence of a pool\n    function exists(PoolId poolId) external view returns (bool);\n\n    /// @notice checks the existence of an asset\n    function isRegistered(AssetId assetId) external view returns (bool);\n}\n"
    },
    "src/hub/interfaces/IShareClassManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {D18} from \"src/misc/types/D18.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nstruct EpochRedeemAmounts {\n    /// @dev Amount of shares pending to be redeemed at time of epoch\n    uint128 pendingShareAmount;\n    /// @dev Total approved amount of redeemed share class tokens\n    uint128 approvedShareAmount;\n    /// @dev Total asset amount of revoked share class tokens\n    uint128 payoutAssetAmount;\n    /// @dev The amount of pool currency per unit of asset at time of approval\n    D18 pricePoolPerAsset;\n    /// @dev The amount of pool currency per unit of share at time of revocation\n    D18 navPoolPerShare;\n    /// @dev block timestamp when shares of epoch were revoked\n    uint64 revokedAt;\n}\n\nstruct EpochInvestAmounts {\n    /// @dev Total pending asset amount of deposit asset at time of epoch\n    uint128 pendingAssetAmount;\n    /// @dev Total approved asset amount of deposit asset\n    uint128 approvedAssetAmount;\n    /// @dev Total approved pool amount of deposit asset\n    uint128 approvedPoolAmount;\n    /// @dev The amount of pool currency per unit of asset at time of approval\n    D18 pricePoolPerAsset;\n    /// @dev The amount of pool currency per unit of share at time of issuance\n    D18 navPoolPerShare;\n    /// @dev block timestamp when shares of epoch were issued\n    uint64 issuedAt;\n}\n\nstruct UserOrder {\n    /// @dev Pending amount in deposit asset denomination\n    uint128 pending;\n    /// @dev Index of epoch in which last order was made\n    uint32 lastUpdate;\n}\n\nstruct ShareClassMetadata {\n    /// @dev The name of the share class token\n    string name;\n    /// @dev The symbol of the share class token\n    string symbol;\n    /// @dev The salt of the share class token\n    bytes32 salt;\n}\n\nstruct ShareClassMetrics {\n    /// @dev Total number of shares\n    uint128 totalIssuance;\n    /// @dev The latest net asset value per share class token\n    D18 navPerShare;\n}\n\nstruct QueuedOrder {\n    /// @dev Whether the user requested a cancellation which is now queued\n    bool isCancelling;\n    /// @dev The queued increased request amount\n    uint128 amount;\n}\n\nenum RequestType {\n    /// @dev Whether the request is a deposit one\n    Deposit,\n    /// @dev Whether the request is a redeem one\n    Redeem\n}\n\nstruct EpochId {\n    uint32 deposit;\n    uint32 redeem;\n    uint32 issue;\n    uint32 revoke;\n}\n\ninterface IShareClassManager {\n    /// Events\n    event AddShareClass(\n        PoolId indexed poolId, ShareClassId indexed scId, uint32 indexed index, string name, string symbol, bytes32 salt\n    );\n    event UpdateMetadata(PoolId indexed poolId, ShareClassId indexed scId, string name, string symbol);\n    event ApproveDeposits(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        AssetId indexed depositAssetId,\n        uint32 epoch,\n        uint128 approvedPoolAmount,\n        uint128 approvedAssetAmount,\n        uint128 pendingAssetAmount\n    );\n    event ApproveRedeems(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        AssetId indexed payoutAssetId,\n        uint32 epoch,\n        uint128 approvedShareAmount,\n        uint128 pendingShareAmount\n    );\n    event IssueShares(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        AssetId indexed depositAssetId,\n        uint32 epoch,\n        D18 navPoolPerShare,\n        D18 navAssetPerShare,\n        uint128 issuedShareAmount\n    );\n    event RemoteIssueShares(PoolId indexed poolId, ShareClassId indexed scId, uint128 issuedShareAmount);\n    event RevokeShares(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        AssetId indexed payoutAssetId,\n        uint32 epoch,\n        D18 navPoolPerShare,\n        D18 navAssetPerShare,\n        uint128 revokedShareAmount,\n        uint128 revokedAssetAmount,\n        uint128 revokedPoolAmount\n    );\n    event RemoteRevokeShares(PoolId indexed poolId, ShareClassId indexed scId, uint128 revokedAssetAmount);\n    event ClaimDeposit(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        uint32 epoch,\n        bytes32 investor,\n        AssetId indexed depositAssetId,\n        uint128 paymentAssetAmount,\n        uint128 pendingAssetAmount,\n        uint128 claimedShareAmount,\n        uint64 issuedAt\n    );\n    event ClaimRedeem(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        uint32 epoch,\n        bytes32 investor,\n        AssetId indexed payoutAssetId,\n        uint128 paymentShareAmount,\n        uint128 pendingShareAmount,\n        uint128 claimedAssetAmount,\n        uint64 revokedAt\n    );\n    event AddShareClass(PoolId indexed poolId, ShareClassId indexed scId, uint32 indexed index);\n    event UpdateShareClass(PoolId indexed poolId, ShareClassId indexed scId, D18 navPoolPerShare);\n    event UpdateDepositRequest(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        AssetId indexed depositAssetId,\n        uint32 epoch,\n        bytes32 investor,\n        uint128 pendingUserAssetAmount,\n        uint128 pendingTotalAssetAmount,\n        uint128 queuedUserAssetAmount,\n        bool pendingCancellation\n    );\n    event UpdateRedeemRequest(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        AssetId indexed payoutAssetId,\n        uint32 epoch,\n        bytes32 investor,\n        uint128 pendingUserShareAmount,\n        uint128 pendingTotalShareAmount,\n        uint128 queuedUserShareAmount,\n        bool pendingCancellation\n    );\n\n    /// Errors\n    error EpochNotInSequence(uint32 providedEpoch, uint32 nowEpoch);\n    error NoOrderFound();\n    error InsufficientPending();\n    error ApprovalRequired();\n    error IssuanceRequired();\n    error AlreadyIssued();\n    error RevocationRequired();\n    error ZeroApprovalAmount();\n    error InvalidMetadataSize();\n    error InvalidMetadataName();\n    error InvalidMetadataSymbol();\n    error InvalidSalt();\n    error AlreadyUsedSalt();\n    error RevokeMoreThanIssued();\n    error PoolMissing();\n    error ShareClassNotFound();\n    error EpochNotFound();\n    error DecreaseMoreThanIssued();\n    error CancellationQueued();\n\n    /// Functions\n\n    /// @notice Creates or updates a request to deposit (exchange) an asset amount for share class tokens.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param amount Asset token amount which is deposited\n    /// @param investor Centrifuge Vault address of the entity which is depositing\n    /// @param depositAssetId Identifier of the asset which the investor used for their deposit request\n    function requestDeposit(PoolId poolId, ShareClassId scId, uint128 amount, bytes32 investor, AssetId depositAssetId)\n        external;\n\n    /// @notice Cancels a pending deposit request.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param investor Centrifuge Vault address of the entity which is cancelling\n    /// @param depositAssetId Identifier of the asset which the investor used for their deposit request\n    /// @return cancelledAssetAmount The deposit amount which was previously pending and is now cancelled. This amount\n    /// was not potentially (partially) swapped to the pool amount in case the deposit asset cannot be exchanged 1:1\n    /// into the pool token\n    function cancelDepositRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external\n        returns (uint128 cancelledAssetAmount);\n\n    /// @notice Creates or updates a request to redeem (exchange) share class tokens for some asset.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param amount Share class token amount which should be redeemed\n    /// @param investor Centrifuge Vault address of the entity which is redeeming\n    /// @param payoutAssetId Identifier of the asset which the investor eventually receives back for their redeemed\n    /// share class tokens\n    function requestRedeem(PoolId poolId, ShareClassId scId, uint128 amount, bytes32 investor, AssetId payoutAssetId)\n        external;\n\n    /// @notice Cancels a pending redeem request.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param investor Centrifuge Vault address of the entity which is cancelling\n    /// @param payoutAssetId Identifier of the asset which the investor eventually receives back for their redeemed\n    /// share class tokens\n    /// @return cancelledShareAmount The redeem amount which was previously pending and is now cancelled\n    function cancelRedeemRequest(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId)\n        external\n        returns (uint128 cancelledShareAmount);\n\n    /// @notice Approves an asset amount of all deposit requests for the given triplet of pool id, share class id and\n    /// deposit asset id.\n    /// @dev nowDepositEpochId MUST be called sequentially.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param depositAssetId Identifier of the asset locked for the deposit request\n    /// @param nowDepositEpochId The epoch for which shares will be approved.\n    /// @param approvedAssetAmount Amount of assets that will be approved for deposit\n    /// @param pricePoolPerAsset Amount of pool unit one gets for a unit of asset\n    /// @return pendingAssetAmount Amount of assets still pending for deposit\n    /// @return approvedPoolAmount  Amount of pool units approved for deposit\n    function approveDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowDepositEpochId,\n        uint128 approvedAssetAmount,\n        D18 pricePoolPerAsset\n    ) external returns (uint128 pendingAssetAmount, uint128 approvedPoolAmount);\n\n    /// @notice Approves a share class token amount of all redeem requests for the given triplet of pool id, share class\n    /// id and payout asset id.\n    /// @dev nowRedeemEpochId MUST be called sequentially.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param payoutAssetId Identifier of the asset for which all requests want to exchange their share class tokens\n    /// for\n    /// @param nowRedeemEpochId The epoch for which shares will be approved.\n    /// @param approvedShareAmount Amount of shares that will be approved for redemption\n    /// @param pricePoolPerAsset Amount of pool unit one gets for a unit of asset\n    /// @return pendingShareAmount Sum of redemption request amounts in share class token amount which was not approved\n    function approveRedeems(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRedeemEpochId,\n        uint128 approvedShareAmount,\n        D18 pricePoolPerAsset\n    ) external returns (uint128 pendingShareAmount);\n\n    /// @notice Emits new shares for the given identifier based on the provided NAV per share.\n    /// @dev nowIssueEpochId MUST be called sequentially.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param depositAssetId Identifier of the deposit asset for which shares should be issued\n    /// @param nowIssueEpochId The epoch for which shares will be issued.\n    /// @param navPoolPerShare The nav per share value of the share class (in the pool currency denomination. Conversion\n    /// to asset price is done onchain based on the valuation of the asset at approval)\n    /// @return issuedShareAmount Amount of shares that have been issued\n    function issueShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId depositAssetId,\n        uint32 nowIssueEpochId,\n        D18 navPoolPerShare\n    ) external returns (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount);\n\n    /// @notice Take back shares for the given identifier based on the provided NAV per share.\n    /// @dev nowRevokeEpochId MUST be called sequentially.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param payoutAssetId Identifier of the payout asset\n    /// @param nowRevokeEpochId The epoch for which shares will be revoked.\n    /// @param navPoolPerShare The nav per share value of the share class (in the pool currency denomination. Conversion\n    /// to asset price is done onchain based on the valuation of the asset at approval)\n    /// @return revokedShareAmount Amount of shares that have been revoked\n    /// @return payoutAssetAmount Converted amount of payout asset based on number of revoked shares\n    /// @return payoutPoolAmount Converted amount of pool currency based on number of revoked shares\n    function revokeShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId payoutAssetId,\n        uint32 nowRevokeEpochId,\n        D18 navPoolPerShare\n    ) external returns (uint128 revokedShareAmount, uint128 payoutAssetAmount, uint128 payoutPoolAmount);\n\n    /// @notice Collects shares for an investor after their deposit request was (partially) approved and new shares were\n    /// issued.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param investor Centrifuge Vault address of the recipient of the claimed share class tokens\n    /// @param depositAssetId Identifier of the asset which the investor used for their deposit request\n    /// @return payoutShareAmount Amount of shares which the investor receives\n    /// @return paymentAssetAmount Amount of deposit asset which was taken as payment\n    /// @return cancelledAssetAmount Amount of deposit asset which was cancelled due to being queued\n    /// @return canClaimAgain Whether another call to claimRedeem is needed until investor has fully claimed investments\n    function claimDeposit(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external\n        returns (\n            uint128 payoutShareAmount,\n            uint128 paymentAssetAmount,\n            uint128 cancelledAssetAmount,\n            bool canClaimAgain\n        );\n\n    /// @notice Collects an asset amount for an investor after their redeem request was (partially) approved and shares\n    /// were revoked.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param investor Centrifuge Vault address of the recipient of the claimed asset amount\n    /// @param payoutAssetId Identifier of the asset which the investor requested to receive back for their redeemed\n    /// shares\n    /// @return payoutAssetAmount Amount of payout amount which the investor receives\n    /// @return paymentShareAmount Amount of shares which the investor redeemed\n    /// @return cancelledShareAmount Amount of shares which were cancelled due to being queued\n    /// @return canClaimAgain Whether another call to claimRedeem is needed until investor has fully claimed redemptions\n    function claimRedeem(PoolId poolId, ShareClassId scId, bytes32 investor, AssetId payoutAssetId)\n        external\n        returns (\n            uint128 payoutAssetAmount,\n            uint128 paymentShareAmount,\n            uint128 cancelledShareAmount,\n            bool canClaimAgain\n        );\n\n    /// @notice Increases the share class issuance\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param amount The amount to increase the share class issuance by\n    function increaseShareClassIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external;\n\n    /// @notice Decreases the share class issuance\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param amount The amount to decrease the share class issuance by\n    function decreaseShareClassIssuance(PoolId poolId, ShareClassId scId, uint128 amount) external;\n\n    /// @notice Adds a new share class to the given pool.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param name The name of the share class\n    /// @param symbol The symbol of the share class\n    /// @param salt The salt used for deploying the share class tokens\n    /// @return scId Identifier of the newly added share class\n    function addShareClass(PoolId poolId, string calldata name, string calldata symbol, bytes32 salt)\n        external\n        returns (ShareClassId scId);\n\n    /// @notice Updates the price pool unit per share unit of a share class\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param pricePoolPerShare The price per share of the share class (in the pool currency denomination)\n    function updatePricePerShare(PoolId poolId, ShareClassId scId, D18 pricePoolPerShare) external;\n\n    /// @notice Updates the metadata of a share class.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    /// @param name The name of the share class\n    /// @param symbol The symbol of the share class\n    function updateMetadata(PoolId poolId, ShareClassId scId, string calldata name, string calldata symbol) external;\n\n    /// @notice Returns the number of share classes for the given pool\n    ///\n    /// @param poolId Identifier of the pool in question\n    /// @return count Number of share classes for the given pool\n    function shareClassCount(PoolId poolId) external view returns (uint32 count);\n\n    /// @notice Checks the existence of a share class.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param scId Identifier of the share class\n    function exists(PoolId poolId, ShareClassId scId) external view returns (bool);\n\n    /// @notice Returns the current ongoing epoch id for deposits\n    ///\n    /// @param scId Identifier of the share class\n    /// @param depositAssetId AssetId of the payment asset\n    function nowDepositEpoch(ShareClassId scId, AssetId depositAssetId) external view returns (uint32);\n\n    /// @notice Returns the epoch for which will be issued next\n    ///\n    /// @param scId Identifier of the share class\n    /// @param depositAssetId AssetId of the payment asset\n    function nowIssueEpoch(ShareClassId scId, AssetId depositAssetId) external view returns (uint32);\n\n    /// @notice Returns the current ongoing epoch id for deposits\n    ///\n    /// @param scId Identifier of the share class\n    /// @param payoutAssetId AssetId of the payment asset\n    function nowRedeemEpoch(ShareClassId scId, AssetId payoutAssetId) external view returns (uint32);\n\n    /// @notice Returns the epoch for which will be revoked next\n    ///\n    /// @param scId Identifier of the share class\n    /// @param depositAssetId AssetId of the payment asset\n    function nowRevokeEpoch(ShareClassId scId, AssetId depositAssetId) external view returns (uint32);\n\n    /// @notice Returns an upper bound for possible calls to `function claimDeposit(..)`\n    ///\n    /// @param scId Identifier of the share class\n    /// @param investor Recipient of the share class tokens\n    /// @param depositAssetId AssetId of the payment asset\n    function maxDepositClaims(ShareClassId scId, bytes32 investor, AssetId depositAssetId)\n        external\n        view\n        returns (uint32 maxClaims);\n\n    /// @notice Returns an upper bound for possible calls to `function claimRedeem(..)`\n    ///\n    /// @param scId Identifier of the share class\n    /// @param investor Recipient of the payout assets\n    /// @param payoutAssetId AssetId of the payout asset\n    function maxRedeemClaims(ShareClassId scId, bytes32 investor, AssetId payoutAssetId)\n        external\n        view\n        returns (uint32 maxClaims);\n\n    /// @notice Exposes relevant metrics for a share class\n    ///\n    /// @return totalIssuance The total number of shares known to the CP side\n    /// @return pricePoolPerShare The amount of pool units per unit share\n    function metrics(ShareClassId scId) external view returns (uint128 totalIssuance, D18 pricePoolPerShare);\n\n    /// @notice Determines the next share class id for the given pool.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @return scId Identifier of the next share class\n    function previewNextShareClassId(PoolId poolId) external view returns (ShareClassId scId);\n\n    /// @notice Determines the share class id for the given pool and index.\n    ///\n    /// @param poolId Identifier of the pool\n    /// @param index The pool-internal index of the share class id\n    /// @return scId Identifier of the underlying share class\n    function previewShareClassId(PoolId poolId, uint32 index) external pure returns (ShareClassId scId);\n\n    /// @notice returns The metadata of the share class.\n    ///\n    /// @param scId Identifier of the share class\n    /// @return name The registered name of the share class token\n    /// @return symbol The registered symbol of the share class token\n    /// @return salt The registered salt of the share class token, used for deterministic deployments\n    function metadata(ShareClassId scId) external returns (string memory name, string memory symbol, bytes32 salt);\n}\n"
    },
    "src/misc/Auth.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\n/// @title  Auth\n/// @notice Simple authentication pattern\n/// @author Based on code from https://github.com/makerdao/dss\nabstract contract Auth is IAuth {\n    /// @inheritdoc IAuth\n    mapping(address => uint256) public wards;\n\n    constructor(address initialWard) {\n        wards[initialWard] = 1;\n        emit Rely(initialWard);\n    }\n\n    /// @dev Check if the msg.sender has permissions\n    modifier auth() {\n        require(wards[msg.sender] == 1, NotAuthorized());\n        _;\n    }\n\n    /// @inheritdoc IAuth\n    function rely(address user) public auth {\n        wards[user] = 1;\n        emit Rely(user);\n    }\n\n    /// @inheritdoc IAuth\n    function deny(address user) public auth {\n        wards[user] = 0;\n        emit Deny(user);\n    }\n}\n"
    },
    "src/misc/BaseValuation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IBaseValuation} from \"src/misc/interfaces/IBaseValuation.sol\";\nimport {IERC6909Decimals} from \"src/misc/interfaces/IERC6909.sol\";\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nabstract contract BaseValuation is Auth, IBaseValuation {\n    /// @notice ERC6909 dependency.\n    IERC6909Decimals public erc6909;\n\n    constructor(IERC6909Decimals erc6909_, address deployer) Auth(deployer) {\n        erc6909 = erc6909_;\n    }\n\n    /// @inheritdoc IBaseValuation\n    function file(bytes32 what, address data) external auth {\n        if (what == \"erc6909\") erc6909 = IERC6909Decimals(data);\n        else revert FileUnrecognizedParam();\n\n        emit File(what, data);\n    }\n\n    /// @notice Obtain the correct decimals given an asset address\n    function _getDecimals(address asset) internal view returns (uint8) {\n        return erc6909.decimals(uint160(asset));\n    }\n}\n"
    },
    "src/misc/ERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {EIP712Lib} from \"src/misc/libraries/EIP712Lib.sol\";\nimport {SignatureLib} from \"src/misc/libraries/SignatureLib.sol\";\n\nimport {IERC20, IERC20Metadata, IERC20Permit} from \"src/misc/interfaces/IERC20.sol\";\n\n/// @title  ERC20\n/// @notice Standard ERC-20 implementation, with mint/burn functionality and permit logic.\n/// @author Modified from https://github.com/makerdao/xdomain-dss/blob/master/src/Dai.sol\ncontract ERC20 is Auth, IERC20Metadata, IERC20Permit {\n    error FileUnrecognizedParam();\n\n    /// @inheritdoc IERC20Metadata\n    string public name;\n    /// @inheritdoc IERC20Metadata\n    string public symbol;\n    /// @inheritdoc IERC20Metadata\n    uint8 public immutable decimals;\n    /// @inheritdoc IERC20\n    uint256 public totalSupply;\n\n    mapping(address => uint256) private balances;\n\n    /// @inheritdoc IERC20\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @inheritdoc IERC20Permit\n    mapping(address => uint256) public nonces;\n\n    // --- EIP712 ---\n    bytes32 private immutable nameHash;\n    bytes32 private immutable versionHash;\n    uint256 public immutable deploymentChainId;\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // --- Events ---\n    event File(bytes32 indexed what, string data);\n\n    constructor(uint8 decimals_) Auth(msg.sender) {\n        decimals = decimals_;\n\n        nameHash = keccak256(bytes(\"Centrifuge\"));\n        versionHash = keccak256(bytes(\"1\"));\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\n    }\n\n    function _balanceOf(address user) internal view virtual returns (uint256) {\n        return balances[user];\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address user) public view virtual returns (uint256) {\n        return _balanceOf(user);\n    }\n\n    function _setBalance(address user, uint256 value) internal virtual {\n        balances[user] = value;\n    }\n\n    /// @inheritdoc IERC20Permit\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return block.chainid == deploymentChainId\n            ? _DOMAIN_SEPARATOR\n            : EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, string memory data) public virtual auth {\n        if (what == \"name\") name = data;\n        else if (what == \"symbol\") symbol = data;\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    // --- ERC20 Mutations ---\n    /// @inheritdoc IERC20\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), InvalidAddress());\n        uint256 balance = balanceOf(msg.sender);\n        require(balance >= value, InsufficientBalance());\n\n        unchecked {\n            _setBalance(msg.sender, balance - value);\n            // note: we don't need an overflow check here b/c sum of all balances == totalSupply\n            _setBalance(to, _balanceOf(to) + value);\n        }\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        return _transferFrom(msg.sender, from, to, value);\n    }\n\n    function _transferFrom(address sender, address from, address to, uint256 value) internal virtual returns (bool) {\n        require(to != address(0) && to != address(this), InvalidAddress());\n        uint256 balance = balanceOf(from);\n        require(balance >= value, InsufficientBalance());\n\n        if (from != sender) {\n            uint256 allowed = allowance[from][sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, InsufficientAllowance());\n                unchecked {\n                    allowance[from][sender] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            _setBalance(from, balance - value);\n            // note: we don't need an overflow check here b/c sum of all balances == totalSupply\n            _setBalance(to, _balanceOf(to) + value);\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function approve(address spender, uint256 value) external returns (bool) {\n        allowance[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n    }\n\n    // --- Mint/Burn ---\n    function mint(address to, uint256 value) public virtual auth {\n        require(to != address(0) && to != address(this), InvalidAddress());\n        unchecked {\n            // We don't need an overflow check here b/c balances[to] <= totalSupply\n            // and there is an overflow check below\n            _setBalance(to, _balanceOf(to) + value);\n        }\n        totalSupply += value;\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual auth {\n        uint256 balance = balanceOf(from);\n        require(balance >= value, InsufficientBalance());\n\n        if (from != msg.sender) {\n            uint256 allowed = allowance[from][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, InsufficientAllowance());\n\n                unchecked {\n                    allowance[from][msg.sender] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            // We don't need overflow checks b/c require(balance >= value) and balance <= totalSupply\n            _setBalance(from, balance - value);\n            totalSupply -= value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n\n    // --- Approve by signature ---\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) public {\n        require(block.timestamp <= deadline, PermitExpired());\n\n        uint256 nonce;\n        unchecked {\n            nonce = nonces[owner]++;\n        }\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))\n            )\n        );\n\n        require(SignatureLib.isValidSignature(owner, digest, signature), InvalidPermit());\n\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /// @inheritdoc IERC20Permit\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n    {\n        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));\n    }\n}\n"
    },
    "src/misc/IdentityValuation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {d18} from \"src/misc/types/D18.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {IIdentityValuation} from \"src/misc/interfaces/IIdentityValuation.sol\";\nimport {IERC6909Decimals} from \"src/misc/interfaces/IERC6909.sol\";\nimport {BaseValuation} from \"src/misc/BaseValuation.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\ncontract IdentityValuation is BaseValuation, IIdentityValuation {\n    constructor(IERC6909Decimals erc6909, address deployer) BaseValuation(erc6909, deployer) {}\n\n    /// @inheritdoc IERC7726\n    function getQuote(uint256 baseAmount, address base, address quote) external view returns (uint256 quoteAmount) {\n        return PricingLib.convertWithPrice(baseAmount, _getDecimals(base), _getDecimals(quote), d18(1e18));\n    }\n}\n"
    },
    "src/misc/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n// NOTE: This file has warning disabled due https://github.com/ethereum/solidity/issues/14359\n// If perform any change on it, please ensure no other warnings appears\n\nimport {IMulticall} from \"src/misc/interfaces/IMulticall.sol\";\nimport {ReentrancyProtection} from \"src/misc/ReentrancyProtection.sol\";\n\nabstract contract Multicall is ReentrancyProtection, IMulticall {\n    function multicall(bytes[] calldata data) public payable virtual protected {\n        uint256 totalBytes = data.length;\n        for (uint256 i; i < totalBytes; ++i) {\n            (bool success, bytes memory returnData) = address(this).delegatecall(data[i]);\n            if (!success) {\n                uint256 length = returnData.length;\n                require(length != 0, CallFailedWithEmptyRevert());\n\n                assembly (\"memory-safe\") {\n                    revert(add(32, returnData), length)\n                }\n            }\n        }\n    }\n}\n"
    },
    "src/misc/Recoverable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {IERC6909} from \"src/misc/interfaces/IERC6909.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\n\nimport {IRecoverable, ETH_ADDRESS} from \"src/misc/interfaces/IRecoverable.sol\";\n\nabstract contract Recoverable is Auth, IRecoverable {\n    /// @inheritdoc IRecoverable\n    function recoverTokens(address token, address receiver, uint256 amount) public auth {\n        if (token == ETH_ADDRESS) {\n            SafeTransferLib.safeTransferETH(receiver, amount);\n        } else {\n            SafeTransferLib.safeTransfer(token, receiver, amount);\n        }\n    }\n\n    /// @inheritdoc IRecoverable\n    function recoverTokens(address token, uint256 tokenId, address receiver, uint256 amount) external auth {\n        if (tokenId == 0) {\n            recoverTokens(token, receiver, amount);\n        } else {\n            IERC6909(token).transfer(receiver, tokenId, amount);\n        }\n    }\n}\n"
    },
    "src/misc/ReentrancyProtection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n// NOTE: This file has warning disabled due https://github.com/ethereum/solidity/issues/14359\n// If perform any change on it, please ensure no other warnings appears\n\nabstract contract ReentrancyProtection {\n    /// @notice Dispatched when there is a re-entrancy issue\n    error UnauthorizedSender();\n\n    address private transient _initiator;\n\n    /// @dev The method is protected for reentrancy issues.\n    modifier protected() {\n        if (_initiator == address(0)) {\n            // Single call re-entrancy lock\n            _initiator = msg.sender;\n            _;\n            _initiator = address(0);\n        } else {\n            // Multicall re-entrancy lock\n            require(msg.sender == _initiator, UnauthorizedSender());\n            _;\n        }\n    }\n}\n"
    },
    "src/misc/interfaces/IAuth.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\ninterface IAuth {\n    event Rely(address indexed user);\n    event Deny(address indexed user);\n\n    error NotAuthorized();\n\n    /// @notice Returns whether the target is a ward (has admin access)\n    function wards(address target) external view returns (uint256);\n\n    /// @notice Make user a ward (give them admin access)\n    function rely(address user) external;\n\n    /// @notice Remove user as a ward (remove admin access)\n    function deny(address user) external;\n}\n"
    },
    "src/misc/interfaces/IBaseValuation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\n\n/// Provides a base implementation for all ERC7726 valuation in the system\ninterface IBaseValuation is IERC7726 {\n    /// @notice Emitted when a call to `file()` was performed.\n    event File(bytes32 indexed what, address addr);\n\n    /// @notice Dispatched when the `what` parameter of `file()` is not supported by the implementation.\n    error FileUnrecognizedParam();\n\n    /// @notice Updates a contract parameter.\n    /// @param what Name of the parameter to update.\n    /// Accepts a `bytes32` representation of 'assetRegistry' string value.\n    /// @param data New value given to the `what` parameter\n    function file(bytes32 what, address data) external;\n}\n"
    },
    "src/misc/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/// @title  IERC20\n/// @dev    Interface of the ERC20 standard as defined in the EIP.\n/// @author Modified from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\ninterface IERC20 {\n    error InvalidAddress();\n    error InsufficientBalance();\n    error InsufficientAllowance();\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    error PermitExpired();\n    error InvalidPermit();\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface IERC20Wrapper {\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() external view returns (address);\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 value) external returns (bool);\n\n    /**\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 value) external returns (bool);\n}\n"
    },
    "src/misc/interfaces/IERC6909.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IERC165} from \"forge-std/interfaces/IERC165.sol\";\n\ninterface IERC6909 is IERC165 {\n    error EmptyOwner();\n    error EmptyAmount();\n    error InvalidTokenId();\n    error InsufficientBalance(address owner, uint256 tokenId);\n    error InsufficientAllowance(address sender, uint256 tokenId);\n\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId, uint256 amount);\n    event Transfer(address caller, address indexed from, address indexed to, uint256 indexed tokenId, uint256 amount);\n\n    /// @notice           Owner balance of a tokenId.\n    /// @param owner      The address of the owner.\n    /// @param tokenId    The id of the token.\n    /// @return amount    The balance of the token.\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256 amount);\n\n    /// @notice           Spender allowance of a tokenId.\n    /// @param owner      The address of the owner.\n    /// @param spender    The address of the spender.\n    /// @param tokenId    The id of the token.\n    /// @return amount    The allowance of the token.\n    function allowance(address owner, address spender, uint256 tokenId) external view returns (uint256 amount);\n\n    /// @notice           Checks if a spender is approved by an owner as an operator.\n    /// @param owner      The address of the owner.\n    /// @param spender    The address of the spender.\n    /// @return approved  The approval status.\n    function isOperator(address owner, address spender) external view returns (bool approved);\n\n    /// @notice           Transfers an amount of a tokenId from the caller to a receiver.\n    /// @param receiver   The address of the receiver.\n    /// @param tokenId    The id of the token.\n    /// @param amount     The amount of the token.\n    /// @return bool      True, always, unless the function reverts.\n    function transfer(address receiver, uint256 tokenId, uint256 amount) external returns (bool);\n\n    /// @notice           Transfers an amount of a tokenId from a sender to a receiver.\n    /// @param sender     The address of the sender.\n    /// @param receiver   The address of the receiver.\n    /// @param tokenId    The id of the token.\n    /// @param amount     The amount of the token.\n    /// @return bool      True, always, unless the function reverts.\n    function transferFrom(address sender, address receiver, uint256 tokenId, uint256 amount) external returns (bool);\n\n    /// @notice           Approves an amount of a tokenId to a spender.\n    /// @param spender    The address of the spender.\n    /// @param tokenId    The id of the token.\n    /// @param amount     The amount of the token.\n    /// @return bool      True, always.\n    function approve(address spender, uint256 tokenId, uint256 amount) external returns (bool);\n\n    /// @notice           Sets or removes an operator for the caller.\n    /// @param operator   The address of the operator.\n    /// @param approved   The approval status.\n    /// @return bool      True, always.\n    function setOperator(address operator, bool approved) external returns (bool);\n}\n\ninterface IERC6909URIExt {\n    event TokenURISet(uint256 indexed tokenId, string uri);\n    event ContractURISet(address indexed target, string uri);\n\n    error EmptyURI();\n\n    /// @return uri     Returns the common token URI.\n    function contractURI() external view returns (string memory);\n\n    /// @dev            Returns empty string if tokenId does not exist.\n    ///                 MAY implemented to throw MissingURI(tokenId) error.\n    /// @param tokenId  The token to query URI for.\n    /// @return uri     A string representing the uri for the specific tokenId.\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC6909NFT is IERC6909, IERC6909URIExt {\n    error UnknownTokenId(address owner, uint256 tokenId);\n    error LessThanMinimalDecimal(uint8 minimal, uint8 actual);\n\n    /// @notice             Provide URI for a specific tokenId.\n    /// @param tokenId      Token Id.\n    /// @param URI          URI to a document defining the collection as a whole.\n    function setTokenURI(uint256 tokenId, string memory URI) external;\n\n    /// @dev                Optional method to set up the contract URI if needed.\n    /// @param URI          URI to a document defining the collection as a whole.\n    function setContractURI(string memory URI) external;\n\n    /// @notice             Mint new tokens for a given owner and sets tokenURI.\n    /// @dev                For non-fungible tokens, call with amount = 1, for fungible it could be any amount.\n    ///                     TokenId is auto incremented by one.\n    ///\n    /// @param owner        Creates supply of a given tokenId by amount for owner.\n    /// @param tokenURI     URI fortestBurningToken the newly minted token.\n    /// @return tokenId     Id of the newly minted token.\n    function mint(address owner, string memory tokenURI) external returns (uint256 tokenId);\n\n    /// @notice             Destroy supply of a given tokenId by amount.\n    /// @dev                The msg.sender MUST be the owner.\n    ///\n    /// @param tokenId      Item which have reduced supply.\n    function burn(uint256 tokenId) external;\n}\n\n/// @notice Extension of ERC6909 Standard for tracking total supply\ninterface IERC6909TotalSupplyExt {\n    /// @notice         The totalSupply for a token id.\n    ///\n    /// @param tokenId  Id of the token\n    /// @return supply  Total supply for a given `tokenId`\n    function totalSupply(uint256 tokenId) external returns (uint256 supply);\n}\n\ninterface IERC6909Decimals {\n    /// @notice             Used to retrieve the decimals of an asset\n    /// @dev                address is used but the value corresponds to a AssetId\n    function decimals(uint256 assetId) external view returns (uint8);\n}\n\ninterface IERC6909MetadataExt is IERC6909Decimals {\n    /// @notice             Used to retrieve the decimals of an asset\n    /// @dev                address is used but the value corresponds to a AssetId\n    function decimals(uint256 assetId) external view returns (uint8);\n\n    /// @notice             Used to retrieve the name of an asset\n    /// @dev                address is used but the value corresponds to a AssetId\n    function name(uint256 assetId) external view returns (string memory);\n\n    /// @notice             Used to retrieve the symbol of an asset\n    /// @dev                address is used but the value corresponds to a AssetId\n    function symbol(uint256 assetId) external view returns (string memory);\n}\n\ninterface IERC6909Fungible is IERC6909 {\n    /// @notice             Mint new tokens for a specific tokenid and assign them to an owner\n    ///\n    /// @param owner        Creates supply of a given `tokenId` by `amount` for owner.\n    /// @param tokenId      Id of the item\n    /// @param amount       Adds `amount` to the total supply of the given `tokenId`\n    function mint(address owner, uint256 tokenId, uint256 amount) external;\n\n    /// @notice             Destroy supply of a given tokenId by amount.\n    /// @dev                The msg.sender MUST be the owner.\n    ///\n    /// @param owner        Owner of the `tokenId`\n    /// @param tokenId      Id of the item.\n    /// @param amount       Subtract `amount` from the total supply of the given `tokenId`\n    function burn(address owner, uint256 tokenId, uint256 amount) external;\n\n    /// @notice             Enforces a transfer from `spender` point of view.\n    ///\n    ///\n    /// @param sender       The owner of the `tokenId`\n    /// @param receiver     Address of the receiving party\n    /// @param tokenId      Token Id\n    /// @param amount       Amount to be transferred\n    function authTransferFrom(address sender, address receiver, uint256 tokenId, uint256 amount)\n        external\n        returns (bool);\n}\n\n/// @dev  A factory contract to deploy new collateral contracts implementing IERC6909.\ninterface IERC6909Factory {\n    /// Events\n    event NewTokenDeployment(address indexed owner, address instance);\n\n    /// @notice       Deploys new install of a contract that implements IERC6909.\n    /// @dev          Factory should deploy deterministically if possible.\n    ///\n    /// @param owner  Owner of the deployed collateral contract which has initial full rights.\n    /// @param salt   Used to make a deterministic deployment.\n    /// @return       An address of the newly deployed contract.\n    function deploy(address owner, bytes32 salt) external returns (address);\n\n    /// @notice       Generates a new deterministic address based on the owner and the salt.\n    ///\n    /// @param owner  Owner of the deployed collateral contract which has initial full rights.\n    /// @param salt   Used to make a deterministic deployment.\n    /// @return       An address of the newly deployed contract.\n    function previewAddress(address owner, bytes32 salt) external returns (address);\n}\n"
    },
    "src/misc/interfaces/IERC7540.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.5.0;\n\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\nimport {IERC7575, IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\ninterface IERC7540Operator {\n    /**\n     * @dev The event emitted when an operator is set.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     */\n    event OperatorSet(address indexed controller, address indexed operator, bool approved);\n\n    /**\n     * @dev Sets or removes an operator for the caller.\n     *\n     * @param operator The address of the operator.\n     * @param approved The approval status.\n     * @return Whether the call was executed successfully or not\n     */\n    function setOperator(address operator, bool approved) external returns (bool);\n\n    /**\n     * @dev Returns `true` if the `operator` is approved as an operator for an `controller`.\n     *\n     * @param controller The address of the controller.\n     * @param operator The address of the operator.\n     * @return status The approval status\n     */\n    function isOperator(address controller, address operator) external view returns (bool status);\n}\n\ninterface IERC7540Deposit is IERC7540Operator {\n    event DepositRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n    /**\n     * @dev Transfers assets from sender into the Vault and submits a Request for asynchronous deposit.\n     *\n     * - MUST support ERC-20 approve / transferFrom on asset as a deposit Request flow.\n     * - MUST revert if all of assets cannot be requested for deposit.\n     * - owner MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from owner to sender is NOT enough.\n     *\n     * @param assets the amount of deposit assets to transfer from owner\n     * @param controller the controller of the request who will be able to operate the request\n     * @param owner the source of the deposit assets\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's underlying asset token.\n     */\n\n    function requestDeposit(uint256 assets, address controller, address owner) external returns (uint256 requestId);\n\n    /**\n     * @dev Returns the amount of requested assets in Pending state.\n     *\n     * - MUST NOT include any assets in Claimable state for deposit or mint.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function pendingDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 pendingAssets);\n\n    /**\n     * @dev Returns the amount of requested assets in Claimable state for the controller to deposit or mint.\n     *\n     * - MUST NOT include any assets in Pending state.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function claimableDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableAssets);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by claiming the Request of the controller.\n     *\n     * - MUST emit the Deposit event.\n     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.\n     */\n    function deposit(uint256 assets, address receiver, address controller) external returns (uint256 shares);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by claiming the Request of the controller.\n     *\n     * - MUST emit the Deposit event.\n     * - controller MUST equal msg.sender unless the controller has approved the msg.sender as an operator.\n     */\n    function mint(uint256 shares, address receiver, address controller) external returns (uint256 assets);\n}\n\ninterface IERC7540Redeem is IERC7540Operator {\n    event RedeemRequest(\n        address indexed controller, address indexed owner, uint256 indexed requestId, address sender, uint256 assets\n    );\n\n    /**\n     * @dev Assumes control of shares from sender into the Vault and submits a Request for asynchronous redeem.\n     *\n     * - MUST support a redeem Request flow where the control of shares is taken from sender directly\n     *   where msg.sender has ERC-20 approval over the shares of owner.\n     * - MUST revert if all of shares cannot be requested for redeem.\n     *\n     * @param shares the amount of shares to be redeemed to transfer from owner\n     * @param controller the controller of the request who will be able to operate the request\n     * @param owner the source of the shares to be redeemed\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault's share token.\n     */\n    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256 requestId);\n\n    /**\n     * @dev Returns the amount of requested shares in Pending state.\n     *\n     * - MUST NOT include any shares in Claimable state for redeem or withdraw.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function pendingRedeemRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 pendingShares);\n\n    /**\n     * @dev Returns the amount of requested shares in Claimable state for the controller to redeem or withdraw.\n     *\n     * - MUST NOT include any shares in Pending state for redeem or withdraw.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT revert unless due to integer overflow caused by an unreasonably large input.\n     */\n    function claimableRedeemRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableShares);\n}\n\ninterface IERC7887Deposit {\n    event CancelDepositRequest(address indexed controller, uint256 indexed requestId, address sender);\n    event CancelDepositClaim(\n        address indexed controller, address indexed receiver, uint256 indexed requestId, address sender, uint256 assets\n    );\n\n    /**\n     * @dev Submits a Request for cancelling the pending deposit Request\n     *\n     * - controller MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from controller to sender is NOT enough.\n     * - MUST set pendingCancelDepositRequest to `true` for the returned requestId after request\n     * - MUST increase claimableCancelDepositRequest for the returned requestId after fulfillment\n     * - SHOULD be claimable using `claimCancelDepositRequest`\n     * Note: while `pendingCancelDepositRequest` is `true`, `requestDeposit` cannot be called\n     */\n    function cancelDepositRequest(uint256 requestId, address controller) external;\n\n    /**\n     * @dev Returns whether the deposit Request is pending cancelation\n     *\n     * - MUST NOT show any variations depending on the caller.\n     */\n    function pendingCancelDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (bool isPending);\n\n    /**\n     * @dev Returns the amount of assets that were canceled from a deposit Request, and can now be claimed.\n     *\n     * - MUST NOT show any variations depending on the caller.\n     */\n    function claimableCancelDepositRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableAssets);\n\n    /**\n     * @dev Claims the canceled deposit assets, and removes the pending cancelation Request\n     *\n     * - controller MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from controller to sender is NOT enough.\n     * - MUST set pendingCancelDepositRequest to `false` for the returned requestId after request\n     * - MUST set claimableCancelDepositRequest to 0 for the returned requestId after fulfillment\n     */\n    function claimCancelDepositRequest(uint256 requestId, address receiver, address controller)\n        external\n        returns (uint256 assets);\n}\n\ninterface IERC7887Redeem {\n    event CancelRedeemRequest(address indexed controller, uint256 indexed requestId, address sender);\n    event CancelRedeemClaim(\n        address indexed controller, address indexed receiver, uint256 indexed requestId, address sender, uint256 shares\n    );\n\n    /**\n     * @dev Submits a Request for cancelling the pending redeem Request\n     *\n     * - controller MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from controller to sender is NOT enough.\n     * - MUST set pendingCancelRedeemRequest to `true` for the returned requestId after request\n     * - MUST increase claimableCancelRedeemRequest for the returned requestId after fulfillment\n     * - SHOULD be claimable using `claimCancelRedeemRequest`\n     * Note: while `pendingCancelRedeemRequest` is `true`, `requestRedeem` cannot be called\n     */\n    function cancelRedeemRequest(uint256 requestId, address controller) external;\n\n    /**\n     * @dev Returns whether the redeem Request is pending cancelation\n     *\n     * - MUST NOT show any variations depending on the caller.\n     */\n    function pendingCancelRedeemRequest(uint256 requestId, address controller) external view returns (bool isPending);\n\n    /**\n     * @dev Returns the amount of shares that were canceled from a redeem Request, and can now be claimed.\n     *\n     * - MUST NOT show any variations depending on the caller.\n     */\n    function claimableCancelRedeemRequest(uint256 requestId, address controller)\n        external\n        view\n        returns (uint256 claimableShares);\n\n    /**\n     * @dev Claims the canceled redeem shares, and removes the pending cancelation Request\n     *\n     * - controller MUST be msg.sender unless some unspecified explicit approval is given by the caller,\n     *    approval of ERC-20 tokens from controller to sender is NOT enough.\n     * - MUST set pendingCancelRedeemRequest to `false` for the returned requestId after request\n     * - MUST set claimableCancelRedeemRequest to 0 for the returned requestId after fulfillment\n     */\n    function claimCancelRedeemRequest(uint256 requestId, address receiver, address controller)\n        external\n        returns (uint256 shares);\n}\n\ninterface IERC7741 {\n    /**\n     * @dev Grants or revokes permissions for `operator` to manage Requests on behalf of the\n     *      `msg.sender`, using an [EIP-712](./eip-712.md) signature.\n     */\n    function authorizeOperator(\n        address controller,\n        address operator,\n        bool approved,\n        bytes32 nonce,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (bool);\n\n    /**\n     * @dev Revokes the given `nonce` for `msg.sender` as the `owner`.\n     */\n    function invalidateNonce(bytes32 nonce) external;\n\n    /**\n     * @dev Returns whether the given `nonce` has been used for the `controller`.\n     */\n    function authorizations(address controller, bytes32 nonce) external view returns (bool used);\n\n    /**\n     * @dev Returns the `DOMAIN_SEPARATOR` as defined according to EIP-712. The `DOMAIN_SEPARATOR\n     *      should be unique to the contract and chain to prevent replay attacks from other domains,\n     *      and satisfy the requirements of EIP-712, but is otherwise unconstrained.\n     */\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\ninterface IERC7714 {\n    /**\n     * @dev Returns `true` if the `user` is permissioned to interact with the contract.\n     */\n    function isPermissioned(address controller) external view returns (bool);\n}\n"
    },
    "src/misc/interfaces/IERC7575.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC7575 is IERC165 {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the address of the share token\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function share() external view returns (address shareTokenAddress);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n     * â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the â€œper-userâ€ price-per-share, and instead should reflect the\n     * â€œaverage-userâ€™sâ€ price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is â€œmanagedâ€ by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaultâ€™s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vaultâ€™s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\ninterface IERC7575Share is IERC165 {\n    event VaultUpdate(address indexed asset, address vault);\n\n    /**\n     * @dev Returns the address of the Vault for the given asset.\n     *\n     * @param asset the ERC-20 token to deposit with into the Vault\n     */\n    function vault(address asset) external view returns (address);\n}\n"
    },
    "src/misc/interfaces/IERC7726.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/// [ERC-7726](https://eips.ethereum.org/EIPS/eip-7726): Common Quote Oracle\n/// Interface for asset conversions.\ninterface IERC7726 {\n    /// @notice Returns the value of baseAmount of base in quote terms, e.g. 10 ETH (base) in USDC (quote).\n    /// @param base The asset in which the baseAmount is denominated in\n    /// @param quote The asset in which the user needs to value the baseAmount\n    /// @param baseAmount The amount of base in base terms.\n    function getQuote(uint256 baseAmount, address base, address quote) external view returns (uint256 quoteAmount);\n}\n"
    },
    "src/misc/interfaces/IIdentityValuation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\n\n/// @notice An IERC7726 valuation that always values 1:1.\ninterface IIdentityValuation is IERC7726 {}\n"
    },
    "src/misc/interfaces/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/// @notice Allows to call several calls of the same contract in a single transaction\ninterface IMulticall {\n    /// @notice Dispatched when an empty revert is dispatched in a method in the multicall\n    error CallFailedWithEmptyRevert();\n\n    /// @notice Allows caller to execute multiple (batched) messages calls in one transaction.\n    /// @param data An array of encoded methods of the same contract.\n    /// @dev No reentrant execution is allowed.\n    /// If one call fails, it reverts the whole transaction.\n    /// In order to provide the correct value for functions that require top up,\n    /// the caller must estimate separately, in advance, how much each of the message call will cost.\n    /// The `msg.value` when calling this method must be the sum of all estimates.\n    function multicall(bytes[] calldata data) external payable;\n}\n"
    },
    "src/misc/interfaces/IRecoverable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\naddress constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\ninterface IRecoverable {\n    /// @notice Used to recover any ERC-20 token.\n    /// @dev    This method is called only by authorized entities\n    /// @param  token It could be 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n    ///         to recover locked native ETH or token compatible with ERC20.\n    /// @param  to Receiver of the funds\n    /// @param  amount Amount to send to the receiver.\n    function recoverTokens(address token, address to, uint256 amount) external;\n\n    /// @notice Used to recover any ERC-20 or ERC-6909 token.\n    /// @dev    This method is called only by authorized entities\n    /// @param  token It could be 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n    ///         to recover locked native ETH or token compatible with ERC20 or ERC6909.\n    /// @param  tokenId The token id, i.e. non-zero if the underlying token is ERC6909 and else zero.\n    /// @param  to Receiver of the funds\n    /// @param  amount Amount to send to the receiver.\n    function recoverTokens(address token, uint256 tokenId, address to, uint256 amount) external;\n}\n"
    },
    "src/misc/libraries/ArrayLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @title  ArrayLib\nlibrary ArrayLib {\n    error InvalidValues();\n\n    function countNonZeroValues(uint16[8] memory arr) internal pure returns (uint8 count) {\n        uint256 elementsCount = arr.length;\n        for (uint256 i; i < elementsCount; i++) {\n            if (arr[i] != 0) ++count;\n        }\n    }\n\n    function decreaseFirstNValues(uint16[8] storage arr, uint8 numValues) internal {\n        uint256 elementsCount = arr.length;\n        for (uint256 i; i < elementsCount; i++) {\n            if (numValues == 0) return;\n\n            if (arr[i] != 0) {\n                arr[i] -= 1;\n                numValues--;\n            }\n        }\n\n        require(numValues == 0, InvalidValues());\n    }\n\n    function isEmpty(uint16[8] memory arr) internal pure returns (bool) {\n        uint256 elementsCount = arr.length;\n        for (uint256 i; i < elementsCount; i++) {\n            if (arr[i] != 0) return false;\n        }\n        return true;\n    }\n}\n"
    },
    "src/misc/libraries/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @title  BitmapLib\nlibrary BitmapLib {\n    function setBit(uint128 bitmap, uint128 index, bool isTrue) internal pure returns (uint128) {\n        if (isTrue) {\n            return bitmap | (uint128(1) << index);\n        }\n\n        return bitmap & ~(uint128(1) << index);\n    }\n\n    function getBit(uint128 bitmap, uint128 index) internal pure returns (bool) {\n        uint128 bitAtIndex = uint128(bitmap & (1 << index));\n        return bitAtIndex != 0;\n    }\n}\n"
    },
    "src/misc/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @title  Bytes Lib\n/// @dev    Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n///         The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n/// @author Modified from Solidity Bytes Arrays Utils v0.8.0\nlibrary BytesLib {\n    error SliceOverflow();\n    error SliceOutOfBounds();\n\n    function sliceZeroPadded(bytes memory _bytes, uint256 _start, uint256 _length)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, SliceOverflow());\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_bytes.length >= _start + _length, SliceOutOfBounds());\n        return sliceZeroPadded(_bytes, _start, _length);\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, SliceOutOfBounds());\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, SliceOutOfBounds());\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, SliceOutOfBounds());\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, SliceOutOfBounds());\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, SliceOutOfBounds());\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, SliceOutOfBounds());\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, SliceOutOfBounds());\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, SliceOutOfBounds());\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function toBytes16(bytes memory _bytes, uint256 _start) internal pure returns (bytes16) {\n        require(_bytes.length >= _start + 16, SliceOutOfBounds());\n        bytes16 tempBytes16;\n\n        assembly {\n            tempBytes16 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes16;\n    }\n\n    function toBool(bytes memory _bytes, uint256 _start) internal pure returns (bool) {\n        require(_bytes.length > _start, SliceOutOfBounds());\n        return _bytes[_start] != 0;\n    }\n}\n"
    },
    "src/misc/libraries/CastLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @title  CastLib\nlibrary CastLib {\n    function toAddressLeftPadded(bytes32 addr) internal pure returns (address) {\n        require(bytes12(addr) == 0, \"First 12 bytes should be zero\");\n        return address(uint160(uint256(addr)));\n    }\n\n    function toBytes32LeftPadded(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function toAddress(bytes32 addr) internal pure returns (address) {\n        require(uint96(uint256(addr)) == 0, \"Input should be 20 bytes\");\n        return address(bytes20(addr));\n    }\n\n    function toString(address addr) internal pure returns (string memory) {\n        return string(abi.encodePacked(addr));\n    }\n\n    function toBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(bytes20(addr));\n    }\n\n    /// @dev Adds zero padding\n    function toBytes32(string memory source) internal pure returns (bytes32) {\n        return bytes32(bytes(source));\n    }\n\n    /// @dev Removes zero padding\n    function bytes128ToString(bytes memory _bytes128) internal pure returns (string memory) {\n        require(_bytes128.length == 128, \"Input should be 128 bytes\");\n\n        uint8 i = 0;\n        while (i < 128 && _bytes128[i] != 0) {\n            i++;\n        }\n\n        bytes memory bytesArray = new bytes(i);\n\n        for (uint8 j; j < i; j++) {\n            bytesArray[j] = _bytes128[j];\n        }\n\n        return string(bytesArray);\n    }\n\n    function toString(bytes32 _bytes32) internal pure returns (string memory) {\n        uint8 i = 0;\n        while (i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n}\n"
    },
    "src/misc/libraries/EIP712Lib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @title  EIP712 Lib\nlibrary EIP712Lib {\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    function calculateDomainSeparator(bytes32 nameHash, bytes32 versionHash) internal view returns (bytes32) {\n        return keccak256(abi.encode(EIP712_DOMAIN_TYPEHASH, nameHash, versionHash, block.chainid, address(this)));\n    }\n}\n"
    },
    "src/misc/libraries/MathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nlibrary MathLib {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n\n    }\n\n    error MulDiv_Overflow();\n    error Uint8_Overflow();\n    error Uint32_Overflow();\n    error Uint64_Overflow();\n    error Uint128_Overflow();\n    error Int128_Overflow();\n\n    uint256 public constant One27 = 10 ** 27;\n\n    /// @notice Returns x^n with rounding precision of base\n    ///\n    /// @dev Source: https://github.com/makerdao/dss/blob/fa4f6630afb0624d04a003e920b0d71a00331d98/src/jug.sol#L62\n    ///\n    /// @param x The base value which should be exponentiated\n    /// @param n The exponent\n    /// @param base The scaling base, typically used for fix-point calculations\n    function rpow(uint256 x, uint256 n, uint256 base) public pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 { z := base }\n                default { z := 0 }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 { z := base }\n                default { z := x }\n                let half := div(base, 2) // for rounding.\n                for { n := div(n, 2) } n { n := div(n, 2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0, 0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0, 0) }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0, 0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0, 0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n    ///         denominator == 0\n    /// @dev    Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n    ///         with further edits by Uniswap Labs also under MIT license.\n    // slither-disable-start divide-before-multiply\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, MulDiv_Overflow());\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    // slither-disable-end divide-before-multiply\n\n    /// @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /// @notice Safe type conversion from uint256 to uint8.\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, Uint8_Overflow());\n        return uint8(value);\n    }\n\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, Uint32_Overflow());\n        return uint32(value);\n    }\n\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, Uint64_Overflow());\n        return uint64(value);\n    }\n\n    /// @notice Safe type conversion from uint256 to uint128.\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, Uint128_Overflow());\n        return uint128(value);\n    }\n\n    /// @notice Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n\n    /// @notice Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "src/misc/libraries/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\n\n/// @title  Safe Transfer Lib\n/// @author Modified from Uniswap v3 Periphery (libraries/TransferHelper.sol)\nlibrary SafeTransferLib {\n    error NoCode();\n    error SafeTransferFromFailed();\n    error SafeTransferFailed();\n    error SafeApproveFailed();\n    error SafeTransferEthFailed();\n\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        require(address(token).code.length > 0, NoCode());\n\n        (bool success, bytes memory data) = token.call(abi.encodeCall(IERC20.transferFrom, (from, to, value)));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), SafeTransferFromFailed());\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        require(address(token).code.length > 0, NoCode());\n\n        (bool success, bytes memory data) = token.call(abi.encodeCall(IERC20.transfer, (to, value)));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), SafeTransferFailed());\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors if approval fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(address token, address to, uint256 value) internal {\n        require(address(token).code.length > 0, NoCode());\n\n        (bool success, bytes memory data) = token.call(abi.encodeCall(IERC20.approve, (to, value)));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), SafeApproveFailed());\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @dev Make sure that method that is using this function is protected from reentrancy\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        require(success, SafeTransferEthFailed());\n    }\n}\n"
    },
    "src/misc/libraries/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\ninterface IERC1271 {\n    function isValidSignature(bytes32, bytes memory) external view returns (bytes4);\n}\n\n/// @title  Signature Lib\nlibrary SignatureLib {\n    error InvalidSigner();\n\n    function isValidSignature(address signer, bytes32 digest, bytes memory signature)\n        internal\n        view\n        returns (bool valid)\n    {\n        require(signer != address(0), InvalidSigner());\n\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            if (signer == ecrecover(digest, v, r, s)) {\n                return true;\n            }\n        }\n\n        if (signer.code.length > 0) {\n            (bool success, bytes memory result) =\n                signer.staticcall(abi.encodeCall(IERC1271.isValidSignature, (digest, signature)));\n            valid =\n                (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n        }\n    }\n}\n"
    },
    "src/misc/libraries/StringLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nlibrary StringLib {\n    function isEmpty(string memory value) internal pure returns (bool) {\n        return bytes(value).length == 0;\n    }\n}\n"
    },
    "src/misc/libraries/TransientArrayLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\n/// @title  TransientArrayLib\nlibrary TransientArrayLib {\n    using TransientStorageLib for bytes32;\n\n    function push(bytes32 key, bytes32 value) internal {\n        bytes32 lengthSlot = keccak256(abi.encodePacked(key, type(uint256).max));\n        uint256 length_ = lengthSlot.tloadUint256();\n        lengthSlot.tstore(length_ + 1);\n\n        bytes32 slot = keccak256(abi.encodePacked(key, length_));\n        slot.tstore(value);\n    }\n\n    function getBytes32(bytes32 key) internal view returns (bytes32[] memory) {\n        uint256 length_ = length(key);\n\n        bytes32[] memory data = new bytes32[](length_);\n        for (uint256 i = 0; i < length_; i++) {\n            bytes32 slot = keccak256(abi.encodePacked(key, i));\n            data[i] = slot.tloadBytes32();\n        }\n\n        return data;\n    }\n\n    function length(bytes32 key) internal view returns (uint256) {\n        return keccak256(abi.encodePacked(key, type(uint256).max)).tloadUint256();\n    }\n\n    function clear(bytes32 key) internal {\n        bytes32 lengthSlot = keccak256(abi.encodePacked(key, type(uint256).max));\n        lengthSlot.tstore(uint256(0));\n    }\n}\n"
    },
    "src/misc/libraries/TransientBytesLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\n/// @title  TransientBytesLib\nlibrary TransientBytesLib {\n    using TransientStorageLib for bytes32;\n    using BytesLib for bytes;\n\n    function append(bytes32 key, bytes memory value) internal {\n        bytes32 lengthSlot = keccak256(abi.encodePacked(key, type(uint256).max));\n        uint256 prevLength = lengthSlot.tloadUint256();\n\n        uint256 startChunk = prevLength / 32;\n        uint256 offset = prevLength % 32;\n\n        lengthSlot.tstore(prevLength + value.length);\n\n        bytes32 joinSlot = keccak256(abi.encodePacked(key, startChunk));\n        bytes memory firstPart = abi.encodePacked(joinSlot.tloadBytes32()).sliceZeroPadded(0, offset);\n        bytes memory secondPart = value.sliceZeroPadded(0, 32 - offset);\n        joinSlot.tstore(bytes32(bytes.concat(firstPart, secondPart)));\n\n        uint256 valueOffset = 32 - offset;\n        uint256 chunkIndex = startChunk + 1;\n        for (; valueOffset < value.length; chunkIndex++) {\n            bytes32 slot = keccak256(abi.encodePacked(key, chunkIndex));\n            slot.tstore(bytes32(value.sliceZeroPadded(valueOffset, 32)));\n            valueOffset += 32;\n        }\n    }\n\n    function get(bytes32 key) internal view returns (bytes memory) {\n        bytes memory data;\n        uint256 length = keccak256(abi.encodePacked(key, type(uint256).max)).tloadUint256();\n        if (length == 0) return data;\n\n        uint256 chunks = length / 32 + 1;\n        for (uint256 i = 0; i < chunks; i++) {\n            bytes32 slot = keccak256(abi.encodePacked(key, i));\n            data = bytes.concat(data, slot.tloadBytes32());\n        }\n\n        return data.slice(0, length);\n    }\n\n    function clear(bytes32 key) internal {\n        bytes32 lengthSlot = keccak256(abi.encodePacked(key, type(uint256).max));\n        lengthSlot.tstore(uint256(0));\n    }\n}\n"
    },
    "src/misc/libraries/TransientStorageLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\n/// @title  TransientStorageLib\nlibrary TransientStorageLib {\n    function tstore(bytes32 slot, address value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    function tstore(bytes32 slot, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    function tstore(bytes32 slot, bytes32 value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    function tstore(bytes32 slot, bool value) internal {\n        assembly (\"memory-safe\") {\n            tstore(slot, value)\n        }\n    }\n\n    function tloadAddress(bytes32 slot) internal view returns (address value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    function tloadUint128(bytes32 slot) internal view returns (uint128 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    function tloadUint256(bytes32 slot) internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    function tloadBytes32(bytes32 slot) internal view returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n\n    function tloadBool(bytes32 slot) internal view returns (bool value) {\n        assembly (\"memory-safe\") {\n            value := tload(slot)\n        }\n    }\n}\n"
    },
    "src/misc/types/D18.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n// Small library to handle fixed point number operations with 18 decimals with static typing support.\n\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\n\ntype D18 is uint128;\n\nusing MathLib for uint256;\n\n/// @dev add two D18 types\nfunction add(D18 d1, D18 d2) pure returns (D18) {\n    return D18.wrap(D18.unwrap(d1) + D18.unwrap(d2));\n}\n\n/// @dev substract two D18 types\nfunction sub(D18 d1, D18 d2) pure returns (D18) {\n    return D18.wrap(D18.unwrap(d1) - D18.unwrap(d2));\n}\n\n/// @dev Divides one D18 by another one while retaining precision:\n/// - nominator (decimal): 50e18\n/// - denominator (decimal):  2e19\n/// - result (decimal): 25e17\nfunction divD18(D18 d1, D18 d2) pure returns (D18) {\n    return D18.wrap(MathLib.mulDiv(D18.unwrap(d1), 1e18, D18.unwrap(d2)).toUint128());\n}\n\n/// @dev Multiplies one D18 with another one while retaining precision:\n/// - value1 (decimal): 50e18\n/// - value2 (decimal):  2e19\n/// - result (decimal): 100e19\nfunction mulD18(D18 d1, D18 d2) pure returns (D18) {\n    return D18.wrap(MathLib.mulDiv(D18.unwrap(d1), D18.unwrap(d2), 1e18).toUint128());\n}\n\n/// @dev sugar for getting the inner representation of a D18\nfunction inner(D18 d1) pure returns (uint128) {\n    return D18.unwrap(d1);\n}\n\n/// @dev Returns the reciprocal of a D18 decimal, i.e. 1 / d.\n///      Example: if d = 2.0 (2e18 internally), reciprocal(d) = 0.5 (5e17 internally).\nfunction reciprocal(D18 d) pure returns (D18) {\n    uint128 val = D18.unwrap(d);\n    require(val != 0, \"D18/division-by-zero\");\n    return d18(1e18, val);\n}\n\n/// @dev Multiplies a decimal by an integer. i.e:\n/// - d (decimal):      1_500_000_000_000_000_000\n/// - value (integer):  4_000_000_000_000_000_000\n/// - result (integer): 6_000_000_000_000_000_000\nfunction mulUint128(D18 d, uint128 value, MathLib.Rounding rounding) pure returns (uint128) {\n    return MathLib.mulDiv(D18.unwrap(d), value, 1e18, rounding).toUint128();\n}\n\n/// @dev Multiplies a decimal by an integer. i.e:\n/// - d (decimal):      1_500_000_000_000_000_000\n/// - value (integer):  4_000_000_000_000_000_000\n/// - result (integer): 6_000_000_000_000_000_000\nfunction mulUint256(D18 d, uint256 value, MathLib.Rounding rounding) pure returns (uint256) {\n    return MathLib.mulDiv(D18.unwrap(d), value, 1e18, rounding);\n}\n\n/// @dev  Divides an integer by a decimal, i.e.\n/// @dev  Same as mulDiv for integers, i.e:\n/// - d (decimal):      2_000_000_000_000_000_000\n/// - value (integer):  100_000_000_000_000_000_000\n/// - result (integer): 50_000_000_000_000_000_000\nfunction reciprocalMulUint128(D18 d, uint128 value, MathLib.Rounding rounding) pure returns (uint128) {\n    return MathLib.mulDiv(value, 1e18, d.inner(), rounding).toUint128();\n}\n\n/// @dev  Divides an integer by a decimal, i.e.\n/// @dev  Same as mulDiv for integers, i.e:\n/// - d (decimal):      2_000_000_000_000_000_000\n/// - value (integer):  100_000_000_000_000_000_000\n/// - result (integer): 50_000_000_000_000_000_000\nfunction reciprocalMulUint256(D18 d, uint256 value, MathLib.Rounding rounding) pure returns (uint256) {\n    return MathLib.mulDiv(value, 1e18, d.inner(), rounding);\n}\n\n/// @dev Easy way to construct a decimal number\nfunction d18(uint128 value) pure returns (D18) {\n    return D18.wrap(value);\n}\n\n/// @dev Easy way to construct a decimal number\nfunction d18(uint128 num, uint128 den) pure returns (D18) {\n    return D18.wrap(MathLib.mulDiv(num, 1e18, den).toUint128());\n}\n\nfunction eq(D18 a, D18 b) pure returns (bool) {\n    return D18.unwrap(a) == D18.unwrap(b);\n}\n\nfunction raw(D18 d) pure returns (uint128) {\n    return D18.unwrap(d);\n}\n\nusing {\n    add as +,\n    sub as -,\n    divD18 as /,\n    inner,\n    eq,\n    mulD18 as *,\n    mulUint128,\n    mulUint256,\n    reciprocalMulUint128,\n    reciprocalMulUint256,\n    reciprocal,\n    raw\n} for D18 global;\n"
    },
    "src/vaults/AsyncRequestManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IVaultMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\nimport {IRequestManagerGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nimport {IPoolManager, VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBalanceSheet} from \"src/vaults/interfaces/IBalanceSheet.sol\";\nimport {IAsyncRequestManager, AsyncInvestmentState} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\nimport {IAsyncDepositManager} from \"src/vaults/interfaces/investments/IAsyncDepositManager.sol\";\nimport {IDepositManager} from \"src/vaults/interfaces/investments/IDepositManager.sol\";\nimport {IRedeemManager} from \"src/vaults/interfaces/investments/IRedeemManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IAsyncVault, IBaseVault, IAsyncRedeemVault, VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {BaseRequestManager} from \"src/vaults/BaseRequestManager.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {ESCROW_HOOK_ID} from \"src/common/interfaces/IHook.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\n/// @title  Investment Manager\n/// @notice This is the main contract vaults interact with for\n///         both incoming and outgoing investment transactions.\ncontract AsyncRequestManager is BaseRequestManager, IAsyncRequestManager {\n    using CastLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using MathLib for uint256;\n\n    IVaultMessageSender public sender;\n    IBalanceSheet public balanceSheet;\n\n    mapping(IBaseVault vault => mapping(address investor => AsyncInvestmentState)) public investments;\n\n    constructor(IEscrow globalEscrow_, address root_, address deployer)\n        BaseRequestManager(globalEscrow_, root_, deployer)\n    {}\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    function file(bytes32 what, address data) external override(IBaseRequestManager, BaseRequestManager) auth {\n        if (what == \"sender\") sender = IVaultMessageSender(data);\n        else if (what == \"poolManager\") poolManager = IPoolManager(data);\n        else if (what == \"balanceSheet\") balanceSheet = IBalanceSheet(data);\n        else if (what == \"poolEscrowProvider\") poolEscrowProvider = IPoolEscrowProvider(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Async investment handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAsyncDepositManager\n    function requestDeposit(IBaseVault vault_, uint256 assets, address controller, address, address)\n        public\n        auth\n        returns (bool)\n    {\n        uint128 assets_ = assets.toUint128();\n        require(assets_ != 0, ZeroAmountNotAllowed());\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        PoolId poolId = vault_.poolId();\n        ShareClassId scId = vault_.scId();\n\n        require(poolManager.isLinked(poolId, scId, vaultDetails.asset, vault_), AssetNotAllowed());\n\n        require(_canTransfer(vault_, address(0), controller, convertToShares(vault_, assets_)), TransferNotAllowed());\n\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        require(state.pendingCancelDepositRequest != true, CancellationIsPending());\n\n        state.pendingDepositRequest += assets_;\n        sender.sendDepositRequest(poolId, scId, controller.toBytes32(), vaultDetails.assetId, assets_);\n\n        return true;\n    }\n\n    /// @inheritdoc IAsyncRedeemManager\n    function requestRedeem(IBaseVault vault_, uint256 shares, address controller, address owner, address)\n        public\n        auth\n        returns (bool)\n    {\n        uint128 shares_ = shares.toUint128();\n        require(shares_ != 0, ZeroAmountNotAllowed());\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        PoolId poolId = vault_.poolId();\n        ShareClassId scId = vault_.scId();\n\n        require(poolManager.isLinked(poolId, scId, vaultDetails.asset, vault_), AssetNotAllowed());\n\n        require(\n            _canTransfer(vault_, owner, ESCROW_HOOK_ID, shares)\n                && _canTransfer(vault_, controller, ESCROW_HOOK_ID, shares),\n            TransferNotAllowed()\n        );\n\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        require(state.pendingCancelRedeemRequest != true, CancellationIsPending());\n\n        state.pendingRedeemRequest = state.pendingRedeemRequest + shares_;\n        sender.sendRedeemRequest(poolId, scId, controller.toBytes32(), vaultDetails.assetId, shares_);\n\n        return true;\n    }\n\n    /// @inheritdoc IAsyncDepositManager\n    function cancelDepositRequest(IBaseVault vault_, address controller, address) public auth {\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        require(state.pendingDepositRequest > 0, NoPendingRequest());\n        require(state.pendingCancelDepositRequest != true, CancellationIsPending());\n        state.pendingCancelDepositRequest = true;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n\n        sender.sendCancelDepositRequest(vault_.poolId(), vault_.scId(), controller.toBytes32(), vaultDetails.assetId);\n    }\n\n    /// @inheritdoc IAsyncRedeemManager\n    function cancelRedeemRequest(IBaseVault vault_, address controller, address) public auth {\n        uint256 approximateSharesPayout = pendingRedeemRequest(vault_, controller);\n        require(approximateSharesPayout > 0, NoPendingRequest());\n        require(_canTransfer(vault_, address(0), controller, approximateSharesPayout), TransferNotAllowed());\n\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        require(state.pendingCancelRedeemRequest != true, CancellationIsPending());\n        state.pendingCancelRedeemRequest = true;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n\n        sender.sendCancelRedeemRequest(vault_.poolId(), vault_.scId(), controller.toBytes32(), vaultDetails.assetId);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function approvedDeposits(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        D18 pricePoolPerAsset\n    ) external auth {\n        (address asset, uint256 tokenId) = poolManager.idToAsset(assetId);\n\n        // Note deposit and transfer from global escrow into the pool escrow,\n        // to make assets available for managers of the balance sheet\n        balanceSheet.overridePricePoolPerAsset(poolId, scId, assetId, pricePoolPerAsset);\n        balanceSheet.noteDeposit(poolId, scId, asset, tokenId, address(globalEscrow), assetAmount);\n\n        address poolEscrow = address(poolEscrowProvider.escrow(poolId));\n        globalEscrow.authTransferTo(asset, tokenId, poolEscrow, assetAmount);\n    }\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function issuedShares(PoolId poolId, ShareClassId scId, uint128 shareAmount, D18 pricePoolPerShare) external auth {\n        balanceSheet.overridePricePoolPerShare(poolId, scId, pricePoolPerShare);\n        balanceSheet.issue(poolId, scId, address(globalEscrow), shareAmount);\n    }\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function revokedShares(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 assetAmount,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) external auth {\n        // Lock assets to ensure they are not withdrawn and are available for the redeeming user\n        (address asset, uint256 tokenId) = poolManager.idToAsset(assetId);\n        poolEscrowProvider.escrow(poolId).reserveIncrease(scId, asset, tokenId, assetAmount);\n\n        balanceSheet.overridePricePoolPerShare(poolId, scId, pricePoolPerShare);\n        balanceSheet.revoke(poolId, scId, address(globalEscrow), shareAmount);\n    }\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function fulfillDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        address user,\n        AssetId assetId,\n        uint128 assets,\n        uint128 shares\n    ) public auth {\n        IAsyncVault vault_ = IAsyncVault(address(vault[poolId][scId][assetId]));\n\n        AsyncInvestmentState storage state = investments[vault_][user];\n        require(state.pendingDepositRequest != 0, NoPendingRequest());\n        state.depositPrice = _calculatePriceAssetPerShare(\n            vault_, state.maxMint + shares, _maxDeposit(vault_, user) + assets, MathLib.Rounding.Down\n        );\n        state.maxMint = state.maxMint + shares;\n        state.pendingDepositRequest = state.pendingDepositRequest > assets ? state.pendingDepositRequest - assets : 0;\n\n        if (state.pendingDepositRequest == 0) delete state.pendingCancelDepositRequest;\n\n        vault_.onDepositClaimable(user, assets, shares);\n    }\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function fulfillRedeemRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        address user,\n        AssetId assetId,\n        uint128 assets,\n        uint128 shares\n    ) public auth {\n        IAsyncRedeemVault vault_ = IAsyncRedeemVault(address(vault[poolId][scId][assetId]));\n\n        AsyncInvestmentState storage state = investments[vault_][user];\n        require(state.pendingRedeemRequest != 0, NoPendingRequest());\n\n        // Calculate new weighted average redeem price and update order book values\n        state.redeemPrice = _calculatePriceAssetPerShare(\n            vault_, ((maxRedeem(vault_, user)) + shares).toUint128(), state.maxWithdraw + assets, MathLib.Rounding.Down\n        );\n        state.maxWithdraw = state.maxWithdraw + assets;\n        state.pendingRedeemRequest = state.pendingRedeemRequest > shares ? state.pendingRedeemRequest - shares : 0;\n\n        if (state.pendingRedeemRequest == 0) delete state.pendingCancelRedeemRequest;\n\n        vault_.onRedeemClaimable(user, assets, shares);\n    }\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function fulfillCancelDepositRequest(\n        PoolId poolId,\n        ShareClassId scId,\n        address user,\n        AssetId assetId,\n        uint128 assets,\n        uint128 fulfillment\n    ) public auth {\n        IAsyncVault vault_ = IAsyncVault(address(vault[poolId][scId][assetId]));\n\n        AsyncInvestmentState storage state = investments[vault_][user];\n        require(state.pendingCancelDepositRequest == true, NoPendingRequest());\n\n        state.claimableCancelDepositRequest = state.claimableCancelDepositRequest + assets;\n        state.pendingDepositRequest =\n            state.pendingDepositRequest > fulfillment ? state.pendingDepositRequest - fulfillment : 0;\n\n        if (state.pendingDepositRequest == 0) delete state.pendingCancelDepositRequest;\n\n        vault_.onCancelDepositClaimable(user, assets);\n    }\n\n    /// @inheritdoc IRequestManagerGatewayHandler\n    function fulfillCancelRedeemRequest(PoolId poolId, ShareClassId scId, address user, AssetId assetId, uint128 shares)\n        public\n        auth\n    {\n        IAsyncRedeemVault vault_ = IAsyncRedeemVault(address(vault[poolId][scId][assetId]));\n        AsyncInvestmentState storage state = investments[vault_][user];\n        require(state.pendingCancelRedeemRequest == true, NoPendingRequest());\n\n        state.claimableCancelRedeemRequest = state.claimableCancelRedeemRequest + shares;\n        state.pendingRedeemRequest = state.pendingRedeemRequest > shares ? state.pendingRedeemRequest - shares : 0;\n\n        if (state.pendingRedeemRequest == 0) delete state.pendingCancelRedeemRequest;\n\n        vault_.onCancelRedeemClaimable(user, shares);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Sync investment handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IDepositManager\n    function deposit(IBaseVault vault_, uint256 assets, address receiver, address controller)\n        public\n        auth\n        returns (uint256 shares)\n    {\n        require(assets <= _maxDeposit(vault_, controller), ExceedsMaxDeposit());\n\n        AsyncInvestmentState storage state = investments[vault_][controller];\n\n        uint128 sharesUp = _assetToShareAmount(vault_, assets.toUint128(), state.depositPrice, MathLib.Rounding.Up);\n        uint128 sharesDown = _assetToShareAmount(vault_, assets.toUint128(), state.depositPrice, MathLib.Rounding.Down);\n        shares = uint256(sharesDown);\n        _processDeposit(state, sharesUp, sharesDown, vault_, receiver);\n    }\n\n    /// @inheritdoc IDepositManager\n    function mint(IBaseVault vault_, uint256 shares, address receiver, address controller)\n        public\n        auth\n        returns (uint256 assets)\n    {\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        uint128 shares_ = shares.toUint128();\n\n        assets = uint256(_shareToAssetAmount(vault_, shares_, state.depositPrice, MathLib.Rounding.Up));\n        _processDeposit(state, shares_, shares_, vault_, receiver);\n    }\n\n    function _processDeposit(\n        AsyncInvestmentState storage state,\n        uint128 sharesUp,\n        uint128 sharesDown,\n        IBaseVault vault_,\n        address receiver\n    ) internal {\n        require(sharesUp <= state.maxMint, ExceedsDepositLimits());\n        state.maxMint = state.maxMint > sharesUp ? state.maxMint - sharesUp : 0;\n\n        if (sharesDown > 0) {\n            globalEscrow.authTransferTo(vault_.share(), receiver, sharesDown);\n        }\n    }\n\n    /// @inheritdoc IRedeemManager\n    function redeem(IBaseVault vault_, uint256 shares, address receiver, address controller)\n        public\n        auth\n        returns (uint256 assets)\n    {\n        require(shares <= maxRedeem(vault_, controller), ExceedsMaxRedeem());\n\n        AsyncInvestmentState storage state = investments[vault_][controller];\n\n        uint128 assetsUp = _shareToAssetAmount(vault_, shares.toUint128(), state.redeemPrice, MathLib.Rounding.Up);\n        uint128 assetsDown = _shareToAssetAmount(vault_, shares.toUint128(), state.redeemPrice, MathLib.Rounding.Down);\n        _processRedeem(state, assetsUp, assetsDown, vault_, receiver, controller);\n        assets = uint256(assetsDown);\n    }\n\n    /// @inheritdoc IRedeemManager\n    function withdraw(IBaseVault vault_, uint256 assets, address receiver, address controller)\n        public\n        auth\n        returns (uint256 shares)\n    {\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        uint128 assets_ = assets.toUint128();\n        _processRedeem(state, assets_, assets_, vault_, receiver, controller);\n\n        shares = uint256(_assetToShareAmount(vault_, assets_, state.redeemPrice, MathLib.Rounding.Up));\n    }\n\n    function _processRedeem(\n        AsyncInvestmentState storage state,\n        uint128 assetsUp,\n        uint128 assetsDown,\n        IBaseVault vault_,\n        address receiver,\n        address controller\n    ) internal {\n        if (controller != receiver) {\n            require(\n                _canTransfer(vault_, controller, receiver, convertToShares(vault_, assetsDown)), TransferNotAllowed()\n            );\n        }\n\n        require(_canTransfer(vault_, receiver, address(0), convertToShares(vault_, assetsDown)), TransferNotAllowed());\n\n        require(assetsUp <= state.maxWithdraw, ExceedsRedeemLimits());\n        state.maxWithdraw = state.maxWithdraw > assetsUp ? state.maxWithdraw - assetsUp : 0;\n\n        if (assetsDown > 0) {\n            _withdraw(vault_, receiver, assetsDown);\n        }\n    }\n\n    /// @dev Transfer funds from escrow to receiver and update holdings\n    function _withdraw(IBaseVault vault_, address receiver, uint128 assets) internal {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n\n        PoolId poolId = vault_.poolId();\n        ShareClassId scId = vault_.scId();\n\n        poolEscrowProvider.escrow(poolId).reserveDecrease(scId, vaultDetails.asset, vaultDetails.tokenId, assets);\n        balanceSheet.withdraw(poolId, scId, vaultDetails.asset, vaultDetails.tokenId, receiver, assets);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Cancellation claim handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IAsyncDepositManager\n    function claimCancelDepositRequest(IBaseVault vault_, address receiver, address controller)\n        public\n        auth\n        returns (uint256 assets)\n    {\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        assets = state.claimableCancelDepositRequest;\n        state.claimableCancelDepositRequest = 0;\n        uint256 shares = convertToShares(vault_, assets);\n\n        if (controller != receiver) {\n            require(_canTransfer(vault_, controller, receiver, shares), TransferNotAllowed());\n        }\n        require(_canTransfer(vault_, receiver, address(0), shares), TransferNotAllowed());\n\n        if (assets > 0) {\n            VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n            globalEscrow.authTransferTo(vaultDetails.asset, vaultDetails.tokenId, receiver, assets);\n        }\n    }\n\n    /// @inheritdoc IAsyncRedeemManager\n    function claimCancelRedeemRequest(IBaseVault vault_, address receiver, address controller)\n        public\n        auth\n        returns (uint256 shares)\n    {\n        AsyncInvestmentState storage state = investments[vault_][controller];\n        shares = state.claimableCancelRedeemRequest;\n        state.claimableCancelRedeemRequest = 0;\n\n        if (shares > 0) {\n            globalEscrow.authTransferTo(vault_.share(), receiver, shares);\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IDepositManager\n    function maxDeposit(IBaseVault vault_, address user) public view returns (uint256 assets) {\n        if (!_canTransfer(vault_, ESCROW_HOOK_ID, user, 0)) {\n            return 0;\n        }\n        assets = uint256(_maxDeposit(vault_, user));\n    }\n\n    function _maxDeposit(IBaseVault vault_, address user) internal view returns (uint128 assets) {\n        AsyncInvestmentState memory state = investments[vault_][user];\n\n        assets = _shareToAssetAmount(vault_, state.maxMint, state.depositPrice, MathLib.Rounding.Down);\n    }\n\n    /// @inheritdoc IDepositManager\n    function maxMint(IBaseVault vault_, address user) public view returns (uint256 shares) {\n        if (!_canTransfer(vault_, ESCROW_HOOK_ID, user, 0)) {\n            return 0;\n        }\n        shares = uint256(investments[vault_][user].maxMint);\n    }\n\n    /// @inheritdoc IRedeemManager\n    function maxWithdraw(IBaseVault vault_, address user) public view returns (uint256 assets) {\n        if (!_canTransfer(vault_, user, address(0), 0)) return 0;\n        assets = uint256(investments[vault_][user].maxWithdraw);\n    }\n\n    /// @inheritdoc IRedeemManager\n    function maxRedeem(IBaseVault vault_, address user) public view returns (uint256 shares) {\n        if (!_canTransfer(vault_, user, address(0), 0)) return 0;\n        AsyncInvestmentState memory state = investments[vault_][user];\n\n        shares = uint256(_assetToShareAmount(vault_, state.maxWithdraw, state.redeemPrice, MathLib.Rounding.Down));\n    }\n\n    /// @inheritdoc IAsyncDepositManager\n    function pendingDepositRequest(IBaseVault vault_, address user) public view returns (uint256 assets) {\n        assets = uint256(investments[vault_][user].pendingDepositRequest);\n    }\n\n    /// @inheritdoc IAsyncRedeemManager\n    function pendingRedeemRequest(IBaseVault vault_, address user) public view returns (uint256 shares) {\n        shares = uint256(investments[vault_][user].pendingRedeemRequest);\n    }\n\n    /// @inheritdoc IAsyncDepositManager\n    function pendingCancelDepositRequest(IBaseVault vault_, address user) public view returns (bool isPending) {\n        isPending = investments[vault_][user].pendingCancelDepositRequest;\n    }\n\n    /// @inheritdoc IAsyncRedeemManager\n    function pendingCancelRedeemRequest(IBaseVault vault_, address user) public view returns (bool isPending) {\n        isPending = investments[vault_][user].pendingCancelRedeemRequest;\n    }\n\n    /// @inheritdoc IAsyncDepositManager\n    function claimableCancelDepositRequest(IBaseVault vault_, address user) public view returns (uint256 assets) {\n        assets = investments[vault_][user].claimableCancelDepositRequest;\n    }\n\n    /// @inheritdoc IAsyncRedeemManager\n    function claimableCancelRedeemRequest(IBaseVault vault_, address user) public view returns (uint256 shares) {\n        shares = investments[vault_][user].claimableCancelRedeemRequest;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev    Checks transfer restrictions for the vault shares. Sender (from) and receiver (to) have to both pass\n    ///         the restrictions for a successful share transfer.\n    function _canTransfer(IBaseVault vault_, address from, address to, uint256 value) internal view returns (bool) {\n        IShareToken share = IShareToken(vault_.share());\n        return share.checkTransferRestriction(from, to, value);\n    }\n\n    function _assetToShareAmount(\n        IBaseVault vault_,\n        uint128 assets,\n        uint256 priceAssetPerShare,\n        MathLib.Rounding rounding\n    ) internal view returns (uint128 shares) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        address shareToken = vault_.share();\n\n        return PricingLib.assetToShareAmount(\n            shareToken, vaultDetails.asset, vaultDetails.tokenId, assets, d18(priceAssetPerShare.toUint128()), rounding\n        );\n    }\n\n    function _shareToAssetAmount(\n        IBaseVault vault_,\n        uint128 shares,\n        uint256 priceAssetPerShare,\n        MathLib.Rounding rounding\n    ) internal view returns (uint128 assets) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        address shareToken = vault_.share();\n\n        return PricingLib.shareToAssetAmount(\n            shareToken, shares, vaultDetails.asset, vaultDetails.tokenId, d18(priceAssetPerShare.toUint128()), rounding\n        );\n    }\n\n    function _calculatePriceAssetPerShare(IBaseVault vault_, uint128 shares, uint128 assets, MathLib.Rounding rounding)\n        internal\n        view\n        returns (uint256 price)\n    {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        address shareToken = vault_.share();\n\n        return PricingLib.calculatePriceAssetPerShare(\n            shareToken, shares, vaultDetails.asset, vaultDetails.tokenId, assets, rounding\n        );\n    }\n}\n"
    },
    "src/vaults/AsyncVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"src/misc/interfaces/IERC7540.sol\";\nimport \"src/misc/interfaces/IERC7575.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IAsyncRedeemVault, VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {BaseVault, BaseAsyncRedeemVault} from \"src/vaults/BaseVaults.sol\";\nimport {IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\n/// @title  AsyncVault\n/// @notice Asynchronous Tokenized Vault standard implementation for Centrifuge pools\n///\n/// @dev    Each vault issues shares of Centrifuge share class tokens as restricted ERC-20 tokens\n///         against asset deposits based on the current share price.\n///\n///         ERC-7540 is an extension of the ERC-4626 standard by 'requestDeposit' & 'requestRedeem' methods, where\n///         deposit and redeem orders are submitted to the pools to be included in the execution of the following epoch.\n///         After execution users can use the deposit, mint, redeem and withdraw functions to get their shares\n///         and/or assets from the pools.\ncontract AsyncVault is BaseAsyncRedeemVault, IAsyncVault {\n    constructor(\n        PoolId poolId_,\n        ShareClassId scId_,\n        address asset_,\n        IShareToken token_,\n        address root_,\n        IAsyncRequestManager manager_\n    ) BaseVault(poolId_, scId_, asset_, token_, root_, manager_) BaseAsyncRedeemVault(manager_) {}\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-7540 deposit\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7540Deposit\n    function requestDeposit(uint256 assets, address controller, address owner) public returns (uint256) {\n        require(owner == msg.sender || isOperator[owner][msg.sender], InvalidOwner());\n        require(IERC20(asset).balanceOf(owner) >= assets, InsufficientBalance());\n\n        require(asyncManager().requestDeposit(this, assets, controller, owner, msg.sender), RequestDepositFailed());\n        SafeTransferLib.safeTransferFrom(asset, owner, address(manager.globalEscrow()), assets);\n\n        emit DepositRequest(controller, owner, REQUEST_ID, msg.sender, assets);\n        return REQUEST_ID;\n    }\n\n    /// @inheritdoc IERC7540Deposit\n    function pendingDepositRequest(uint256, address controller) public view returns (uint256 pendingAssets) {\n        pendingAssets = asyncManager().pendingDepositRequest(this, controller);\n    }\n\n    /// @inheritdoc IERC7540Deposit\n    function claimableDepositRequest(uint256, address controller) external view returns (uint256 claimableAssets) {\n        claimableAssets = maxDeposit(controller);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-7887\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7887Deposit\n    function cancelDepositRequest(uint256, address controller) external {\n        _validateController(controller);\n        asyncManager().cancelDepositRequest(this, controller, msg.sender);\n        emit CancelDepositRequest(controller, REQUEST_ID, msg.sender);\n    }\n\n    /// @inheritdoc IERC7887Deposit\n    function pendingCancelDepositRequest(uint256, address controller) public view returns (bool isPending) {\n        isPending = asyncManager().pendingCancelDepositRequest(this, controller);\n    }\n\n    /// @inheritdoc IERC7887Deposit\n    function claimableCancelDepositRequest(uint256, address controller) public view returns (uint256 claimableAssets) {\n        claimableAssets = asyncManager().claimableCancelDepositRequest(this, controller);\n    }\n\n    /// @inheritdoc IERC7887Deposit\n    function claimCancelDepositRequest(uint256, address receiver, address controller)\n        external\n        returns (uint256 assets)\n    {\n        _validateController(controller);\n        assets = asyncManager().claimCancelDepositRequest(this, receiver, controller);\n        emit CancelDepositClaim(controller, receiver, REQUEST_ID, msg.sender, assets);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public pure override(BaseAsyncRedeemVault, IERC165) returns (bool) {\n        return interfaceId == type(IERC7540Deposit).interfaceId || interfaceId == type(IERC7887Deposit).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-7540 claim\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7575\n    function maxDeposit(address controller) public view returns (uint256 maxAssets) {\n        maxAssets = asyncManager().maxDeposit(this, controller);\n    }\n\n    /// @inheritdoc IERC7540Deposit\n    function deposit(uint256 assets, address receiver, address controller) public returns (uint256 shares) {\n        _validateController(controller);\n        shares = asyncManager().deposit(this, assets, receiver, controller);\n        emit Deposit(controller, receiver, assets, shares);\n    }\n\n    /// @inheritdoc IERC7575\n    /// @notice     When claiming deposit requests using deposit(), there can be some precision loss leading to dust.\n    ///             It is recommended to use mint() to claim deposit requests instead.\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {\n        shares = deposit(assets, receiver, msg.sender);\n    }\n\n    /// @inheritdoc IERC7575\n    function maxMint(address controller) public view returns (uint256 maxShares) {\n        maxShares = asyncManager().maxMint(this, controller);\n    }\n\n    /// @inheritdoc IERC7540Deposit\n    function mint(uint256 shares, address receiver, address controller) public returns (uint256 assets) {\n        _validateController(controller);\n        assets = asyncManager().mint(this, shares, receiver, controller);\n        emit Deposit(controller, receiver, assets, shares);\n    }\n\n    /// @inheritdoc IERC7575\n    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n        assets = mint(shares, receiver, msg.sender);\n    }\n\n    /// @dev Strongly-typed accessor to the generic async redeem manager\n    function asyncManager() public view returns (IAsyncRequestManager) {\n        return IAsyncRequestManager(address(IAsyncRedeemVault(this).asyncRedeemManager()));\n    }\n\n    /// @dev Preview functions for ERC-7540 vaults revert\n    function previewDeposit(uint256) external pure returns (uint256) {\n        revert();\n    }\n\n    /// @dev Preview functions for ERC-7540 vaults revert\n    function previewMint(uint256) external pure returns (uint256) {\n        revert();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Event emitters\n    //----------------------------------------------------------------------------------------------\n\n    function onDepositClaimable(address controller, uint256 assets, uint256 shares) public virtual auth {\n        emit DepositClaimable(controller, REQUEST_ID, assets, shares);\n    }\n\n    function onCancelDepositClaimable(address controller, uint256 assets) public virtual auth {\n        emit CancelDepositClaimable(controller, REQUEST_ID, assets);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // IBaseVault view\n    //----------------------------------------------------------------------------------------------\n\n    function vaultKind() public pure returns (VaultKind vaultKind_) {\n        return VaultKind.Async;\n    }\n}\n"
    },
    "src/vaults/BalanceSheet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {IERC6909} from \"src/misc/interfaces/IERC6909.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {MessageLib, UpdateContractType} from \"src/common/libraries/MessageLib.sol\";\nimport {IVaultMessageSender} from \"../common/interfaces/IGatewaySenders.sol\";\nimport {IBalanceSheetGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IPoolManager} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBalanceSheet, QueueAmount} from \"src/vaults/interfaces/IBalanceSheet.sol\";\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {IUpdateContract} from \"src/vaults/interfaces/IUpdateContract.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\n\n/// @title  Balance Sheet\n/// @notice Management contract that integrates all balance sheet functions of a pool:\n///         - Issuing and revoking shares\n///         - Depositing and withdrawing assets\n///         - Force transferring shares\n///\n///         Share and asset updates to the Hub are optionally queued, to reduce the cost\n///         per transaction. Dequeuing can be triggered locally by the manager or from the Hub.\ncontract BalanceSheet is Auth, Recoverable, IBalanceSheet, IBalanceSheetGatewayHandler, IUpdateContract {\n    using MathLib for *;\n    using CastLib for bytes32;\n\n    IRoot public immutable root;\n\n    IPoolManager public poolManager;\n    IVaultMessageSender public sender;\n    IPoolEscrowProvider public poolEscrowProvider;\n\n    mapping(PoolId => mapping(address => bool)) public manager;\n    mapping(PoolId poolId => mapping(ShareClassId scId => bool)) public queueEnabled;\n    mapping(PoolId poolId => mapping(ShareClassId scId => QueueAmount)) public queuedShares;\n    mapping(PoolId poolId => mapping(ShareClassId scId => mapping(AssetId assetId => QueueAmount))) public queuedAssets;\n\n    constructor(IRoot root_, address deployer) Auth(deployer) {\n        root = root_;\n    }\n\n    /// @dev Check if the msg.sender is ward or a manager\n    modifier authOrManager(PoolId poolId) {\n        require(wards[msg.sender] == 1 || manager[poolId][msg.sender], IAuth.NotAuthorized());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    function file(bytes32 what, address data) external auth {\n        if (what == \"poolManager\") poolManager = IPoolManager(data);\n        else if (what == \"sender\") sender = IVaultMessageSender(data);\n        else if (what == \"poolEscrowProvider\") poolEscrowProvider = IPoolEscrowProvider(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    function update(PoolId poolId, ShareClassId, /* scId */ bytes calldata payload) external auth {\n        uint8 kind = uint8(MessageLib.updateContractType(payload));\n\n        if (kind == uint8(UpdateContractType.UpdateManager)) {\n            MessageLib.UpdateContractUpdateManager memory m = MessageLib.deserializeUpdateContractUpdateManager(payload);\n            address who = m.who.toAddress();\n\n            manager[poolId][who] = m.canManage;\n            emit UpdateManager(poolId, who, m.canManage);\n        } else {\n            revert UnknownUpdateContractType();\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Management functions\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheet\n    function deposit(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, address owner, uint128 amount)\n        external\n        authOrManager(poolId)\n    {\n        AssetId assetId = poolManager.assetToId(asset, tokenId);\n        _noteDeposit(poolId, scId, assetId, asset, tokenId, owner, amount);\n        _executeDeposit(poolId, asset, tokenId, owner, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    /// @dev This function is mostly useful to keep higher level integrations CEI adherent.\n    function noteDeposit(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address owner,\n        uint128 amount\n    ) external authOrManager(poolId) {\n        AssetId assetId = poolManager.assetToId(asset, tokenId);\n        _noteDeposit(poolId, scId, assetId, asset, tokenId, owner, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function withdraw(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount\n    ) external authOrManager(poolId) {\n        AssetId assetId = poolManager.assetToId(asset, tokenId);\n        _withdraw(poolId, scId, assetId, asset, tokenId, receiver, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function issue(PoolId poolId, ShareClassId scId, address to, uint128 shares) external authOrManager(poolId) {\n        _issue(poolId, scId, to, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function revoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) external authOrManager(poolId) {\n        _noteRevoke(poolId, scId, from, shares);\n        _executeRevoke(poolId, scId, from, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    /// @dev This function is mostly useful to keep higher level integrations CEI adherent.\n    function noteRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares)\n        external\n        authOrManager(poolId)\n    {\n        _noteRevoke(poolId, scId, from, shares);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function transferSharesFrom(PoolId poolId, ShareClassId scId, address from, address to, uint256 amount)\n        external\n        authOrManager(poolId)\n    {\n        require(!root.endorsed(from), CannotTransferFromEndorsedContract());\n        IShareToken token = IShareToken(poolManager.shareToken(poolId, scId));\n        token.authTransferFrom(from, from, to, amount);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function overridePricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 value)\n        external\n        authOrManager(poolId)\n    {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAsset\", poolId, scId, assetId)), value.raw());\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)), true);\n    }\n\n    /// @inheritdoc IBalanceSheet\n    function overridePricePoolPerShare(PoolId poolId, ShareClassId scId, D18 value) external authOrManager(poolId) {\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerShare\", poolId, scId)), value.raw());\n        TransientStorageLib.tstore(keccak256(abi.encode(\"pricePoolPerShareIsSet\", poolId, scId)), true);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Gateway handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function triggerDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, address owner, uint128 amount)\n        external\n        auth\n    {\n        (address asset, uint256 tokenId) = poolManager.idToAsset(assetId);\n        _noteDeposit(poolId, scId, assetId, asset, tokenId, owner, amount);\n        _executeDeposit(poolId, asset, tokenId, owner, amount);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function triggerWithdraw(PoolId poolId, ShareClassId scId, AssetId assetId, address receiver, uint128 amount)\n        external\n        auth\n    {\n        (address asset, uint256 tokenId) = poolManager.idToAsset(assetId);\n        _withdraw(poolId, scId, assetId, asset, tokenId, receiver, amount);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function triggerIssueShares(PoolId poolId, ShareClassId scId, address receiver, uint128 shares) external auth {\n        _issue(poolId, scId, receiver, shares);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function setQueue(PoolId poolId, ShareClassId scId, bool enabled) external auth {\n        queueEnabled[poolId][scId] = enabled;\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function submitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) external authOrManager(poolId) {\n        _submitQueuedAssets(poolId, scId, assetId);\n    }\n\n    /// @inheritdoc IBalanceSheetGatewayHandler\n    function submitQueuedShares(PoolId poolId, ShareClassId scId) external authOrManager(poolId) {\n        _submitQueuedShares(poolId, scId);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal\n    //----------------------------------------------------------------------------------------------\n\n    function _noteDeposit(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address asset,\n        uint256 tokenId,\n        address owner,\n        uint128 amount\n    ) internal {\n        IPoolEscrow escrow = poolEscrowProvider.escrow(poolId);\n        escrow.deposit(scId, asset, tokenId, amount);\n\n        D18 pricePoolPerAsset_ = _pricePoolPerAsset(poolId, scId, assetId);\n        emit Deposit(poolId, scId, asset, tokenId, owner, amount, pricePoolPerAsset_);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedAssets[poolId][scId][assetId].increase += amount;\n        } else {\n            sender.sendUpdateHoldingAmount(poolId, scId, assetId, owner, amount, pricePoolPerAsset_, true);\n        }\n    }\n\n    function _executeDeposit(PoolId poolId, address asset, uint256 tokenId, address owner, uint128 amount) internal {\n        IPoolEscrow escrow = poolEscrowProvider.escrow(poolId);\n        if (tokenId == 0) {\n            SafeTransferLib.safeTransferFrom(asset, owner, address(escrow), amount);\n        } else {\n            IERC6909(asset).transferFrom(owner, address(escrow), tokenId, amount);\n        }\n    }\n\n    function _withdraw(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount\n    ) internal {\n        IPoolEscrow escrow = poolEscrowProvider.escrow(poolId);\n        escrow.withdraw(scId, asset, tokenId, amount);\n\n        D18 pricePoolPerAsset_ = _pricePoolPerAsset(poolId, scId, assetId);\n        emit Withdraw(poolId, scId, asset, tokenId, receiver, amount, pricePoolPerAsset_);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedAssets[poolId][scId][assetId].decrease += amount;\n        } else {\n            sender.sendUpdateHoldingAmount(poolId, scId, assetId, receiver, amount, pricePoolPerAsset_, false);\n        }\n\n        escrow.authTransferTo(asset, tokenId, receiver, amount);\n    }\n\n    function _issue(PoolId poolId, ShareClassId scId, address to, uint128 shares) internal {\n        emit Issue(poolId, scId, to, _pricePoolPerShare(poolId, scId), shares);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedShares[poolId][scId].increase += shares;\n        } else {\n            sender.sendUpdateShares(poolId, scId, shares, true);\n        }\n\n        IShareToken token = poolManager.shareToken(poolId, scId);\n        token.mint(to, shares);\n    }\n\n    function _noteRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) internal {\n        emit Revoke(poolId, scId, from, _pricePoolPerShare(poolId, scId), shares);\n\n        if (queueEnabled[poolId][scId]) {\n            queuedShares[poolId][scId].decrease += shares;\n        } else {\n            sender.sendUpdateShares(poolId, scId, shares, false);\n        }\n    }\n\n    function _executeRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) internal {\n        IShareToken token = poolManager.shareToken(poolId, scId);\n        token.authTransferFrom(from, from, address(this), shares);\n        token.burn(address(this), shares);\n    }\n\n    function _submitQueuedShares(PoolId poolId, ShareClassId scId) internal {\n        QueueAmount storage queue = queuedShares[poolId][scId];\n\n        if (queue.increase > queue.decrease) {\n            sender.sendUpdateShares(poolId, scId, queue.increase - queue.decrease, true);\n        } else if (queue.decrease > queue.increase) {\n            sender.sendUpdateShares(poolId, scId, queue.decrease - queue.increase, false);\n        }\n\n        queue.increase = 0;\n        queue.decrease = 0;\n    }\n\n    function _submitQueuedAssets(PoolId poolId, ShareClassId scId, AssetId assetId) internal {\n        QueueAmount storage queue = queuedAssets[poolId][scId][assetId];\n\n        D18 pricePoolPerAsset = _pricePoolPerAsset(poolId, scId, assetId);\n        if (queue.increase > queue.decrease) {\n            sender.sendUpdateHoldingAmount(\n                poolId, scId, assetId, address(0), queue.increase - queue.decrease, pricePoolPerAsset, true\n            );\n        } else if (queue.decrease > queue.increase) {\n            sender.sendUpdateHoldingAmount(\n                poolId, scId, assetId, address(0), queue.decrease - queue.increase, pricePoolPerAsset, false\n            );\n        }\n\n        queue.increase = 0;\n        queue.decrease = 0;\n    }\n\n    function _pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId) internal view returns (D18) {\n        if (TransientStorageLib.tloadBool(keccak256(abi.encode(\"pricePoolPerAssetIsSet\", poolId, scId, assetId)))) {\n            return\n                d18(TransientStorageLib.tloadUint128(keccak256(abi.encode(\"pricePoolPerAsset\", poolId, scId, assetId))));\n        }\n\n        D18 pricePoolPerAsset = poolManager.pricePoolPerAsset(poolId, scId, assetId, true);\n        return pricePoolPerAsset;\n    }\n\n    function _pricePoolPerShare(PoolId poolId, ShareClassId scId) internal view returns (D18) {\n        if (TransientStorageLib.tloadBool(keccak256(abi.encode(\"pricePoolPerShareIsSet\", poolId, scId)))) {\n            return d18(TransientStorageLib.tloadUint128(keccak256(abi.encode(\"pricePoolPerShare\", poolId, scId))));\n        }\n\n        D18 pricePoolPerShare = poolManager.pricePoolPerShare(poolId, scId, true);\n        return pricePoolPerShare;\n    }\n}\n"
    },
    "src/vaults/BaseRequestManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {D18} from \"src/misc/types/D18.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IPoolManager, VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IBaseVault, VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IPoolEscrow, IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\nabstract contract BaseRequestManager is Auth, Recoverable, IBaseRequestManager {\n    using MathLib for uint256;\n\n    address public immutable root;\n    IEscrow public immutable globalEscrow;\n\n    IPoolManager public poolManager;\n    IPoolEscrowProvider public poolEscrowProvider;\n\n    mapping(PoolId poolId => mapping(ShareClassId scId => mapping(AssetId assetId => IBaseVault vault))) public vault;\n\n    constructor(IEscrow globalEscrow_, address root_, address deployer) Auth(deployer) {\n        globalEscrow = globalEscrow_;\n        root = root_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBaseRequestManager\n    function file(bytes32 what, address data) external virtual auth {\n        if (what == \"poolManager\") poolManager = IPoolManager(data);\n        else if (what == \"poolEscrowProvider\") poolEscrowProvider = IPoolEscrowProvider(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function addVault(PoolId poolId, ShareClassId scId, IBaseVault vault_, address asset_, AssetId assetId)\n        public\n        virtual\n        auth\n    {\n        address token = vault_.share();\n\n        require(vault_.asset() == asset_, AssetMismatch());\n        require(address(vault[poolId][scId][assetId]) == address(0), VaultAlreadyExists());\n\n        vault[poolId][scId][assetId] = IBaseVault(address(vault_));\n        IAuth(token).rely(address(vault_));\n        IShareToken(token).updateVault(vault_.asset(), address(vault_));\n        rely(address(vault_));\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function removeVault(PoolId poolId, ShareClassId scId, IBaseVault vault_, address asset_, AssetId assetId)\n        public\n        virtual\n        auth\n    {\n        address token = vault_.share();\n\n        require(vault_.asset() == asset_, AssetMismatch());\n        require(address(vault[poolId][scId][assetId]) != address(0), VaultDoesNotExist());\n\n        delete vault[poolId][scId][assetId];\n\n        IAuth(token).deny(address(vault_));\n        IShareToken(token).updateVault(vault_.asset(), address(0));\n        deny(address(vault_));\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBaseRequestManager\n    function convertToShares(IBaseVault vault_, uint256 assets) public view virtual returns (uint256 shares) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        (D18 pricePoolPerAsset, D18 pricePoolPerShare) =\n            poolManager.pricesPoolPer(vault_.poolId(), vault_.scId(), vaultDetails.assetId, false);\n\n        return _assetToShareAmount(\n            vault_, vaultDetails, assets, pricePoolPerAsset, pricePoolPerShare, MathLib.Rounding.Down\n        );\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function convertToAssets(IBaseVault vault_, uint256 shares) public view virtual returns (uint256 assets) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        (D18 pricePoolPerAsset, D18 pricePoolPerShare) =\n            poolManager.pricesPoolPer(vault_.poolId(), vault_.scId(), vaultDetails.assetId, false);\n\n        return _shareToAssetAmount(\n            vault_, vaultDetails, shares, pricePoolPerAsset, pricePoolPerShare, MathLib.Rounding.Down\n        );\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function priceLastUpdated(IBaseVault vault_) public view virtual returns (uint64 lastUpdated) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n\n        (uint64 shareLastUpdated,,) = poolManager.markersPricePoolPerShare(vault_.poolId(), vault_.scId());\n        (uint64 assetLastUpdated,,) =\n            poolManager.markersPricePoolPerAsset(vault_.poolId(), vault_.scId(), vaultDetails.assetId);\n\n        // Choose the latest update to be the marker\n        lastUpdated = MathLib.max(shareLastUpdated, assetLastUpdated).toUint64();\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function poolEscrow(PoolId poolId) public view returns (IPoolEscrow) {\n        return poolEscrowProvider.escrow(poolId);\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function vaultByAssetId(PoolId poolId, ShareClassId scId, AssetId assetId) public view returns (IBaseVault) {\n        return vault[poolId][scId][assetId];\n    }\n\n    function _assetToShareAmount(\n        IBaseVault vault_,\n        VaultDetails memory vaultDetails,\n        uint256 assets,\n        D18 pricePoolPerAsset,\n        D18 pricePoolPerShare,\n        MathLib.Rounding rounding\n    ) internal view returns (uint256 shares) {\n        return PricingLib.assetToShareAmount(\n            vault_.share(),\n            vaultDetails.asset,\n            vaultDetails.tokenId,\n            assets.toUint128(),\n            pricePoolPerAsset,\n            pricePoolPerShare,\n            rounding\n        );\n    }\n\n    function _shareToAssetAmount(\n        IBaseVault vault_,\n        VaultDetails memory vaultDetails,\n        uint256 shares,\n        D18 pricePoolPerAsset,\n        D18 pricePoolPerShare,\n        MathLib.Rounding rounding\n    ) internal view returns (uint256 assets) {\n        return PricingLib.shareToAssetAmount(\n            vault_.share(),\n            shares.toUint128(),\n            vaultDetails.asset,\n            vaultDetails.tokenId,\n            pricePoolPerAsset,\n            pricePoolPerShare,\n            rounding\n        );\n    }\n}\n"
    },
    "src/vaults/BaseVaults.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"src/misc/interfaces/IERC7540.sol\";\nimport \"src/misc/interfaces/IERC7575.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {IERC20Metadata} from \"src/misc/interfaces/IERC20.sol\";\nimport {EIP712Lib} from \"src/misc/libraries/EIP712Lib.sol\";\nimport {SignatureLib} from \"src/misc/libraries/SignatureLib.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IBaseVault, IAsyncRedeemVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IERC7575} from \"src/misc/interfaces/IERC7575.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\nimport {ISyncDepositManager} from \"src/vaults/interfaces/investments/ISyncDepositManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\nabstract contract BaseVault is Auth, Recoverable, IBaseVault {\n    /// @dev Requests for Centrifuge pool are non-fungible and all have ID = 0\n    uint256 internal constant REQUEST_ID = 0;\n\n    IRoot public immutable root;\n    /// @dev this naming MUST NEVER change - due to legacy v2 vaults\n    IBaseRequestManager public manager;\n\n    /// @inheritdoc IBaseVault\n    PoolId public immutable poolId;\n    /// @inheritdoc IBaseVault\n    ShareClassId public immutable scId;\n\n    /// @inheritdoc IERC7575\n    address public immutable asset;\n\n    /// @inheritdoc IERC7575\n    address public immutable share;\n    uint8 internal immutable _shareDecimals;\n\n    /// --- ERC7741 ---\n    bytes32 private immutable nameHash;\n    bytes32 private immutable versionHash;\n    uint256 public immutable deploymentChainId;\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    bytes32 public constant AUTHORIZE_OPERATOR_TYPEHASH =\n        keccak256(\"AuthorizeOperator(address controller,address operator,bool approved,bytes32 nonce,uint256 deadline)\");\n\n    /// @inheritdoc IERC7741\n    mapping(address controller => mapping(bytes32 nonce => bool used)) public authorizations;\n\n    /// @inheritdoc IERC7540Operator\n    mapping(address => mapping(address => bool)) public isOperator;\n\n    constructor(\n        PoolId poolId_,\n        ShareClassId scId_,\n        address asset_,\n        IShareToken token_,\n        address root_,\n        IBaseRequestManager manager_\n    ) Auth(msg.sender) {\n        poolId = poolId_;\n        scId = scId_;\n        asset = asset_;\n        share = address(token_);\n        _shareDecimals = IERC20Metadata(share).decimals();\n        root = IRoot(root_);\n        manager = IBaseRequestManager(manager_);\n\n        nameHash = keccak256(bytes(\"Centrifuge\"));\n        versionHash = keccak256(bytes(\"1\"));\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    function file(bytes32 what, address data) external virtual auth {\n        if (what == \"manager\") manager = IBaseRequestManager(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IERC7540Operator\n    function setOperator(address operator, bool approved) public virtual returns (bool success) {\n        require(msg.sender != operator, CannotSetSelfAsOperator());\n        isOperator[msg.sender][operator] = approved;\n        emit OperatorSet(msg.sender, operator, approved);\n        success = true;\n    }\n\n    /// @inheritdoc IBaseVault\n    function setEndorsedOperator(address owner, bool approved) public virtual {\n        require(msg.sender != owner, CannotSetSelfAsOperator());\n        require(root.endorsed(msg.sender), NotEndorsed());\n        isOperator[owner][msg.sender] = approved;\n        emit OperatorSet(owner, msg.sender, approved);\n    }\n\n    /// @inheritdoc IERC7741\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return block.chainid == deploymentChainId\n            ? _DOMAIN_SEPARATOR\n            : EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\n    }\n\n    /// @inheritdoc IERC7741\n    function authorizeOperator(\n        address controller,\n        address operator,\n        bool approved,\n        bytes32 nonce,\n        uint256 deadline,\n        bytes memory signature\n    ) external returns (bool success) {\n        require(controller != operator, CannotSetSelfAsOperator());\n        require(block.timestamp <= deadline, ExpiredAuthorization());\n        require(!authorizations[controller][nonce], AlreadyUsedAuthorization());\n\n        authorizations[controller][nonce] = true;\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(AUTHORIZE_OPERATOR_TYPEHASH, controller, operator, approved, nonce, deadline))\n            )\n        );\n\n        require(SignatureLib.isValidSignature(controller, digest, signature), InvalidAuthorization());\n\n        isOperator[controller][operator] = approved;\n        emit OperatorSet(controller, operator, approved);\n\n        success = true;\n    }\n\n    /// @inheritdoc IERC7741\n    function invalidateNonce(bytes32 nonce) external {\n        authorizations[msg.sender][nonce] = true;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n        return interfaceId == type(IERC7540Operator).interfaceId || interfaceId == type(IERC7741).interfaceId\n            || interfaceId == type(IERC7714).interfaceId || interfaceId == type(IERC7575).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-4626\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7575\n    function totalAssets() external view returns (uint256) {\n        return convertToAssets(IERC20Metadata(share).totalSupply());\n    }\n\n    /// @inheritdoc IERC7575\n    /// @notice     The calculation is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///             The actual conversion MAY change between order submission and execution.\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\n        shares = manager.convertToShares(this, assets);\n    }\n\n    /// @inheritdoc IERC7575\n    /// @notice     The calculation is based on the token price from the most recent epoch retrieved from Centrifuge.\n    ///             The actual conversion MAY change between order submission and execution.\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\n        assets = manager.convertToAssets(this, shares);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------------------------------\n\n    /// @notice Price of 1 unit of share, quoted in the decimals of the asset.\n    function pricePerShare() external view returns (uint256) {\n        return convertToAssets(10 ** _shareDecimals);\n    }\n\n    /// @notice Returns timestamp of the last share price update.\n    function priceLastUpdated() external view returns (uint64) {\n        return manager.priceLastUpdated(this);\n    }\n\n    /// @inheritdoc IERC7714\n    function isPermissioned(address controller) external view returns (bool) {\n        return IShareToken(share).checkTransferRestriction(address(0), controller, 0);\n    }\n\n    /// @notice Ensures msg.sender can operate on behalf of controller.\n    function _validateController(address controller) internal view {\n        require(controller == msg.sender || isOperator[controller][msg.sender], InvalidController());\n    }\n}\n\nabstract contract BaseAsyncRedeemVault is BaseVault, IAsyncRedeemVault {\n    IAsyncRedeemManager public asyncRedeemManager;\n\n    constructor(IAsyncRedeemManager asyncRequestManager_) {\n        asyncRedeemManager = asyncRequestManager_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    function file(bytes32 what, address data) external virtual override auth {\n        if (what == \"manager\") manager = IBaseRequestManager(data);\n        else if (what == \"asyncRedeemManager\") asyncRedeemManager = IAsyncRedeemManager(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-7540 redeem\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7540Redeem\n    function requestRedeem(uint256 shares, address controller, address owner) public returns (uint256) {\n        require(IShareToken(share).balanceOf(owner) >= shares, InsufficientBalance());\n\n        // If msg.sender is operator of owner, the transfer is executed as if\n        // the sender is the owner, to bypass the allowance check\n        address sender = isOperator[owner][msg.sender] ? owner : msg.sender;\n\n        require(asyncRedeemManager.requestRedeem(this, shares, controller, owner, sender), RequestRedeemFailed());\n        IShareToken(share).authTransferFrom(sender, owner, address(manager.globalEscrow()), shares);\n\n        emit RedeemRequest(controller, owner, REQUEST_ID, msg.sender, shares);\n        return REQUEST_ID;\n    }\n\n    /// @inheritdoc IERC7540Redeem\n    function pendingRedeemRequest(uint256, address controller) public view returns (uint256 pendingShares) {\n        pendingShares = asyncRedeemManager.pendingRedeemRequest(this, controller);\n    }\n\n    /// @inheritdoc IERC7540Redeem\n    function claimableRedeemRequest(uint256, address controller) external view returns (uint256 claimableShares) {\n        claimableShares = maxRedeem(controller);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-7887\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7887Redeem\n    function cancelRedeemRequest(uint256, address controller) external {\n        _validateController(controller);\n        asyncRedeemManager.cancelRedeemRequest(this, controller, msg.sender);\n        emit CancelRedeemRequest(controller, REQUEST_ID, msg.sender);\n    }\n\n    /// @inheritdoc IERC7887Redeem\n    function pendingCancelRedeemRequest(uint256, address controller) public view returns (bool isPending) {\n        isPending = asyncRedeemManager.pendingCancelRedeemRequest(this, controller);\n    }\n\n    /// @inheritdoc IERC7887Redeem\n    function claimableCancelRedeemRequest(uint256, address controller) public view returns (uint256 claimableShares) {\n        claimableShares = asyncRedeemManager.claimableCancelRedeemRequest(this, controller);\n    }\n\n    /// @inheritdoc IERC7887Redeem\n    function claimCancelRedeemRequest(uint256, address receiver, address controller)\n        external\n        returns (uint256 shares)\n    {\n        _validateController(controller);\n        shares = asyncRedeemManager.claimCancelRedeemRequest(this, receiver, controller);\n        emit CancelRedeemClaim(receiver, controller, REQUEST_ID, msg.sender, shares);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-7540 claim\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7575\n    /// @notice     DOES NOT support controller != msg.sender since shares are already transferred on requestRedeem\n    function withdraw(uint256 assets, address receiver, address controller) public returns (uint256 shares) {\n        _validateController(controller);\n        shares = asyncRedeemManager.withdraw(this, assets, receiver, controller);\n        emit Withdraw(msg.sender, receiver, controller, assets, shares);\n    }\n\n    /// @inheritdoc IERC7575\n    /// @notice     DOES NOT support controller != msg.sender since shares are already transferred on requestRedeem.\n    ///             When claiming redemption requests using redeem(), there can be some precision loss leading to dust.\n    ///             It is recommended to use withdraw() to claim redemption requests instead.\n    function redeem(uint256 shares, address receiver, address controller) external returns (uint256 assets) {\n        _validateController(controller);\n        assets = asyncRedeemManager.redeem(this, shares, receiver, controller);\n        emit Withdraw(msg.sender, receiver, controller, assets, shares);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Event emitters\n    //----------------------------------------------------------------------------------------------\n\n    function onRedeemRequest(address controller, address owner, uint256 shares) public virtual auth {\n        emit RedeemRequest(controller, owner, REQUEST_ID, msg.sender, shares);\n    }\n\n    function onRedeemClaimable(address controller, uint256 assets, uint256 shares) public virtual auth {\n        emit RedeemClaimable(controller, REQUEST_ID, assets, shares);\n    }\n\n    function onCancelRedeemClaimable(address controller, uint256 shares) public virtual auth {\n        emit CancelRedeemClaimable(controller, REQUEST_ID, shares);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public pure virtual override(BaseVault, IERC165) returns (bool) {\n        return super.supportsInterface(interfaceId) || interfaceId == type(IERC7540Redeem).interfaceId\n            || interfaceId == type(IERC7887Redeem).interfaceId;\n    }\n\n    /// @inheritdoc IERC7575\n    function maxWithdraw(address controller) public view returns (uint256 maxAssets) {\n        maxAssets = asyncRedeemManager.maxWithdraw(this, controller);\n    }\n\n    /// @inheritdoc IERC7575\n    function maxRedeem(address controller) public view returns (uint256 maxShares) {\n        maxShares = asyncRedeemManager.maxRedeem(this, controller);\n    }\n\n    /// @dev Preview functions for ERC-7540 vaults revert\n    function previewWithdraw(uint256) external pure returns (uint256) {\n        revert();\n    }\n\n    /// @dev Preview functions for ERC-7540 vaults revert\n    function previewRedeem(uint256) external pure returns (uint256) {\n        revert();\n    }\n}\n\nabstract contract BaseSyncDepositVault is BaseVault {\n    ISyncDepositManager public syncDepositManager;\n\n    constructor(ISyncDepositManager syncRequestManager_) {\n        syncDepositManager = syncRequestManager_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-4626\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC7575\n    function maxDeposit(address owner) public view returns (uint256 maxAssets) {\n        maxAssets = syncDepositManager.maxDeposit(this, owner);\n    }\n\n    /// @inheritdoc IERC7575\n    function previewDeposit(uint256 assets) external view override returns (uint256 shares) {\n        shares = syncDepositManager.previewDeposit(this, msg.sender, assets);\n    }\n\n    /// @inheritdoc IERC7575\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {\n        shares = syncDepositManager.deposit(this, assets, receiver, msg.sender);\n        // NOTE: For security reasons, transfer must stay at end of call despite the fact that it logically should\n        // happen before depositing in the manager\n        SafeTransferLib.safeTransferFrom(asset, msg.sender, address(manager.poolEscrow(poolId)), assets);\n        emit Deposit(receiver, msg.sender, assets, shares);\n    }\n\n    /// @inheritdoc IERC7575\n    function maxMint(address owner) public view returns (uint256 maxShares) {\n        maxShares = syncDepositManager.maxMint(this, owner);\n    }\n\n    /// @inheritdoc IERC7575\n    function previewMint(uint256 shares) external view returns (uint256 assets) {\n        assets = syncDepositManager.previewMint(this, msg.sender, shares);\n    }\n\n    /// @inheritdoc IERC7575\n    function mint(uint256 shares, address receiver) public returns (uint256 assets) {\n        assets = syncDepositManager.mint(this, shares, receiver, msg.sender);\n        // NOTE: For security reasons, transfer must stay at end of call\n        SafeTransferLib.safeTransferFrom(asset, msg.sender, address(manager.poolEscrow(poolId)), assets);\n        emit Deposit(receiver, msg.sender, assets, shares);\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public pure virtual override(BaseVault) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "src/vaults/Escrow.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC6909} from \"src/misc/interfaces/IERC6909.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {Holding, IPoolEscrow, IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\n\ncontract Escrow is Auth, IEscrow {\n    constructor(address deployer) Auth(deployer) {}\n\n    /// @inheritdoc IEscrow\n    function authTransferTo(address asset, uint256 tokenId, address receiver, uint256 amount) public auth {\n        if (tokenId == 0) {\n            uint256 balance = IERC20(asset).balanceOf(address(this));\n            require(balance >= amount, InsufficientBalance(asset, tokenId, amount, balance));\n\n            SafeTransferLib.safeTransfer(asset, receiver, amount);\n        } else {\n            uint256 balance = IERC6909(asset).balanceOf(address(this), tokenId);\n            require(balance >= amount, InsufficientBalance(asset, tokenId, amount, balance));\n\n            IERC6909(asset).transfer(receiver, tokenId, amount);\n        }\n\n        emit AuthTransferTo(asset, tokenId, receiver, amount);\n    }\n\n    /// @inheritdoc IEscrow\n    function authTransferTo(address asset, address receiver, uint256 amount) external auth {\n        authTransferTo(asset, 0, receiver, amount);\n    }\n}\n\n/// @title  Escrow\n/// @notice Escrow contract that holds assets for a specific pool separated by share classes.\n///         Only wards can approve funds to be taken out.\ncontract PoolEscrow is Escrow, Recoverable, IPoolEscrow {\n    /// @dev The underlying pool id\n    PoolId public immutable poolId;\n\n    mapping(ShareClassId scId => mapping(address asset => mapping(uint256 tokenId => Holding))) public holding;\n\n    constructor(PoolId poolId_, address deployer) Escrow(deployer) {\n        poolId = poolId_;\n    }\n\n    receive() external payable {}\n\n    /// @inheritdoc IPoolEscrow\n    function deposit(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external auth {\n        holding[scId][asset][tokenId].total += value;\n\n        emit Deposit(asset, tokenId, poolId, scId, value);\n    }\n\n    /// @inheritdoc IPoolEscrow\n    function withdraw(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external auth {\n        Holding storage holding_ = holding[scId][asset][tokenId];\n        uint128 balance = holding_.total - holding_.reserved;\n        require(balance >= value, InsufficientBalance(asset, tokenId, value, balance));\n\n        holding_.total -= value;\n\n        emit Withdraw(asset, tokenId, poolId, scId, value);\n    }\n\n    /// @inheritdoc IPoolEscrow\n    function reserveIncrease(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external auth {\n        uint128 newValue = holding[scId][asset][tokenId].reserved + value;\n        holding[scId][asset][tokenId].reserved = newValue;\n\n        emit IncreaseReserve(asset, tokenId, poolId, scId, value, newValue);\n    }\n\n    /// @inheritdoc IPoolEscrow\n    function reserveDecrease(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external auth {\n        uint128 prevValue = holding[scId][asset][tokenId].reserved;\n        uint128 value_ = value;\n        require(prevValue >= value_, InsufficientReservedAmount());\n\n        uint128 newValue = prevValue - value_;\n        holding[scId][asset][tokenId].reserved = newValue;\n\n        emit DecreaseReserve(asset, tokenId, poolId, scId, value, newValue);\n    }\n\n    /// @inheritdoc IPoolEscrow\n    function availableBalanceOf(ShareClassId scId, address asset, uint256 tokenId) public view returns (uint128) {\n        Holding storage holding_ = holding[scId][asset][tokenId];\n        if (holding_.total < holding_.reserved) return 0;\n        return holding_.total - holding_.reserved;\n    }\n}\n"
    },
    "src/vaults/PoolManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata, IERC20Wrapper} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC6909MetadataExt} from \"src/misc/interfaces/IERC6909.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {D18} from \"src/misc/types/D18.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\nimport {ReentrancyProtection} from \"src/misc/ReentrancyProtection.sol\";\n\nimport {VaultUpdateKind, MessageLib, UpdateContractType} from \"src/common/libraries/MessageLib.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IPoolManagerGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\nimport {IVaultMessageSender} from \"src/common/interfaces/IGatewaySenders.sol\";\nimport {newAssetId, AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nimport {IVaultFactory} from \"src/vaults/interfaces/factories/IVaultFactory.sol\";\nimport {IBaseVault, VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {ITokenFactory} from \"src/vaults/interfaces/factories/ITokenFactory.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IPoolEscrowFactory} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\nimport {IUpdateContract} from \"src/vaults/interfaces/IUpdateContract.sol\";\nimport {\n    AssetIdKey,\n    Pool,\n    ShareClassDetails,\n    Price,\n    VaultDetails,\n    IPoolManager\n} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {ISyncRequestManager} from \"src/vaults/interfaces/investments/ISyncRequestManager.sol\";\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\n\n/// @title  Pool Manager\n/// @notice This contract manages which pools & share classes exist,\n///         as well as managing allowed pool currencies, and incoming and outgoing transfers.\ncontract PoolManager is\n    Auth,\n    Recoverable,\n    ReentrancyProtection,\n    IPoolManager,\n    IUpdateContract,\n    IPoolManagerGatewayHandler\n{\n    using CastLib for *;\n    using MessageLib for *;\n    using BytesLib for bytes;\n    using MathLib for uint256;\n\n    uint8 internal constant MIN_DECIMALS = 2;\n    uint8 internal constant MAX_DECIMALS = 18;\n\n    IGateway public gateway;\n    address public balanceSheet;\n    ITokenFactory public tokenFactory;\n    IVaultMessageSender public sender;\n    IPoolEscrowFactory public poolEscrowFactory;\n    IAsyncRequestManager public asyncRequestManager;\n    ISyncRequestManager public syncRequestManager;\n\n    uint64 internal _assetCounter;\n\n    mapping(PoolId poolId => Pool) public pools;\n    mapping(IVaultFactory factory => bool) public vaultFactory;\n\n    mapping(IBaseVault => VaultDetails) internal _vaultDetails;\n    mapping(AssetId assetId => AssetIdKey) internal _idToAsset;\n    mapping(address asset => mapping(uint256 tokenId => AssetId assetId)) internal _assetToId;\n\n    constructor(ITokenFactory tokenFactory_, address deployer) Auth(deployer) {\n        tokenFactory = tokenFactory_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPoolManager\n    function file(bytes32 what, address data) external auth {\n        if (what == \"sender\") sender = IVaultMessageSender(data);\n        else if (what == \"tokenFactory\") tokenFactory = ITokenFactory(data);\n        else if (what == \"gateway\") gateway = IGateway(data);\n        else if (what == \"balanceSheet\") balanceSheet = data;\n        else if (what == \"poolEscrowFactory\") poolEscrowFactory = IPoolEscrowFactory(data);\n        else if (what == \"asyncRequestManager\") asyncRequestManager = IAsyncRequestManager(data);\n        else if (what == \"syncRequestManager\") syncRequestManager = ISyncRequestManager(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IPoolManager\n    function file(bytes32 what, address factory, bool status) external auth {\n        if (what == \"vaultFactory\") {\n            vaultFactory[IVaultFactory(factory)] = status;\n        } else {\n            revert FileUnrecognizedParam();\n        }\n        emit File(what, factory, status);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Outgoing methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPoolManager\n    function transferShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes32 receiver, uint128 amount)\n        external\n        payable\n        protected\n    {\n        IShareToken share = IShareToken(shareToken(poolId, scId));\n        require(centrifugeId != sender.localCentrifugeId(), LocalTransferNotAllowed());\n        require(\n            share.checkTransferRestriction(msg.sender, address(uint160(centrifugeId)), amount),\n            CrossChainTransferNotAllowed()\n        );\n\n        gateway.payTransaction{value: msg.value}(msg.sender);\n\n        share.authTransferFrom(msg.sender, msg.sender, address(this), amount);\n        share.burn(address(this), amount);\n\n        emit TransferShares(centrifugeId, poolId, scId, msg.sender, receiver, amount);\n        sender.sendTransferShares(centrifugeId, poolId, scId, receiver, amount);\n    }\n\n    // @inheritdoc IPoolManager\n    function registerAsset(uint16 centrifugeId, address asset, uint256 tokenId)\n        external\n        payable\n        protected\n        returns (AssetId assetId)\n    {\n        string memory name;\n        string memory symbol;\n        uint8 decimals;\n\n        decimals = _safeGetAssetDecimals(asset, tokenId);\n        require(decimals >= MIN_DECIMALS, TooFewDecimals());\n        require(decimals <= MAX_DECIMALS, TooManyDecimals());\n\n        gateway.payTransaction{value: msg.value}(msg.sender);\n\n        if (tokenId == 0) {\n            IERC20Metadata meta = IERC20Metadata(asset);\n            name = meta.name();\n            symbol = meta.symbol();\n        } else {\n            IERC6909MetadataExt meta = IERC6909MetadataExt(asset);\n            name = meta.name(tokenId);\n            symbol = meta.symbol(tokenId);\n        }\n\n        assetId = _assetToId[asset][tokenId];\n        if (assetId.raw() == 0) {\n            _assetCounter++;\n            assetId = newAssetId(sender.localCentrifugeId(), _assetCounter);\n\n            _idToAsset[assetId] = AssetIdKey(asset, tokenId);\n            _assetToId[asset][tokenId] = assetId;\n\n            emit RegisterAsset(assetId, asset, tokenId, name, symbol, decimals);\n        }\n\n        sender.sendRegisterAsset(centrifugeId, assetId, decimals);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Incoming\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function addPool(PoolId poolId) public auth {\n        Pool storage pool = pools[poolId];\n        require(pool.createdAt == 0, PoolAlreadyAdded());\n        pool.createdAt = block.timestamp;\n\n        IPoolEscrow escrow = poolEscrowFactory.newEscrow(poolId);\n        gateway.setRefundAddress(PoolId.wrap(poolId.raw()), escrow);\n\n        emit AddPool(poolId);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function addShareClass(\n        PoolId poolId,\n        ShareClassId scId,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 salt,\n        address hook\n    ) public auth {\n        require(decimals >= MIN_DECIMALS, TooFewDecimals());\n        require(decimals <= MAX_DECIMALS, TooManyDecimals());\n        require(isPoolActive(poolId), InvalidPool());\n\n        Pool storage pool = pools[poolId];\n        require(address(pool.shareClasses[scId].shareToken) == address(0), ShareClassAlreadyRegistered());\n\n        // Hook can be address zero if the share token is fully permissionless and has no custom logic\n        require(hook == address(0) || _isValidHook(hook), InvalidHook());\n\n        address[] memory tokenWards = new address[](2);\n        tokenWards[0] = address(this);\n        // BalanceSheet needs this in order to mint shares\n        tokenWards[1] = balanceSheet;\n\n        IShareToken shareToken_ = tokenFactory.newToken(name, symbol, decimals, salt, tokenWards);\n\n        if (hook != address(0)) {\n            shareToken_.file(\"hook\", hook);\n        }\n\n        pool.shareClasses[scId].shareToken = shareToken_;\n\n        emit AddShareClass(poolId, scId, shareToken_);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function updateShareMetadata(PoolId poolId, ShareClassId scId, string memory name, string memory symbol)\n        public\n        auth\n    {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n\n        require(\n            keccak256(bytes(shareToken_.name())) != keccak256(bytes(name))\n                || keccak256(bytes(shareToken_.symbol())) != keccak256(bytes(symbol)),\n            OldMetadata()\n        );\n\n        shareToken_.file(\"name\", name);\n        shareToken_.file(\"symbol\", symbol);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function updatePricePoolPerShare(PoolId poolId, ShareClassId scId, uint128 price, uint64 computedAt) public auth {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n        require(computedAt >= shareClass.pricePoolPerShare.computedAt, CannotSetOlderPrice());\n\n        shareClass.pricePoolPerShare = Price(price, computedAt, shareClass.pricePoolPerShare.maxAge);\n        emit PriceUpdate(poolId, scId, price, computedAt);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function updatePricePoolPerAsset(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 poolPerAsset_,\n        uint64 computedAt\n    ) public auth {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        Price storage poolPerAsset = shareClass.pricePoolPerAsset[asset][tokenId];\n        require(computedAt >= poolPerAsset.computedAt, CannotSetOlderPrice());\n\n        // Disable expiration of the price\n        if (poolPerAsset.computedAt == 0) {\n            poolPerAsset.maxAge = type(uint64).max;\n        }\n        poolPerAsset.price = poolPerAsset_;\n        poolPerAsset.computedAt = computedAt;\n\n        emit PriceUpdate(poolId, scId, asset, tokenId, poolPerAsset_, computedAt);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function updateRestriction(PoolId poolId, ShareClassId scId, bytes memory update_) public auth {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n        address hook = shareToken_.hook();\n        require(hook != address(0), InvalidHook());\n        IHook(hook).updateRestriction(address(shareToken_), update_);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function updateContract(PoolId poolId, ShareClassId scId, address target, bytes memory update_) public auth {\n        if (target == address(this)) {\n            update(poolId, scId, update_);\n        } else {\n            IUpdateContract(target).update(poolId, scId, update_);\n        }\n\n        emit UpdateContract(poolId, scId, target, update_);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function updateShareHook(PoolId poolId, ShareClassId scId, address hook) public auth {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n        require(hook != shareToken_.hook(), OldHook());\n        shareToken_.file(\"hook\", hook);\n    }\n\n    /// @inheritdoc IPoolManagerGatewayHandler\n    function handleTransferShares(PoolId poolId, ShareClassId scId, address destinationAddress, uint128 amount)\n        public\n        auth\n    {\n        IShareToken shareToken_ = shareToken(poolId, scId);\n\n        shareToken_.mint(destinationAddress, amount);\n    }\n\n    /// @inheritdoc IUpdateContract\n    /// @notice The pool manager either deploys the vault if a factory address is provided\n    ///         or it simply links/unlinks the vault.\n    function update(PoolId poolId, ShareClassId scId, bytes memory payload) public auth {\n        uint8 kind = uint8(MessageLib.updateContractType(payload));\n\n        if (kind == uint8(UpdateContractType.VaultUpdate)) {\n            MessageLib.UpdateContractVaultUpdate memory m = MessageLib.deserializeUpdateContractVaultUpdate(payload);\n\n            if (m.kind == uint8(VaultUpdateKind.DeployAndLink)) {\n                IVaultFactory factory = IVaultFactory(m.vaultOrFactory.toAddress());\n\n                IBaseVault vault = deployVault(poolId, scId, AssetId.wrap(m.assetId), factory);\n                linkVault(poolId, scId, AssetId.wrap(m.assetId), vault);\n            } else {\n                IBaseVault vault = IBaseVault(m.vaultOrFactory.toAddress());\n\n                // Needed as safeguard against non-validated vaults\n                // I.e. we only accept vaults that have been deployed by the pool manager\n                require(_vaultDetails[vault].asset != address(0), UnknownVault());\n\n                if (m.kind == uint8(VaultUpdateKind.Link)) {\n                    linkVault(poolId, scId, AssetId.wrap(m.assetId), vault);\n                } else if (m.kind == uint8(VaultUpdateKind.Unlink)) {\n                    unlinkVault(poolId, scId, AssetId.wrap(m.assetId), vault);\n                } else {\n                    revert MalformedVaultUpdateMessage();\n                }\n            }\n        } else if (kind == uint8(UpdateContractType.MaxAssetPriceAge)) {\n            MessageLib.UpdateContractMaxAssetPriceAge memory m =\n                MessageLib.deserializeUpdateContractMaxAssetPriceAge(payload);\n\n            ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n            require(m.assetId != 0, UnknownAsset());\n\n            (address asset, uint256 tokenId) = idToAsset(AssetId.wrap(m.assetId));\n            shareClass.pricePoolPerAsset[asset][tokenId].maxAge = m.maxPriceAge;\n            emit UpdateMaxAssetPriceAge(poolId, scId, asset, tokenId, m.maxPriceAge);\n        } else if (kind == uint8(UpdateContractType.MaxSharePriceAge)) {\n            MessageLib.UpdateContractMaxSharePriceAge memory m =\n                MessageLib.deserializeUpdateContractMaxSharePriceAge(payload);\n\n            ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n            shareClass.pricePoolPerShare.maxAge = m.maxPriceAge;\n            emit UpdateMaxSharePriceAge(poolId, scId, m.maxPriceAge);\n        } else {\n            revert UnknownUpdateContractType();\n        }\n    }\n\n    /// @inheritdoc IPoolManager\n    function linkVault(PoolId poolId, ShareClassId scId, AssetId assetId, IBaseVault vault) public auth {\n        _shareClass(poolId, scId);\n\n        AssetIdKey memory assetIdKey = _idToAsset[assetId];\n\n        IBaseRequestManager manager = vault.manager();\n        manager.addVault(poolId, scId, vault, assetIdKey.asset, assetId);\n\n        _vaultDetails[vault].isLinked = true;\n\n        emit LinkVault(poolId, scId, assetIdKey.asset, assetIdKey.tokenId, vault);\n    }\n\n    /// @inheritdoc IPoolManager\n    function unlinkVault(PoolId poolId, ShareClassId scId, AssetId assetId, IBaseVault vault) public auth {\n        _shareClass(poolId, scId);\n\n        AssetIdKey memory assetIdKey = _idToAsset[assetId];\n\n        IBaseRequestManager manager = vault.manager();\n        manager.removeVault(poolId, scId, vault, assetIdKey.asset, assetId);\n\n        _vaultDetails[vault].isLinked = false;\n\n        emit UnlinkVault(poolId, scId, assetIdKey.asset, assetIdKey.tokenId, vault);\n    }\n\n    /// @inheritdoc IPoolManager\n    function deployVault(PoolId poolId, ShareClassId scId, AssetId assetId, IVaultFactory factory)\n        public\n        auth\n        returns (IBaseVault)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        require(vaultFactory[factory], InvalidFactory());\n\n        // Rely investment manager on vault so it can mint tokens\n        address[] memory vaultWards = new address[](0);\n\n        // Deploy vault\n        AssetIdKey memory assetIdKey = _idToAsset[assetId];\n        IBaseVault vault = IVaultFactory(factory).newVault(\n            poolId, scId, assetIdKey.asset, assetIdKey.tokenId, shareClass.shareToken, vaultWards\n        );\n\n        // Check whether asset is an ERC20 token wrapper\n        (bool success, bytes memory data) =\n            assetIdKey.asset.staticcall(abi.encodeWithSelector(IERC20Wrapper.underlying.selector));\n        // On success, the returned 20 byte address is padded to 32 bytes\n        bool isWrappedERC20 = success && data.length == 32;\n        _vaultDetails[vault] = VaultDetails(assetId, assetIdKey.asset, assetIdKey.tokenId, isWrappedERC20, false);\n\n        // NOTE - Reverting the manager approvals is not easy. We SHOULD do that if we phase-out a manager\n        VaultKind vaultKind = _relyShareToken(vault, shareClass.shareToken);\n\n        emit DeployVault(poolId, scId, assetIdKey.asset, assetIdKey.tokenId, factory, vault, vaultKind);\n        return vault;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IPoolManager\n    function isPoolActive(PoolId poolId) public view returns (bool) {\n        return pools[poolId].createdAt > 0;\n    }\n\n    /// @inheritdoc IPoolManager\n    function shareToken(PoolId poolId, ShareClassId scId) public view returns (IShareToken) {\n        ShareClassDetails storage shareClass = pools[poolId].shareClasses[scId];\n        require(address(shareClass.shareToken) != address(0), UnknownToken());\n        return shareClass.shareToken;\n    }\n\n    /// @inheritdoc IPoolManager\n    function vaultDetails(IBaseVault vault) public view returns (VaultDetails memory details) {\n        details = _vaultDetails[vault];\n        require(details.asset != address(0), UnknownVault());\n    }\n\n    /// @inheritdoc IPoolManager\n    function isLinked(PoolId, /* poolId */ ShareClassId, /* scId */ address, /* asset */ IBaseVault vault)\n        public\n        view\n        returns (bool)\n    {\n        return _vaultDetails[vault].isLinked;\n    }\n\n    /// @inheritdoc IPoolManager\n    function idToAsset(AssetId assetId) public view returns (address asset, uint256 tokenId) {\n        AssetIdKey memory assetIdKey = _idToAsset[assetId];\n        require(assetIdKey.asset != address(0), UnknownAsset());\n        return (assetIdKey.asset, assetIdKey.tokenId);\n    }\n\n    /// @inheritdoc IPoolManager\n    function assetToId(address asset, uint256 tokenId) public view returns (AssetId assetId) {\n        assetId = _assetToId[asset][tokenId];\n        require(assetId.raw() != 0, UnknownAsset());\n    }\n\n    /// @inheritdoc IPoolManager\n    function priceAssetPerShare(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        public\n        view\n        returns (D18 price)\n    {\n        (Price memory poolPerAsset, Price memory poolPerShare) = _pricesPoolPer(poolId, scId, assetId, checkValidity);\n\n        price = PricingLib.priceAssetPerShare(poolPerShare.asPrice(), poolPerAsset.asPrice());\n    }\n\n    /// @inheritdoc IPoolManager\n    function pricePoolPerShare(PoolId poolId, ShareClassId scId, bool checkValidity) public view returns (D18 price) {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n        if (checkValidity) {\n            require(shareClass.pricePoolPerShare.isValid(), InvalidPrice());\n        }\n\n        price = shareClass.pricePoolPerShare.asPrice();\n    }\n\n    /// @inheritdoc IPoolManager\n    function pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        public\n        view\n        returns (D18 price)\n    {\n        (Price memory poolPerAsset,) = _pricesPoolPer(poolId, scId, assetId, false);\n\n        if (checkValidity) {\n            require(poolPerAsset.isValid(), InvalidPrice());\n        }\n\n        price = poolPerAsset.asPrice();\n    }\n\n    /// @inheritdoc IPoolManager\n    function pricesPoolPer(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        public\n        view\n        returns (D18 pricePoolPerAsset_, D18 pricePoolPerShare_)\n    {\n        (Price memory poolPerAsset, Price memory poolPerShare) = _pricesPoolPer(poolId, scId, assetId, checkValidity);\n        return (poolPerAsset.asPrice(), poolPerShare.asPrice());\n    }\n\n    /// @inheritdoc IPoolManager\n    function markersPricePoolPerShare(PoolId poolId, ShareClassId scId)\n        external\n        view\n        returns (uint64 computedAt, uint64 maxAge, uint64 validUntil)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n        computedAt = shareClass.pricePoolPerShare.computedAt;\n        maxAge = shareClass.pricePoolPerShare.maxAge;\n        validUntil = shareClass.pricePoolPerShare.validUntil();\n    }\n\n    /// @inheritdoc IPoolManager\n    function markersPricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        view\n        returns (uint64 computedAt, uint64 maxAge, uint64 validUntil)\n    {\n        (Price memory poolPerAsset,) = _pricesPoolPer(poolId, scId, assetId, false);\n        computedAt = poolPerAsset.computedAt;\n        maxAge = poolPerAsset.maxAge;\n        validUntil = poolPerAsset.validUntil();\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal methods\n    //----------------------------------------------------------------------------------------------\n\n    function _pricesPoolPer(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        internal\n        view\n        returns (Price memory poolPerAsset, Price memory poolPerShare)\n    {\n        ShareClassDetails storage shareClass = _shareClass(poolId, scId);\n\n        (address asset, uint256 tokenId) = idToAsset(assetId);\n        poolPerAsset = shareClass.pricePoolPerAsset[asset][tokenId];\n        poolPerShare = shareClass.pricePoolPerShare;\n\n        if (checkValidity) {\n            require(poolPerAsset.isValid(), InvalidPrice());\n            require(poolPerShare.isValid(), InvalidPrice());\n        }\n    }\n\n    /// @dev Sets up approval permissions for pool, i.e. the pool escrow, the base vault manager and potentially a\n    ///      secondary manager (in case of partially sync vault)\n    function _relyShareToken(IBaseVault vault, IShareToken shareToken_) internal returns (VaultKind) {\n        IBaseRequestManager manager = vault.manager();\n        IAuth(address(shareToken_)).rely(address(manager));\n\n        // For sync deposit & async redeem vault, also repeat above for async manager\n        VaultKind vaultKind = vault.vaultKind();\n        if (vaultKind == VaultKind.SyncDepositAsyncRedeem) {\n            IAuth(address(shareToken_)).rely(address(asyncRequestManager));\n        }\n\n        return vaultKind;\n    }\n\n    function _safeGetAssetDecimals(address asset, uint256 tokenId) private view returns (uint8) {\n        bytes memory callData;\n\n        if (tokenId == 0) {\n            callData = abi.encodeWithSignature(\"decimals()\");\n        } else {\n            callData = abi.encodeWithSignature(\"decimals(uint256)\", tokenId);\n        }\n\n        (bool success, bytes memory data) = asset.staticcall(callData);\n        require(success && data.length >= 32, AssetMissingDecimals());\n\n        return abi.decode(data, (uint8));\n    }\n\n    function _isValidHook(address hook) internal view returns (bool) {\n        (bool success, bytes memory data) =\n            hook.staticcall(abi.encodeWithSelector(IERC165.supportsInterface.selector, type(IHook).interfaceId));\n\n        return success && data.length == 32 && abi.decode(data, (bool));\n    }\n\n    function _shareClass(PoolId poolId, ShareClassId scId)\n        internal\n        view\n        returns (ShareClassDetails storage shareClass)\n    {\n        shareClass = pools[poolId].shareClasses[scId];\n        require(address(shareClass.shareToken) != address(0), ShareTokenDoesNotExist());\n    }\n}\n"
    },
    "src/vaults/SyncDepositVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {BaseVault, BaseAsyncRedeemVault, BaseSyncDepositVault} from \"src/vaults/BaseVaults.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\nimport {ISyncDepositManager} from \"src/vaults/interfaces/investments/ISyncDepositManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\n/// @title  SyncDepositVault\n/// @notice Partially (a)synchronous Tokenized Vault implementation with synchronous deposits\n///         and asynchronous redemptions following ERC-7540.\n///\n/// @dev    Each vault issues shares of Centrifuge share class tokens as restricted ERC-20 tokens\n///         against asset deposits based on the current share price.\ncontract SyncDepositVault is BaseSyncDepositVault, BaseAsyncRedeemVault {\n    constructor(\n        PoolId poolId_,\n        ShareClassId scId_,\n        address asset_,\n        IShareToken token_,\n        address root_,\n        ISyncDepositManager syncDepositManager_,\n        IAsyncRedeemManager asyncRedeemManager_\n    )\n        BaseVault(poolId_, scId_, asset_, token_, root_, syncDepositManager_)\n        BaseSyncDepositVault(syncDepositManager_)\n        BaseAsyncRedeemVault(asyncRedeemManager_)\n    {}\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    function file(bytes32 what, address data) external override(BaseAsyncRedeemVault, BaseVault) auth {\n        if (what == \"manager\") manager = IBaseRequestManager(data);\n        else if (what == \"asyncRedeemManager\") asyncRedeemManager = IAsyncRedeemManager(data);\n        else if (what == \"syncDepositManager\") syncDepositManager = ISyncDepositManager(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        override(BaseAsyncRedeemVault, BaseSyncDepositVault)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // IBaseVault view\n    //----------------------------------------------------------------------------------------------\n\n    function vaultKind() public pure returns (VaultKind vaultKind_) {\n        return VaultKind.SyncDepositAsyncRedeem;\n    }\n}\n"
    },
    "src/vaults/SyncRequestManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC165} from \"forge-std/interfaces/IERC165.sol\";\nimport {IERC7540Redeem} from \"src/misc/interfaces/IERC7540.sol\";\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {d18, D18} from \"src/misc/types/D18.sol\";\n\nimport {MessageLib, UpdateContractType} from \"src/common/libraries/MessageLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nimport {BaseRequestManager} from \"src/vaults/BaseRequestManager.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IAsyncRedeemVault, IBaseVault, VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IPoolManager, VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBalanceSheet} from \"src/vaults/interfaces/IBalanceSheet.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {\n    ISyncRequestManager,\n    Prices,\n    ISyncDepositValuation\n} from \"src/vaults/interfaces/investments/ISyncRequestManager.sol\";\nimport {IDepositManager} from \"src/vaults/interfaces/investments/IDepositManager.sol\";\nimport {ISyncDepositManager} from \"src/vaults/interfaces/investments/ISyncDepositManager.sol\";\nimport {IUpdateContract} from \"src/vaults/interfaces/IUpdateContract.sol\";\nimport {IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\n\n/// @title  Sync Investment Manager\n/// @notice This is the main contract vaults interact with for\n///         both incoming and outgoing investment transactions.\ncontract SyncRequestManager is BaseRequestManager, ISyncRequestManager {\n    using BytesLib for bytes;\n    using MathLib for *;\n    using CastLib for *;\n    using MessageLib for *;\n\n    IBalanceSheet public balanceSheet;\n\n    mapping(PoolId => mapping(ShareClassId scId => ISyncDepositValuation)) public valuation;\n    mapping(PoolId => mapping(ShareClassId scId => mapping(address asset => mapping(uint256 tokenId => uint128))))\n        public maxReserve;\n\n    constructor(IEscrow globalEscrow_, address root_, address deployer)\n        BaseRequestManager(globalEscrow_, root_, deployer)\n    {}\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IBaseRequestManager\n    function file(bytes32 what, address data) external override(IBaseRequestManager, BaseRequestManager) auth {\n        if (what == \"poolManager\") poolManager = IPoolManager(data);\n        else if (what == \"balanceSheet\") balanceSheet = IBalanceSheet(data);\n        else if (what == \"poolEscrowProvider\") poolEscrowProvider = IPoolEscrowProvider(data);\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IUpdateContract\n    function update(PoolId poolId, ShareClassId scId, bytes memory payload) external auth {\n        uint8 kind = uint8(MessageLib.updateContractType(payload));\n\n        if (kind == uint8(UpdateContractType.Valuation)) {\n            MessageLib.UpdateContractValuation memory m = MessageLib.deserializeUpdateContractValuation(payload);\n\n            require(address(poolManager.shareToken(poolId, scId)) != address(0), ShareTokenDoesNotExist());\n\n            setValuation(poolId, scId, m.valuation.toAddress());\n        } else if (kind == uint8(UpdateContractType.SyncDepositMaxReserve)) {\n            MessageLib.UpdateContractSyncDepositMaxReserve memory m =\n                MessageLib.deserializeUpdateContractSyncDepositMaxReserve(payload);\n\n            require(address(poolManager.shareToken(poolId, scId)) != address(0), ShareTokenDoesNotExist());\n            (address asset, uint256 tokenId) = poolManager.idToAsset(AssetId.wrap(m.assetId));\n\n            setMaxReserve(poolId, scId, asset, tokenId, m.maxReserve);\n        } else {\n            revert UnknownUpdateContractType();\n        }\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function addVault(PoolId poolId, ShareClassId scId, IBaseVault vault_, address asset_, AssetId assetId)\n        public\n        override(BaseRequestManager, IBaseRequestManager)\n        auth\n    {\n        super.addVault(poolId, scId, vault_, asset_, assetId);\n\n        (, uint256 tokenId) = poolManager.idToAsset(assetId);\n        setMaxReserve(poolId, scId, asset_, tokenId, type(uint128).max);\n\n        VaultKind vaultKind_ = vault_.vaultKind();\n        if (vaultKind_ == VaultKind.SyncDepositAsyncRedeem) {\n            IAsyncRedeemManager asyncRequestManager = IAsyncRedeemVault(address(vault_)).asyncRedeemManager();\n            require(address(asyncRequestManager) != address(0), SecondaryManagerDoesNotExist());\n            asyncRequestManager.addVault(poolId, scId, vault_, asset_, assetId);\n        }\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function removeVault(PoolId poolId, ShareClassId scId, IBaseVault vault_, address asset_, AssetId assetId)\n        public\n        override(BaseRequestManager, IBaseRequestManager)\n        auth\n    {\n        super.removeVault(poolId, scId, vault_, asset_, assetId);\n\n        (, uint256 tokenId) = poolManager.idToAsset(assetId);\n        delete maxReserve[poolId][scId][asset_][tokenId];\n\n        VaultKind vaultKind_ = vault_.vaultKind();\n        if (vaultKind_ == VaultKind.SyncDepositAsyncRedeem) {\n            IAsyncRedeemManager asyncRequestManager = IAsyncRedeemVault(address(vault_)).asyncRedeemManager();\n            require(address(asyncRequestManager) != address(0), SecondaryManagerDoesNotExist());\n            asyncRequestManager.removeVault(poolId, scId, vault_, asset_, assetId);\n        }\n    }\n\n    /// @inheritdoc ISyncRequestManager\n    function setValuation(PoolId poolId, ShareClassId scId, address valuation_) public auth {\n        valuation[poolId][scId] = ISyncDepositValuation(valuation_);\n\n        emit SetValuation(poolId, scId, address(valuation_));\n    }\n\n    /// @inheritdoc ISyncRequestManager\n    function setMaxReserve(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, uint128 maxReserve_)\n        public\n        auth\n    {\n        maxReserve[poolId][scId][asset][tokenId] = maxReserve_;\n\n        emit SetMaxReserve(poolId, scId, asset, tokenId, maxReserve_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Deposit handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IDepositManager\n    function mint(IBaseVault vault_, uint256 shares, address receiver, address owner)\n        external\n        auth\n        returns (uint256 assets)\n    {\n        require(maxMint(vault_, owner) >= shares, ExceedsMaxMint());\n        assets = previewMint(vault_, owner, shares);\n\n        _issueShares(vault_, shares.toUint128(), receiver, owner, assets.toUint128());\n    }\n\n    /// @inheritdoc IDepositManager\n    function deposit(IBaseVault vault_, uint256 assets, address receiver, address owner)\n        external\n        auth\n        returns (uint256 shares)\n    {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        require(poolManager.isLinked(vault_.poolId(), vault_.scId(), vaultDetails.asset, vault_), AssetNotAllowed());\n\n        require(maxDeposit(vault_, owner) >= assets, ExceedsMaxDeposit());\n        shares = previewDeposit(vault_, owner, assets);\n\n        _issueShares(vault_, shares.toUint128(), receiver, owner, assets.toUint128());\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc ISyncDepositManager\n    function previewMint(IBaseVault vault_, address, /* sender */ uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        return _shareToAssetAmount(vault_, shares, MathLib.Rounding.Up);\n    }\n\n    /// @inheritdoc ISyncDepositManager\n    function previewDeposit(IBaseVault vault_, address, /* sender */ uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        return convertToShares(vault_, assets);\n    }\n\n    /// @inheritdoc IDepositManager\n    function maxMint(IBaseVault vault_, address /* owner */ ) public view returns (uint256) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        uint128 maxAssets = _maxDeposit(vault_.poolId(), vault_.scId(), vaultDetails.asset, vaultDetails.tokenId);\n        return convertToShares(vault_, maxAssets);\n    }\n\n    /// @inheritdoc IDepositManager\n    function maxDeposit(IBaseVault vault_, address /* owner */ ) public view returns (uint256) {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        return _maxDeposit(vault_.poolId(), vault_.scId(), vaultDetails.asset, vaultDetails.tokenId);\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function convertToShares(IBaseVault vault_, uint256 assets)\n        public\n        view\n        override(IBaseRequestManager, BaseRequestManager)\n        returns (uint256 shares)\n    {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        Prices memory prices_ = prices(vault_.poolId(), vault_.scId(), vaultDetails.assetId);\n\n        return super._assetToShareAmount(\n            vault_, vaultDetails, assets, prices_.poolPerAsset, prices_.poolPerShare, MathLib.Rounding.Down\n        );\n    }\n\n    /// @inheritdoc IBaseRequestManager\n    function convertToAssets(IBaseVault vault_, uint256 shares)\n        public\n        view\n        override(IBaseRequestManager, BaseRequestManager)\n        returns (uint256 assets)\n    {\n        return _shareToAssetAmount(vault_, shares, MathLib.Rounding.Down);\n    }\n\n    /// @inheritdoc ISyncDepositValuation\n    function pricePoolPerShare(PoolId poolId, ShareClassId scId) public view returns (D18 price) {\n        ISyncDepositValuation valuation_ = valuation[poolId][scId];\n\n        if (address(valuation_) == address(0)) {\n            price = poolManager.pricePoolPerShare(poolId, scId, true);\n        } else {\n            price = valuation_.pricePoolPerShare(poolId, scId);\n        }\n    }\n\n    /// @inheritdoc ISyncRequestManager\n    function prices(PoolId poolId, ShareClassId scId, AssetId assetId) public view returns (Prices memory priceData) {\n        priceData.poolPerShare = pricePoolPerShare(poolId, scId);\n        priceData.poolPerAsset = poolManager.pricePoolPerAsset(poolId, scId, assetId, true);\n        priceData.assetPerShare = PricingLib.priceAssetPerShare(priceData.poolPerShare, priceData.poolPerAsset);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Internal\n    //----------------------------------------------------------------------------------------------\n\n    /// @dev Issues shares to the receiver and instruct the balance sheet\n    //       to react on the issuance and the updated holding.\n    function _issueShares(IBaseVault vault_, uint128 shares, address receiver, address, /* owner */ uint128 assets)\n        internal\n    {\n        PoolId poolId = vault_.poolId();\n        ShareClassId scId = vault_.scId();\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n\n        balanceSheet.overridePricePoolPerShare(poolId, scId, prices(poolId, scId, vaultDetails.assetId).poolPerShare);\n        balanceSheet.issue(poolId, scId, receiver, shares);\n\n        // Note deposit into the pool escrow, to make assets available for managers of the balance sheet\n        // ERC-20 transfer is handled by the vault to the pool escrow afterwards\n        balanceSheet.noteDeposit(poolId, scId, vaultDetails.asset, vaultDetails.tokenId, receiver, assets);\n    }\n\n    function _maxDeposit(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId)\n        internal\n        view\n        returns (uint128 maxDeposit_)\n    {\n        uint128 availableBalance = poolEscrowProvider.escrow(poolId).availableBalanceOf(scId, asset, tokenId);\n        uint128 maxReserve_ = maxReserve[poolId][scId][asset][tokenId];\n\n        if (maxReserve_ < availableBalance) {\n            maxDeposit_ = 0;\n        } else {\n            maxDeposit_ = maxReserve_ - availableBalance;\n        }\n    }\n\n    function _shareToAssetAmount(IBaseVault vault_, uint256 assets, MathLib.Rounding rounding)\n        internal\n        view\n        returns (uint256 shares)\n    {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault_);\n        Prices memory prices_ = prices(vault_.poolId(), vault_.scId(), vaultDetails.assetId);\n        return super._shareToAssetAmount(\n            vault_, vaultDetails, assets, prices_.poolPerAsset, prices_.poolPerShare, rounding\n        );\n    }\n}\n"
    },
    "src/vaults/VaultRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {Multicall, IMulticall} from \"src/misc/Multicall.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IERC20, IERC20Permit, IERC20Wrapper} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC7540Deposit} from \"src/misc/interfaces/IERC7540.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\n\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IMessageDispatcher} from \"src/common/interfaces/IMessageDispatcher.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IAsyncVault, IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IVaultRouter} from \"src/vaults/interfaces/IVaultRouter.sol\";\nimport {IPoolManager, VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {BaseSyncDepositVault} from \"src/vaults/BaseVaults.sol\";\n\n/// @title  VaultRouter\n/// @notice This is a helper contract, designed to be the entrypoint for EOAs.\n///         It removes the need to know about all other contracts and simplifies the way to interact with the protocol.\n///         It also adds the need to fully pay for each step of the transaction execution. VaultRouter allows\n///         the caller to execute multiple function into a single transaction by taking advantage of\n///         the multicall functionality which batches message calls into a single one.\n/// @dev    It is critical to ensure that at the end of any transaction, no funds remain in the\n///         VaultRouter. Any funds that do remain are at risk of being taken by other users.\ncontract VaultRouter is Auth, Multicall, Recoverable, IVaultRouter {\n    using CastLib for address;\n\n    /// @dev Requests for Centrifuge pool are non-fungible and all have ID = 0\n    uint256 private constant REQUEST_ID = 0;\n\n    IEscrow public immutable escrow;\n    IGateway public immutable gateway;\n    IPoolManager public immutable poolManager;\n    IMessageDispatcher public immutable messageDispatcher;\n\n    /// @inheritdoc IVaultRouter\n    mapping(address controller => mapping(IBaseVault vault => uint256 amount)) public lockedRequests;\n\n    constructor(\n        address escrow_,\n        IGateway gateway_,\n        IPoolManager poolManager_,\n        IMessageDispatcher messageDispatcher_,\n        address deployer\n    ) Auth(deployer) {\n        escrow = IEscrow(escrow_);\n        gateway = gateway_;\n        poolManager = poolManager_;\n        messageDispatcher = messageDispatcher_;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IMulticall\n    /// @notice performs a multicall but all message sent in the process will be batched\n    function multicall(bytes[] calldata data) public payable override(Multicall, IMulticall) {\n        bool wasBatching = gateway.isBatching();\n        if (!wasBatching) {\n            gateway.startBatching();\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n\n        super.multicall(data);\n\n        if (!wasBatching) {\n            gateway.endBatching();\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Enable interactions\n    //----------------------------------------------------------------------------------------------\n\n    function enable(IBaseVault vault) public payable protected {\n        vault.setEndorsedOperator(msg.sender, true);\n    }\n\n    function disable(IBaseVault vault) external payable protected {\n        vault.setEndorsedOperator(msg.sender, false);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Deposit\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function requestDeposit(IAsyncVault vault, uint256 amount, address controller, address owner)\n        external\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        if (owner == address(this)) {\n            _approveMax(vaultDetails.asset, address(vault));\n        }\n\n        _pay();\n        vault.requestDeposit(amount, controller, owner);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function deposit(BaseSyncDepositVault vault, uint256 assets, address receiver, address owner)\n        external\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        require(!vault.supportsInterface(type(IERC7540Deposit).interfaceId), NonSyncDepositVault());\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        SafeTransferLib.safeTransferFrom(vaultDetails.asset, owner, address(this), assets);\n        _approveMax(vaultDetails.asset, address(vault));\n\n        _pay();\n        vault.deposit(assets, receiver);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function lockDepositRequest(IBaseVault vault, uint256 amount, address controller, address owner)\n        public\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        require(vault.supportsInterface(type(IERC7540Deposit).interfaceId), NonAsyncVault());\n\n        lockedRequests[controller][vault] += amount;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        SafeTransferLib.safeTransferFrom(vaultDetails.asset, owner, address(escrow), amount);\n\n        emit LockDepositRequest(vault, controller, owner, msg.sender, amount);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function enableLockDepositRequest(IBaseVault vault, uint256 amount) external payable protected {\n        enable(vault);\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n\n        uint256 assetBalance;\n        assetBalance = IERC20(vaultDetails.asset).balanceOf(msg.sender);\n\n        if (vaultDetails.isWrapper && assetBalance < amount) {\n            wrap(vaultDetails.asset, amount, address(this), msg.sender);\n            lockDepositRequest(vault, amount, msg.sender, address(this));\n        } else {\n            lockDepositRequest(vault, amount, msg.sender, msg.sender);\n        }\n    }\n\n    /// @inheritdoc IVaultRouter\n    function unlockDepositRequest(IBaseVault vault, address receiver) external payable protected {\n        uint256 lockedRequest = lockedRequests[msg.sender][vault];\n        require(lockedRequest != 0, NoLockedBalance());\n        lockedRequests[msg.sender][vault] = 0;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        escrow.authTransferTo(vaultDetails.asset, receiver, lockedRequest);\n\n        emit UnlockDepositRequest(vault, msg.sender, receiver);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function executeLockedDepositRequest(IAsyncVault vault, address controller) external payable protected {\n        uint256 lockedRequest = lockedRequests[controller][vault];\n        require(lockedRequest != 0, NoLockedRequest());\n        lockedRequests[controller][vault] = 0;\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        escrow.authTransferTo(vaultDetails.asset, address(this), lockedRequest);\n\n        _pay();\n        _approveMax(vaultDetails.asset, address(vault));\n        vault.requestDeposit(lockedRequest, controller, address(this));\n        emit ExecuteLockedDepositRequest(vault, controller, msg.sender);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimDeposit(IAsyncVault vault, address receiver, address controller) external payable protected {\n        _canClaim(vault, receiver, controller);\n        uint256 maxMint = vault.maxMint(controller);\n        vault.mint(maxMint, receiver, controller);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function cancelDepositRequest(IAsyncVault vault) external payable protected {\n        _pay();\n        vault.cancelDepositRequest(REQUEST_ID, msg.sender);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimCancelDepositRequest(IAsyncVault vault, address receiver, address controller)\n        external\n        payable\n        protected\n    {\n        _canClaim(vault, receiver, controller);\n        vault.claimCancelDepositRequest(REQUEST_ID, receiver, controller);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Redeem\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function requestRedeem(IAsyncVault vault, uint256 amount, address controller, address owner)\n        external\n        payable\n        protected\n    {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        _pay();\n        vault.requestRedeem(amount, controller, owner);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimRedeem(IBaseVault vault, address receiver, address controller) external payable protected {\n        _canClaim(vault, receiver, controller);\n        uint256 maxWithdraw = vault.maxWithdraw(controller);\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        if (vaultDetails.isWrapper && controller != msg.sender) {\n            // Auto-unwrap if permissionlessly claiming for another controller\n            vault.withdraw(maxWithdraw, address(this), controller);\n            unwrap(vaultDetails.asset, maxWithdraw, receiver);\n        } else {\n            vault.withdraw(maxWithdraw, receiver, controller);\n        }\n    }\n\n    /// @inheritdoc IVaultRouter\n    function cancelRedeemRequest(IAsyncVault vault) external payable protected {\n        _pay();\n        vault.cancelRedeemRequest(REQUEST_ID, msg.sender);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function claimCancelRedeemRequest(IAsyncVault vault, address receiver, address controller)\n        external\n        payable\n        protected\n    {\n        _canClaim(vault, receiver, controller);\n        vault.claimCancelRedeemRequest(REQUEST_ID, receiver, controller);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-20 permits & wrapping\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function permit(address asset, address spender, uint256 assets, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        payable\n        protected\n    {\n        try IERC20Permit(asset).permit(msg.sender, spender, assets, deadline, v, r, s) {} catch {}\n    }\n\n    function wrap(address wrapper, uint256 amount, address receiver, address owner) public payable protected {\n        require(owner == msg.sender || owner == address(this), InvalidOwner());\n        address underlying = IERC20Wrapper(wrapper).underlying();\n\n        amount = MathLib.min(amount, IERC20(underlying).balanceOf(owner));\n        require(amount != 0, ZeroBalance());\n        SafeTransferLib.safeTransferFrom(underlying, owner, address(this), amount);\n\n        _approveMax(underlying, wrapper);\n        require(IERC20Wrapper(wrapper).depositFor(receiver, amount), WrapFailed());\n    }\n\n    function unwrap(address wrapper, uint256 amount, address receiver) public payable protected {\n        amount = MathLib.min(amount, IERC20(wrapper).balanceOf(address(this)));\n        require(amount != 0, ZeroBalance());\n\n        require(IERC20Wrapper(wrapper).withdrawTo(receiver, amount), UnwrapFailed());\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // View methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IVaultRouter\n    function getVault(PoolId poolId, ShareClassId scId, address asset) external view returns (address) {\n        return IPoolManager(poolManager).shareToken(poolId, scId).vault(asset);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256) {\n        return messageDispatcher.estimate(centrifugeId, payload);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function hasPermissions(IBaseVault vault, address controller) external view returns (bool) {\n        return vault.isPermissioned(controller);\n    }\n\n    /// @inheritdoc IVaultRouter\n    function isEnabled(IBaseVault vault, address controller) public view returns (bool) {\n        return vault.isOperator(controller, address(this));\n    }\n\n    /// @notice Gives the max approval to `to` for spending the given `asset` if not already approved.\n    /// @dev    Assumes that `type(uint256).max` is large enough to never have to increase the allowance again.\n    function _approveMax(address asset, address spender) internal {\n        if (IERC20(asset).allowance(address(this), spender) == 0) {\n            SafeTransferLib.safeApprove(asset, spender, type(uint256).max);\n        }\n    }\n\n    /// @notice Send native tokens to the gateway for transaction payment if it's not in a multicall.\n    function _pay() internal {\n        if (!gateway.isBatching()) {\n            gateway.payTransaction{value: msg.value}(msg.sender);\n        }\n    }\n\n    /// @notice Ensures msg.sender is either the controller, or can permissionlessly claim\n    ///         on behalf of the controller.\n    function _canClaim(IBaseVault vault, address receiver, address controller) internal view {\n        require(controller == msg.sender || (controller == receiver && isEnabled(vault, controller)), InvalidSender());\n    }\n}\n"
    },
    "src/vaults/factories/AsyncVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {AsyncVault} from \"src/vaults/AsyncVault.sol\";\nimport {IVaultFactory} from \"src/vaults/interfaces/factories/IVaultFactory.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\n/// @title  ERC7540 Vault Factory\n/// @dev    Utility for deploying new vault contracts\ncontract AsyncVaultFactory is Auth, IVaultFactory {\n    address public immutable root;\n    IAsyncRequestManager public immutable asyncRequestManager;\n\n    constructor(address root_, IAsyncRequestManager asyncRequestManager_, address deployer) Auth(deployer) {\n        root = root_;\n        asyncRequestManager = asyncRequestManager_;\n    }\n\n    /// @inheritdoc IVaultFactory\n    function newVault(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        IShareToken token,\n        address[] calldata wards_\n    ) public auth returns (IBaseVault) {\n        require(tokenId == 0, UnsupportedTokenId());\n        AsyncVault vault = new AsyncVault(poolId, scId, asset, token, root, asyncRequestManager);\n\n        vault.rely(root);\n        vault.rely(address(asyncRequestManager));\n        uint256 wardsCount = wards_.length;\n        for (uint256 i; i < wardsCount; i++) {\n            vault.rely(wards_[i]);\n        }\n\n        vault.deny(address(this));\n        return vault;\n    }\n}\n"
    },
    "src/vaults/factories/PoolEscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {IPoolEscrowProvider, IPoolEscrowFactory} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {PoolEscrow} from \"src/vaults/Escrow.sol\";\n\ncontract PoolEscrowFactory is Auth, IPoolEscrowFactory {\n    address public immutable root;\n\n    address public gateway;\n    address public poolManager;\n    address public balanceSheet;\n    address public asyncRequestManager;\n\n    constructor(address root_, address deployer) Auth(deployer) {\n        root = root_;\n    }\n\n    /// @inheritdoc IPoolEscrowFactory\n    function file(bytes32 what, address data) external auth {\n        if (what == \"poolManager\") poolManager = data;\n        else if (what == \"gateway\") gateway = data;\n        else if (what == \"balanceSheet\") balanceSheet = data;\n        else if (what == \"asyncRequestManager\") asyncRequestManager = data;\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IPoolEscrowFactory\n    function newEscrow(PoolId poolId) public auth returns (IPoolEscrow) {\n        PoolEscrow escrow_ = new PoolEscrow{salt: bytes32(uint256(poolId.raw()))}(poolId, address(this));\n\n        escrow_.rely(root);\n        escrow_.rely(gateway);\n        escrow_.rely(poolManager);\n        escrow_.rely(balanceSheet);\n        escrow_.rely(asyncRequestManager);\n\n        escrow_.deny(address(this));\n\n        emit DeployPoolEscrow(poolId, address(escrow_));\n        return IPoolEscrow(escrow_);\n    }\n\n    /// @inheritdoc IPoolEscrowProvider\n    function escrow(PoolId poolId) external view returns (IPoolEscrow) {\n        bytes32 salt = bytes32(uint256(poolId.raw()));\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(abi.encodePacked(type(PoolEscrow).creationCode, abi.encode(poolId, address(this))))\n            )\n        );\n\n        return IPoolEscrow(address(uint160(uint256(hash))));\n    }\n}\n"
    },
    "src/vaults/factories/SyncDepositVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {SyncDepositVault} from \"src/vaults/SyncDepositVault.sol\";\nimport {IVaultFactory} from \"src/vaults/interfaces/factories/IVaultFactory.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\nimport {ISyncDepositManager} from \"src/vaults/interfaces/investments/ISyncDepositManager.sol\";\nimport {IPoolEscrowProvider} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\n/// @title  Sync Vault Factory\n/// @dev    Utility for deploying new vault contracts\ncontract SyncDepositVaultFactory is Auth, IVaultFactory {\n    address public immutable root;\n    ISyncDepositManager public immutable syncDepositManager;\n    IAsyncRedeemManager public immutable asyncRedeemManager;\n\n    constructor(\n        address root_,\n        ISyncDepositManager syncDepositManager_,\n        IAsyncRedeemManager asyncRedeemManager_,\n        address deployer\n    ) Auth(deployer) {\n        root = root_;\n        syncDepositManager = syncDepositManager_;\n        asyncRedeemManager = asyncRedeemManager_;\n    }\n\n    /// @inheritdoc IVaultFactory\n    function newVault(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        IShareToken token,\n        address[] calldata wards_\n    ) public auth returns (IBaseVault) {\n        require(tokenId == 0, UnsupportedTokenId());\n        SyncDepositVault vault =\n            new SyncDepositVault(poolId, scId, asset, token, root, syncDepositManager, asyncRedeemManager);\n\n        vault.rely(root);\n        vault.rely(address(syncDepositManager));\n        vault.rely(address(asyncRedeemManager));\n\n        uint256 wardsCount = wards_.length;\n        for (uint256 i; i < wardsCount; i++) {\n            vault.rely(wards_[i]);\n        }\n\n        vault.deny(address(this));\n        return vault;\n    }\n}\n"
    },
    "src/vaults/factories/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {ShareToken} from \"src/vaults/token/ShareToken.sol\";\nimport {ITokenFactory} from \"src/vaults/interfaces/factories/ITokenFactory.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\n/// @title  Share Token Factory\n/// @dev    Utility for deploying new share class token contracts\n///         Ensures the addresses are deployed at a deterministic address\n///         based on the pool id and share class id.\ncontract TokenFactory is Auth, ITokenFactory {\n    address public immutable root;\n\n    constructor(address _root, address deployer) Auth(deployer) {\n        root = _root;\n    }\n\n    /// @inheritdoc ITokenFactory\n    function newToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 salt,\n        address[] calldata tokenWards\n    ) public auth returns (IShareToken) {\n        ShareToken token = new ShareToken{salt: salt}(decimals);\n\n        token.file(\"name\", name);\n        token.file(\"symbol\", symbol);\n\n        token.rely(root);\n        uint256 wardsCount = tokenWards.length;\n        for (uint256 i; i < wardsCount; i++) {\n            token.rely(tokenWards[i]);\n        }\n        token.deny(address(this));\n\n        return token;\n    }\n\n    /// @inheritdoc ITokenFactory\n    function getAddress(uint8 decimals, bytes32 salt) external view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(abi.encodePacked(type(ShareToken).creationCode, abi.encode(decimals)))\n            )\n        );\n\n        return address(uint160(uint256(hash)));\n    }\n}\n"
    },
    "src/vaults/interfaces/IBalanceSheet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nstruct QueueAmount {\n    // Issuances of shares / deposits of assets\n    uint128 increase;\n    // Revocations of shares / withdraws of assets\n    uint128 decrease;\n}\n\ninterface IBalanceSheet {\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event UpdateManager(PoolId indexed poolId, address who, bool canManage);\n    event Withdraw(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount,\n        D18 pricePoolPerAsset\n    );\n    event Deposit(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        address asset,\n        uint256 tokenId,\n        address provider,\n        uint128 amount,\n        D18 pricePoolPerAsset\n    );\n    event Issue(PoolId indexed poolId, ShareClassId indexed scId, address to, D18 pricePoolPerShare, uint128 shares);\n    event Revoke(PoolId indexed poolId, ShareClassId indexed scId, address from, D18 pricePoolPerShare, uint128 shares);\n\n    // --- Errors ---\n    error FileUnrecognizedParam();\n    error CannotTransferFromEndorsedContract();\n\n    /// @notice Overloaded increase with asset transfer\n    function deposit(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, address provider, uint128 amount)\n        external;\n\n    function noteDeposit(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address provider,\n        uint128 amount\n    ) external;\n\n    function withdraw(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        address receiver,\n        uint128 amount\n    ) external;\n\n    function issue(PoolId poolId, ShareClassId scId, address to, uint128 shares) external;\n\n    function revoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) external;\n\n    function noteRevoke(PoolId poolId, ShareClassId scId, address from, uint128 shares) external;\n\n    function transferSharesFrom(PoolId poolId, ShareClassId scId, address from, address to, uint256 amount) external;\n\n    function overridePricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, D18 value) external;\n\n    function overridePricePoolPerShare(PoolId poolId, ShareClassId scId, D18 value) external;\n}\n"
    },
    "src/vaults/interfaces/IBaseVaults.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.5.0;\n\nenum VaultKind {\n    /// @dev Refers to AsyncVault\n    Async,\n    /// @dev not yet supported\n    Sync,\n    /// @dev Refers to SyncDepositVault\n    SyncDepositAsyncRedeem\n}\n\nimport {IERC7575, IERC165} from \"src/misc/interfaces/IERC7575.sol\";\nimport {\n    IERC7540Operator,\n    IERC7714,\n    IERC7741,\n    IERC7540Redeem,\n    IERC7887Redeem,\n    IERC7887Deposit,\n    IERC7540Deposit\n} from \"src/misc/interfaces/IERC7540.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\n\n/// @notice Interface for the all vault contracts\n/// @dev Must be implemented by all vaults\ninterface IBaseVault is IERC7540Operator, IERC7741, IERC7714, IERC7575, IRecoverable {\n    error FileUnrecognizedParam();\n    error NotEndorsed();\n    error CannotSetSelfAsOperator();\n    error ExpiredAuthorization();\n    error AlreadyUsedAuthorization();\n    error InvalidAuthorization();\n    error InvalidController();\n    error InsufficientBalance();\n    error RequestRedeemFailed();\n    error TransferFromFailed();\n\n    event File(bytes32 indexed what, address data);\n\n    /// @notice Identifier of the Centrifuge pool\n    function poolId() external view returns (PoolId);\n\n    /// @notice Identifier of the share class of the Centrifuge pool\n    function scId() external view returns (ShareClassId);\n\n    /// @notice Set msg.sender as operator of owner, to `approved` status\n    /// @dev    MUST be called by endorsed sender\n    function setEndorsedOperator(address owner, bool approved) external;\n\n    /// @notice Returns the base investment manager contract handling the vault.\n    /// @dev This naming MUST NOT change due to requirements of legacy vaults (v2)\n    /// @return IBaseRequestManager The address of the manager contract that is between vault and gateway\n    function manager() external view returns (IBaseRequestManager);\n\n    /// @notice Checks whether the vault is partially (a)synchronous.\n    ///\n    /// @return vaultKind_ The kind of the vault\n    function vaultKind() external view returns (VaultKind vaultKind_);\n}\n\n/**\n * @title  IAsyncRedeemVault\n * @dev    This is the specific set of interfaces used by the Centrifuge implementation of ERC7540,\n *         as a fully asynchronous Vault, with cancellation support, and authorize operator signature support.\n */\ninterface IAsyncRedeemVault is IERC7540Redeem, IERC7887Redeem, IBaseVault {\n    event RedeemClaimable(address indexed controller, uint256 indexed requestId, uint256 assets, uint256 shares);\n    event CancelRedeemClaimable(address indexed controller, uint256 indexed requestId, uint256 shares);\n\n    /// @notice Callback when a redeem Request is triggered externally;\n    function onRedeemRequest(address controller, address owner, uint256 shares) external;\n\n    /// @notice Callback when a redeem Request becomes claimable\n    function onRedeemClaimable(address owner, uint256 assets, uint256 shares) external;\n\n    /// @notice Callback when a claim redeem Request becomes claimable\n    function onCancelRedeemClaimable(address owner, uint256 shares) external;\n\n    /// @notice Retrieve the asynchronous redeem manager\n    function asyncRedeemManager() external view returns (IAsyncRedeemManager);\n}\n\ninterface IAsyncVault is IERC7540Deposit, IERC7887Deposit, IAsyncRedeemVault {\n    event DepositClaimable(address indexed controller, uint256 indexed requestId, uint256 assets, uint256 shares);\n    event CancelDepositClaimable(address indexed controller, uint256 indexed requestId, uint256 assets);\n\n    error InvalidOwner();\n    error RequestDepositFailed();\n\n    /// @notice Callback when a deposit Request becomes claimable\n    function onDepositClaimable(address owner, uint256 assets, uint256 shares) external;\n\n    /// @notice Callback when a claim deposit Request becomes claimable\n    function onCancelDepositClaimable(address owner, uint256 assets) external;\n}\n"
    },
    "src/vaults/interfaces/IEscrow.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IRecoverable} from \"src/misc/Recoverable.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\n/// @title  Escrow for holding assets\ninterface IEscrow {\n    // --- Events ---\n    /// @notice Emitted when an authTransferTo is made\n    /// @dev Needed as allowances increase attack surface\n    event AuthTransferTo(address indexed asset, uint256 indexed tokenId, address reciver, uint256 value);\n\n    /// @notice Emitted when the escrow has insufficient balance for an action - virtual or actual balance\n    error InsufficientBalance(address asset, uint256 tokenId, uint256 value, uint256 balance);\n\n    /// @notice\n    function authTransferTo(address asset, uint256 tokenId, address receiver, uint256 value) external;\n\n    /// @notice\n    function authTransferTo(address asset, address receiver, uint256 value) external;\n}\n\nstruct Holding {\n    uint128 total;\n    uint128 reserved;\n}\n\n/// @title PerPoolEscrow separating funds by pool and share class\ninterface IPoolEscrow is IEscrow, IRecoverable {\n    // --- Events ---\n    /// @notice Emitted when a deposit is made\n    /// @param asset The address of the deposited asset\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param poolId The id of the pool\n    /// @param scId The id of the share class\n    /// @param value The amount deposited\n    event Deposit(\n        address indexed asset, uint256 indexed tokenId, PoolId indexed poolId, ShareClassId scId, uint128 value\n    );\n\n    /// @notice Emitted when an amount is reserved\n    /// @param asset The address of the reserved asset\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param poolId The id of the pool\n    /// @param scId The id of the share class\n    /// @param value The delta amount reserved\n    /// @param value The new absolute amount reserved\n    event IncreaseReserve(\n        address indexed asset,\n        uint256 indexed tokenId,\n        PoolId indexed poolId,\n        ShareClassId scId,\n        uint256 delta,\n        uint128 value\n    );\n\n    /// @notice Emitted when an amount is unreserved\n    /// @param asset The address of the reserved asset\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param poolId The id of the pool\n    /// @param scId The id of the share class\n    /// @param value The delta amount unreserved\n    /// @param value The new absolute amount reserved\n    event DecreaseReserve(\n        address indexed asset,\n        uint256 indexed tokenId,\n        PoolId indexed poolId,\n        ShareClassId scId,\n        uint256 delta,\n        uint128 value\n    );\n\n    /// @notice Emitted when a withdraw is made\n    /// @param asset The address of the withdrawn asset\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param poolId The id of the pool\n    /// @param scId The id of the share class\n    /// @param value The amount withdrawn\n    event Withdraw(\n        address indexed asset, uint256 indexed tokenId, PoolId indexed poolId, ShareClassId scId, uint128 value\n    );\n\n    // --- Errors ---\n    /// @notice Dispatched when the balance of the escrow did not increase sufficiently\n    error InsufficientDeposit();\n\n    /// @notice Dispatched when the outstanding reserved amount is insufficient for the decrease\n    error InsufficientReservedAmount();\n\n    // --- Functions ---\n    /// @notice Deposits `value` of `asset` in underlying `poolId` and given `scId`\n    ///\n    /// @dev NOTE: Must ensure balance sufficiency, i.e. that the depositing amount does not exceed the balance of\n    /// escrow\n    ///\n    /// @param scId The id of the share class\n    /// @param asset The address of the asset to be deposited\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param value The amount to deposit\n    function deposit(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external;\n\n    /// @notice Withdraws `value` of `asset` in underlying `poolId` and given `scId`\n    /// @dev MUST ensure that reserved amounts are not withdrawn\n    /// @param scId The id of the share class\n    /// @param asset The address of the asset to be withdrawn\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param value The amount to withdraw\n    function withdraw(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external;\n\n    /// @notice Increases the reserved amount of `value` for `asset` in underlying `poolId` and given `scId`\n    /// @dev MUST prevent the reserved amount from being withdrawn\n    /// @param scId The id of the share class\n    /// @param asset The address of the asset to be reserved\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param value The amount to reserve\n    function reserveIncrease(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external;\n\n    /// @notice Decreases the reserved amount of `value` for `asset` in underlying `poolId` and given `scId`\n    /// @dev MUST fail if `value` is greater than the current reserved amount\n    /// @param scId The id of the share class\n    /// @param asset The address of the asset to be reserved\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @param value The amount to decrease\n    function reserveDecrease(ShareClassId scId, address asset, uint256 tokenId, uint128 value) external;\n\n    /// @notice Provides the available balance of `asset` in underlying `poolId` and given `scId`\n    /// @dev MUST return the balance minus the reserved amount\n    /// @param scId The id of the share class\n    /// @param asset The address of the asset to be checked\n    /// @param tokenId The id of the asset - 0 for ERC20\n    /// @return The available balance\n    function availableBalanceOf(ShareClassId scId, address asset, uint256 tokenId) external view returns (uint128);\n}\n"
    },
    "src/vaults/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IVaultFactory} from \"src/vaults/interfaces/factories/IVaultFactory.sol\";\nimport {IBaseVault, VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\n/// @dev Centrifuge pools\nstruct Pool {\n    uint256 createdAt;\n    mapping(ShareClassId scId => ShareClassDetails) shareClasses;\n}\n\n/// @dev Each Centrifuge pool is associated to 1 or more shar classes\nstruct ShareClassDetails {\n    IShareToken shareToken;\n    /// @dev Each share class has an individual price per share class unit in pool denomination (POOL_UNIT/SHARE_UNIT)\n    Price pricePoolPerShare;\n    /// @dev Each share class can have multiple vaults deployed,\n    ///      multiple vaults can be linked to the same asset.\n    ///      A vault in this storage DOES NOT mean the vault can be used\n    mapping(address asset => mapping(uint256 tokenId => IBaseVault[])) vaults;\n    /// @dev For each share class, we store the price per pool unit in asset denomination (POOL_UNIT/ASSET_UNIT)\n    mapping(address asset => mapping(uint256 tokenId => Price)) pricePoolPerAsset;\n}\n\n/// @dev Price struct that contains a price, the timestamp at which it was computed and the max age of the price.\nstruct Price {\n    uint128 price;\n    uint64 computedAt;\n    uint64 maxAge;\n}\n\n/// @dev Checks if a price is valid. Returns false if price is 0 or computedAt is 0. Otherwise checks for block\n/// timestamp <= computedAt + maxAge\nfunction isValid(Price memory price) view returns (bool) {\n    if (price.computedAt != 0 && price.price != 0) {\n        return block.timestamp <= price.validUntil();\n    } else {\n        return false;\n    }\n}\n\n/// @dev Computes the timestamp until the price is valid. Saturates at uint64.MAX.\nfunction validUntil(Price memory price) pure returns (uint64) {\n    unchecked {\n        uint64 validUntil_ = price.computedAt + price.maxAge;\n        if (validUntil_ < price.computedAt) {\n            return type(uint64).max;\n        }\n        return validUntil_;\n    }\n}\n\n/// @dev Retrieves the price as an D18 from the struct\nfunction asPrice(Price memory price) pure returns (D18) {\n    return d18(price.price);\n}\n\nusing {isValid, asPrice, validUntil} for Price global;\n\nstruct VaultDetails {\n    /// @dev AssetId of the asset\n    AssetId assetId;\n    /// @dev Address of the asset\n    address asset;\n    /// @dev TokenId of the asset - zero if asset is ERC20, non-zero if asset is ERC6909\n    uint256 tokenId;\n    /// @dev Whether this wrapper conforms to the IERC20Wrapper interface\n    bool isWrapper;\n    /// @dev Whether the vault is linked to a share class atm\n    bool isLinked;\n}\n\nstruct AssetIdKey {\n    /// @dev The address of the asset\n    address asset;\n    /// @dev The ERC6909 token id or 0, if the underlying asset is an ERC20\n    uint256 tokenId;\n}\n\ninterface IPoolManager {\n    event File(bytes32 indexed what, address data);\n    event RegisterAsset(\n        AssetId indexed assetId,\n        address indexed asset,\n        uint256 indexed tokenId,\n        string name,\n        string symbol,\n        uint8 decimals\n    );\n    event File(bytes32 indexed what, address factory, bool status);\n    event AddPool(PoolId indexed poolId);\n    event AddShareClass(PoolId indexed poolId, ShareClassId indexed scId, IShareToken token);\n    event DeployVault(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        address indexed asset,\n        uint256 tokenId,\n        IVaultFactory factory,\n        IBaseVault vault,\n        VaultKind kind\n    );\n    event PriceUpdate(\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        address indexed asset,\n        uint256 tokenId,\n        uint256 price,\n        uint64 computedAt\n    );\n    event PriceUpdate(PoolId indexed poolId, ShareClassId indexed scId, uint256 price, uint64 computedAt);\n    event TransferShares(\n        uint16 centrifugeId,\n        PoolId indexed poolId,\n        ShareClassId indexed scId,\n        address indexed sender,\n        bytes32 destinationAddress,\n        uint128 amount\n    );\n    event UpdateContract(PoolId indexed poolId, ShareClassId indexed scId, address target, bytes payload);\n    event LinkVault(\n        PoolId indexed poolId, ShareClassId indexed scId, address indexed asset, uint256 tokenId, IBaseVault vault\n    );\n    event UnlinkVault(\n        PoolId indexed poolId, ShareClassId indexed scId, address indexed asset, uint256 tokenId, IBaseVault vault\n    );\n    event UpdateMaxSharePriceAge(PoolId indexed poolId, ShareClassId indexed scId, uint64 maxPriceAge);\n    event UpdateMaxAssetPriceAge(\n        PoolId indexed poolId, ShareClassId indexed scId, address indexed asset, uint256 tokenId, uint64 maxPriceAge\n    );\n\n    error FileUnrecognizedParam();\n    error TooFewDecimals();\n    error TooManyDecimals();\n    error PoolAlreadyAdded();\n    error InvalidPool();\n    error ShareClassAlreadyRegistered();\n    error InvalidHook();\n    error OldMetadata();\n    error CannotSetOlderPrice();\n    error OldHook();\n    error UnknownVault();\n    error UnknownAsset();\n    error MalformedVaultUpdateMessage();\n    error UnknownToken();\n    error InvalidFactory();\n    error InvalidPrice();\n    error AssetMissingDecimals();\n    error ShareTokenDoesNotExist();\n    error LocalTransferNotAllowed();\n    error CrossChainTransferNotAllowed();\n    error ShareTokenTransferFailed();\n    error TransferFromFailed();\n\n    /// @notice Returns the asset address and tokenId associated with a given asset id.\n    /// @dev Reverts if asset id does not exist\n    ///\n    /// @param assetId The underlying internal uint128 assetId.\n    /// @return asset The address of the asset linked to the given asset id.\n    /// @return tokenId The token id corresponding to the asset, i.e. zero if ERC20 or non-zero if ERC6909.\n    function idToAsset(AssetId assetId) external view returns (address asset, uint256 tokenId);\n\n    /// @notice Returns assetId given the asset address and tokenId.\n    /// @dev Reverts if asset id does not exist\n    ///\n    /// @param asset The address of the asset linked to the given asset id.\n    /// @param tokenId The token id corresponding to the asset, i.e. zero if ERC20 or non-zero if ERC6909.\n    /// @return assetId The underlying internal uint128 assetId.\n    function assetToId(address asset, uint256 tokenId) external view returns (AssetId assetId);\n\n    /// @notice Updates a contract parameter\n    /// @param what Accepts a bytes32 representation of 'gateway', 'investmentManager', 'tokenFactory',\n    ///                'vaultFactory', or 'gasService'\n    function file(bytes32 what, address data) external;\n\n    /// @notice Updates a contract parameter\n    /// @param what Accepts a bytes32 representation of 'vaultFactory'\n    function file(bytes32 what, address factory, bool status) external;\n\n    /// @notice transfers share class tokens to a cross-chain recipient address\n    /// @dev    To transfer to evm chains, pad a 20 byte evm address with 12 bytes of 0\n    /// @param  centrifugeId The destination chain id\n    /// @param  poolId The centrifuge pool id\n    /// @param  scId The share class id\n    /// @param  receiver A bytes32 representation of the receiver address\n    /// @param  amount The amount of tokens to transfer\n    function transferShares(uint16 centrifugeId, PoolId poolId, ShareClassId scId, bytes32 receiver, uint128 amount)\n        external\n        payable;\n\n    /// @notice Registers an ERC-20 or ERC-6909 asset in another chain.\n    /// @dev `decimals()` MUST return a `uint8` value between 2 and 18.\n    /// @dev `name()` and `symbol()` MAY return no values.\n    ///\n    /// @param centrifugeId The centrifuge id of chain to where the shares are transferred\n    /// @param asset The address of the asset to be registered\n    /// @param tokenId The token id corresponding to the asset, i.e. zero if ERC20 or non-zero if ERC6909.\n    /// @return assetId The underlying internal uint128 assetId.\n    function registerAsset(uint16 centrifugeId, address asset, uint256 tokenId)\n        external\n        payable\n        returns (AssetId assetId);\n\n    /// @notice Deploys a new vault\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to deploy a vault\n    /// @param factory The address of the corresponding vault factory\n    /// @return address The address of the deployed vault\n    function deployVault(PoolId poolId, ShareClassId scId, AssetId assetId, IVaultFactory factory)\n        external\n        returns (IBaseVault);\n\n    /// @notice Links a deployed vault to the given pool, share class and asset.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to deploy a vault\n    /// @param vault The address of the deployed vault\n    function linkVault(PoolId poolId, ShareClassId scId, AssetId assetId, IBaseVault vault) external;\n\n    /// @notice Removes the link between a vault and the given pool, share class and asset.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to deploy a vault\n    /// @param vault The address of the deployed vault\n    function unlinkVault(PoolId poolId, ShareClassId scId, AssetId assetId, IBaseVault vault) external;\n\n    /// @notice Returns whether the given pool id is active\n    function isPoolActive(PoolId poolId) external view returns (bool);\n\n    /// @notice Returns the share class token for a given pool and share class id.\n    /// @dev Reverts if share class does not exists\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @return address The address of the share token\n    function shareToken(PoolId poolId, ShareClassId scId) external view returns (IShareToken);\n\n    /// @notice Function to get the details of a vault\n    /// @dev    Reverts if vault does not exist\n    ///\n    /// @param vault The address of the vault to be checked for\n    /// @return details The details of the vault including the underlying asset address, token id, asset id\n    function vaultDetails(IBaseVault vault) external view returns (VaultDetails memory details);\n\n    /// @notice Checks whether a given asset-vault pair is eligible for investing into a share class of a pool\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param asset The address of the asset\n    /// @param vault The address of the vault\n    /// @return bool Whether vault is to a share class\n    function isLinked(PoolId poolId, ShareClassId scId, address asset, IBaseVault vault) external view returns (bool);\n\n    /// @notice Returns the price per share for a given pool, share class, asset, and asset id. The provided price is\n    /// defined as ASSET_UNIT/SHARE_UNIT.\n    /// @dev Conditionally checks if price is valid.\n    ///\n    /// @dev NOTE: Should never be used for calculating amounts due to precision loss. Instead, please refer to\n    /// conversion relying on pricePoolPerShare and pricePoolPerAsset. See PricingLib for more information.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to know the ASSET_UNIT/SHARE_UNIT price\n    /// @param checkValidity Whether to check if the price is valid\n    /// @return price The asset price per share\n    function priceAssetPerShare(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        external\n        view\n        returns (D18 price);\n\n    /// @notice Returns the price per share for a given pool and share class. The Provided price is defined as\n    /// POOL_UNIT/SHARE_UNIT.\n    /// @dev Conditionally checks if price is valid.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param checkValidity Whether to check if the price is valid\n    /// @return price The pool price per share\n    function pricePoolPerShare(PoolId poolId, ShareClassId scId, bool checkValidity)\n        external\n        view\n        returns (D18 price);\n\n    /// @notice Returns the price per asset for a given pool, share class and the underlying asset id. The Provided\n    /// price is defined as POOL_UNIT/ASSET_UNIT.\n    /// @dev Conditionally checks if price is valid.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to know the POOL_UNIT/ASSET_UNIT.\n    /// @param checkValidity Whether to check if the price is valid\n    /// @return price The pool price per asset unit\n    function pricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        external\n        view\n        returns (D18 price);\n\n    /// @notice Returns the both prices per pool for a given pool, share class and the underlying asset id. The Provided\n    /// prices is defined as POOL_UNIT/ASSET_UNIT and POOL_UNIT/SHARE_UNIT.\n    /// @dev Conditionally checks if prices are valid.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to know pool price per asset\n    /// @param checkValidity Whether to check if the prices are valid\n    /// @return pricePoolPerAsset The pool price per asset unit, i.e. POOL_UNIT/ASSET_UNIT\n    /// @return pricePoolPerShare The pool price per share unit, i.e. POOL_UNIT/SHARE_UNIT\n    function pricesPoolPer(PoolId poolId, ShareClassId scId, AssetId assetId, bool checkValidity)\n        external\n        view\n        returns (D18 pricePoolPerAsset, D18 pricePoolPerShare);\n\n    /// @notice Returns the age related markers for a share class price\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @return computedAt The timestamp when this price was computed\n    /// @return maxAge The maximum age this price is allowed to have\n    /// @return validUntil The timestamp until this price is valid\n    function markersPricePoolPerShare(PoolId poolId, ShareClassId scId)\n        external\n        view\n        returns (uint64 computedAt, uint64 maxAge, uint64 validUntil);\n\n    /// @notice Returns the age related markers for an asset price\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id for which we want to know pool price per asset\n    /// @return computedAt The timestamp when this price was computed\n    /// @return maxAge The maximum age this price is allowed to have\n    /// @return validUntil The timestamp until this price is valid\n    function markersPricePoolPerAsset(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        view\n        returns (uint64 computedAt, uint64 maxAge, uint64 validUntil);\n}\n"
    },
    "src/vaults/interfaces/IUpdateContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\ninterface IUpdateContract {\n    error UnknownUpdateContractType();\n\n    /// @notice Triggers an update on the target contract.\n    /// @param  poolId The centrifuge pool id\n    /// @param  scId The share class id\n    /// @param  payload The payload to be processed by the target address\n    function update(PoolId poolId, ShareClassId scId, bytes calldata payload) external;\n}\n"
    },
    "src/vaults/interfaces/IVaultRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport {IMulticall} from \"src/misc/interfaces/IMulticall.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {IBaseVault, IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {BaseSyncDepositVault} from \"src/vaults/BaseVaults.sol\";\n\ninterface IVaultRouter is IMulticall {\n    // --- Events ---\n    event LockDepositRequest(\n        IBaseVault indexed vault, address indexed controller, address indexed owner, address sender, uint256 amount\n    );\n    event UnlockDepositRequest(IBaseVault indexed vault, address indexed controller, address indexed receiver);\n    event ExecuteLockedDepositRequest(IBaseVault indexed vault, address indexed controller, address sender);\n\n    error InvalidOwner();\n    error NoLockedBalance();\n    error NoLockedRequest();\n    error ZeroBalance();\n    error WrapFailed();\n    error UnwrapFailed();\n    error InvalidSender();\n    error NonSyncDepositVault();\n    error NonAsyncVault();\n\n    /// @notice Check how much of the `vault`'s asset is locked for the current `controller`.\n    /// @dev    This is a getter method\n    function lockedRequests(address controller, IBaseVault vault) external view returns (uint256 amount);\n\n    // --- Manage permissionless claiming ---\n    /// @notice Enable permissionless claiming\n    /// @dev    After this is called, anyone can claim tokens to msg.sender.\n    ///         Even any requests submitted directly to the vault (not through the VaultRouter) will be\n    ///         permissionlessly claimable through the VaultRouter, until `disable()` is called.\n    function enable(IBaseVault vault) external payable;\n\n    /// @notice Disable permissionless claiming\n    function disable(IBaseVault vault) external payable;\n\n    // --- Deposit ---\n    /// @notice Check `IERC7540Deposit.requestDeposit`.\n    /// @dev    This adds a mandatory prepayment for all the costs that will incur during the transaction.\n    ///         The caller must call `VaultRouter.estimate` to get estimates how much the deposit will cost.\n    ///\n    /// @param  vault The vault to deposit into\n    /// @param  amount Check @param IERC7540Deposit.requestDeposit.assets\n    /// @param  controller Check @param IERC7540Deposit.requestDeposit.controller\n    /// @param  owner Check @param IERC7540Deposit.requestDeposit.owner\n    function requestDeposit(IAsyncVault vault, uint256 amount, address controller, address owner) external payable;\n\n    /// @notice Check `IERC4626.deposit`.\n    /// @dev    This adds a mandatory prepayment for all the costs that will incur during the transaction.\n    ///         The caller must call `VaultRouter.estimate` to get estimates how much the deposit will cost.\n    ///\n    /// @param  vault The vault to deposit into\n    /// @param  assets Check @param IERC4626.deposit.assets\n    /// @param  receiver Check @param IERC4626.deposit.receiver\n    /// @param  owner User from which to transfer the assets, either msg.sender or the VaultRouter\n    function deposit(BaseSyncDepositVault vault, uint256 assets, address receiver, address owner) external payable;\n\n    /// @notice Locks `amount` of `vault`'s asset in an escrow before actually sending a deposit LockDepositRequest\n    ///         There are users that would like to interact with the protocol but don't have permissions yet. They can\n    ///         lock the funds they would like to deposit beforehand.\n    ///         Once permissions are granted, anyone can deposit on\n    ///         their behalf by calling `executeLockedDepositRequest`.\n    ///\n    ///         Example: DAO with onchain governance, that wants to invest their treasury\n    ///             The process that doesn't include calling this method is as follows:\n    ///\n    ///                 1. The DAO signs the legal agreements for the pool => no onchain action,\n    ///                    but only after this the issuer can call update_member to add them as a whitelisted investor\n    ///                 2. Call `requestDeposit` to lock funds\n    ///                 3. After the pool has fulfilled their request, call `deposit` to claim their share class tokens\n    ///\n    ///\n    ///             With the new router function the steps are as follows:\n    ///\n    ///                 1. DAO signs the legal agreement + calls  `openLockDepositRequest`  in 1 governance proposal\n    ///\n    ///                 2. Issuer then gives them permissions, then calls `executeLockDepositFunds` for them,\n    ///                    then fulfills the request, then calls `claimDeposit` for them\n    ///\n    /// @dev    For initial interaction better use `openLockDepositRequest` which includes some of the message calls\n    ///         that the caller must do execute before calling `lockDepositRequest`\n    ///\n    /// @param  vault The address of the vault to invest in\n    /// @param  amount Amount to invest\n    /// @param  controller Address of the owner of the position\n    /// @param  owner Where the  funds to be deposited will be take from\n    function lockDepositRequest(IBaseVault vault, uint256 amount, address controller, address owner) external payable;\n\n    /// @notice Helper method to lock a deposit request, and enable permissionless claiming of that vault in 1 call.\n    /// @dev    It starts interaction with the vault by calling `open`.\n    ///         Vaults support assets that are wrapped one. When user calls this method\n    ///         and the vault's asset is a wrapped one, first the balance of the wrapped asset is checked.\n    ///         If balance >= `amount`, then this asset is used\n    ///         else  amount is treat as an underlying asset one and it is wrapped.\n    /// @param  vault Address of the vault\n    /// @param  amount Amount to be deposited\n    function enableLockDepositRequest(IBaseVault vault, uint256 amount) external payable;\n\n    /// @notice Unlocks all deposited assets of the current caller for a given vault\n    ///\n    /// @param  vault Address of the vault for which funds were locked\n    /// @param  receiver Address of the received of the unlocked funds\n    function unlockDepositRequest(IBaseVault vault, address receiver) external payable;\n\n    /// @notice After the controller is given permissions, anyone can call this method and\n    ///         actually request a deposit with the locked funds on the behalf of the `controller`\n    /// @param  vault The vault for which funds are locked\n    /// @param  controller Owner of the deposit position\n    function executeLockedDepositRequest(IAsyncVault vault, address controller) external payable;\n\n    /// @notice Check IERC7540Deposit.mint\n    /// @param  vault Address of the vault\n    /// @param  receiver Check IERC7540Deposit.mint.receiver\n    /// @param  controller Check IERC7540Deposit.mint.owner\n    function claimDeposit(IAsyncVault vault, address receiver, address controller) external payable;\n\n    // --- Redeem ---\n    /// @notice Check `IERC7887Deposit.cancelDepositRequest`.\n    /// @dev    This adds a mandatory prepayment for all the costs that will incur during the transaction.\n    ///         The caller must call `VaultRouter.estimate` to get estimates how much the deposit will cost.\n    ///\n    /// @param  vault The vault where the deposit was initiated\n    function cancelDepositRequest(IAsyncVault vault) external payable;\n\n    /// @notice Check IERC7887Deposit.claimCancelDepositRequest\n    ///\n    /// @param  vault Address of the vault\n    /// @param  receiver Check  IERC7887Deposit.claimCancelDepositRequest.receiver\n    /// @param  controller Check  IERC7887Deposit.claimCancelDepositRequest.controller\n    function claimCancelDepositRequest(IAsyncVault vault, address receiver, address controller) external payable;\n\n    // --- Redeem ---\n    /// @notice Check `IERC7540Redeem.requestRedeem`.\n    /// @dev    This adds a mandatory prepayment for all the costs that will incur during the transaction.\n    ///         The caller must call `VaultRouter.estimate` to get estimates how much the deposit will cost.\n    ///\n    /// @param  vault The vault to deposit into\n    /// @param  amount Check @param IERC7540Redeem.requestRedeem.shares\n    /// @param  controller Check @param IERC7540Redeem.requestRedeem.controller\n    /// @param  owner Check @param IERC7540Redeem.requestRedeem.owner\n    function requestRedeem(IAsyncVault vault, uint256 amount, address controller, address owner) external payable;\n\n    /// @notice Check IERC7575.withdraw\n    /// @dev    If the underlying vault asset is a wrapped one,\n    ///         `VaultRouter.unwrap` is called and the unwrapped\n    ///         asset is sent to the receiver\n    /// @param  vault Address of the vault\n    /// @param  receiver Check IERC7575.withdraw.receiver\n    /// @param  controller Check IERC7575.withdraw.owner\n    function claimRedeem(IBaseVault vault, address receiver, address controller) external payable;\n\n    /// @notice Check `IERC7887Redeem.cancelRedeemRequest`.\n    /// @dev    This adds a mandatory prepayment for all the costs that will incur during the transaction.\n    ///         The caller must call `VaultRouter.estimate` to get estimates how much the deposit will cost.\n    ///\n    /// @param  vault The vault where the deposit was initiated\n    function cancelRedeemRequest(IAsyncVault vault) external payable;\n\n    /// @notice Check IERC7887Redeem.claimableCancelRedeemRequest\n    ///\n    /// @param  vault Address of the vault\n    /// @param  receiver Check  IERC7887Redeem.claimCancelRedeemRequest.receiver\n    /// @param  controller Check  IERC7887Redeem.claimCancelRedeemRequest.controller\n    function claimCancelRedeemRequest(IAsyncVault vault, address receiver, address controller) external payable;\n\n    // --- ERC20 permit ---\n    /// @notice Check IERC20.permit\n    function permit(address asset, address spender, uint256 assets, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        payable;\n\n    // --- ERC20 wrapping ---\n    /// @notice There are vault which underlying asset is actuall a wrapped one.\n    ///\n    /// @param  wrapper The address of the wrapper\n    /// @param  amount  Amount to be wrapped\n    /// @param  receiver Receiver of the wrapped tokens\n    /// @param  owner The address from which `amount` is taken from\n    function wrap(address wrapper, uint256 amount, address receiver, address owner) external payable;\n\n    /// @notice There are vault which underlying asset is actuall a wrapped one.\n    /// @dev    Wrapped tokens need to be held by the VaultRouter to be unwrapped.\n    /// @param  wrapper The address of the wrapper\n    /// @param  amount  Amount to be wrapped\n    /// @param  receiver Receiver of the unwrapped tokens\n    function unwrap(address wrapper, uint256 amount, address receiver) external payable;\n\n    // --- View Methods ---\n    /// @notice Check IPoolManager.getVault\n    function getVault(PoolId poolId, ShareClassId scId, address asset) external view returns (address);\n\n    /// @notice Check IGateway.estimate\n    ///         If the destination and source chain ID are the same, this will always return 0.\n    /// @param centrifugeId destination chain\n    function estimate(uint16 centrifugeId, bytes calldata payload) external view returns (uint256 amount);\n\n    /// @notice Called to check if `user` has permissions on `vault` to execute requests\n    ///\n    /// @param vault Address of the `vault` the `user` wants to operate on\n    /// @param user Address of the `user` that will operates on the `vault`\n    /// @return Whether `user` has permissions to operate on `vault`\n    function hasPermissions(IBaseVault vault, address user) external view returns (bool);\n\n    /// @notice Returns whether the controller has called `enable()` for the given `vault`\n    function isEnabled(IBaseVault vault, address controller) external view returns (bool);\n}\n"
    },
    "src/vaults/interfaces/factories/IPoolEscrowFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\n\ninterface IPoolEscrowProvider {\n    /// @notice Returns the deterministic address of an escrow contract based on a given pool id wrapped into the\n    /// corresponding interface.\n    ///\n    /// @dev Does not check, whether the escrow was already deployed.\n    function escrow(PoolId poolId) external view returns (IPoolEscrow);\n}\n\ninterface IPoolEscrowFactory is IPoolEscrowProvider {\n    event DeployPoolEscrow(PoolId indexed poolId, address indexed escrow);\n    event File(bytes32 what, address data);\n\n    error FileUnrecognizedParam();\n    error EscrowAlreadyDeployed();\n\n    /// @notice Deploys new escrow and returns it.\n    /// @dev All share classes of a pool are represented by the same escrow contract.\n    ///\n    /// @param poolId Id of the pool this escrow is deployed for\n    /// @return IPoolEscrow The the newly deployed escrow contract\n    function newEscrow(PoolId poolId) external returns (IPoolEscrow);\n\n    /// @notice Updates contract parameters of type address.\n    function file(bytes32 what, address data) external;\n}\n"
    },
    "src/vaults/interfaces/factories/ITokenFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\ninterface ITokenFactory {\n    /// @notice Used to deploy new share class tokens.\n    /// @dev    In order to have the same address on different EVMs `salt` should be used\n    ///         during creationg process.\n    /// @param name Name of the new token.\n    /// @param symbol Symbol of the new token.\n    /// @param decimals Decimals of the new token.\n    /// @param salt Salt used for deterministic deployments.\n    /// @param tokenWards Address which can call methods behind authorized only.\n    function newToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 salt,\n        address[] calldata tokenWards\n    ) external returns (IShareToken);\n\n    /// @notice Returns the predicted address (using CREATE2)\n    function getAddress(uint8 decimals, bytes32 salt) external view returns (address);\n}\n"
    },
    "src/vaults/interfaces/factories/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface IVaultFactory {\n    error UnsupportedTokenId();\n\n    /// @notice Deploys new vault for `poolId`, `scId` and `asset`.\n    ///\n    /// @param poolId Id of the pool. Id is one of the already supported pools.\n    /// @param scId Id of the share class token. Id is one of the already supported share class tokens.\n    /// @param asset Address of the underlying asset that is getting deposited inside the pool.\n    /// @param asset Token id of the underlying asset that is getting deposited inside the pool. I.e. zero if asset\n    /// corresponds to ERC20 or non-zero if asset corresponds to ERC6909.\n    /// @param token Address of the share class token that is getting issues against the deposited asset.\n    /// @param wards_ Address which can call methods behind authorized only.\n    function newVault(\n        PoolId poolId,\n        ShareClassId scId,\n        address asset,\n        uint256 tokenId,\n        IShareToken token,\n        address[] calldata wards_\n    ) external returns (IBaseVault);\n}\n"
    },
    "src/vaults/interfaces/investments/IAsyncDepositManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IDepositManager} from \"src/vaults/interfaces/investments/IDepositManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface IAsyncDepositManager is IDepositManager {\n    /// @notice Requests assets deposit. Vaults have to request investments from Centrifuge before\n    ///         shares can be minted. The deposit requests are added to the order book\n    ///         on the corresponding CP instance. Once the next epoch is executed on the corresponding CP instance,\n    /// vaults can\n    ///         proceed with share payouts in case the order got fulfilled.\n    /// @dev    The assets required to fulfill the deposit request have to be locked and are transferred from the\n    ///         owner to the escrow, even though the share payout can only happen after epoch execution.\n    ///         The receiver becomes the owner of deposit request fulfillment.\n    /// @param  source Deprecated\n    function requestDeposit(IBaseVault vault, uint256 assets, address receiver, address owner, address source)\n        external\n        returns (bool);\n\n    /// @notice Requests the cancellation of a pending deposit request. Vaults have to request the\n    ///         cancellation of outstanding requests from Centrifuge before actual assets can be unlocked and\n    /// transferred\n    ///         to the owner.\n    ///         While users have outstanding cancellation requests no new deposit requests can be submitted.\n    ///         Once the next epoch is executed on the corresponding CP instance, vaults can proceed with asset payouts\n    ///         if orders could be cancelled successfully.\n    /// @dev    The cancellation request might fail in case the pending deposit order already got fulfilled on\n    ///         Centrifuge.\n    /// @param  source Deprecated\n    function cancelDepositRequest(IBaseVault vault, address owner, address source) external;\n\n    /// @notice Processes owner's deposit request cancellation after the epoch has been executed on the corresponding CP\n    /// instance and the\n    ///         deposit order cancellation has been successfully processed (partial fulfillment possible).\n    ///         Assets are transferred from the escrow to the receiver.\n    /// @dev    The assets required to fulfill the claim have already been reserved for the owner in escrow on\n    ///         fulfillCancelDepositRequest.\n    function claimCancelDepositRequest(IBaseVault vault, address receiver, address owner)\n        external\n        returns (uint256 assets);\n\n    /// @notice Indicates whether a user has pending deposit requests and returns the total deposit request asset\n    /// request value.\n    function pendingDepositRequest(IBaseVault vault, address user) external view returns (uint256 assets);\n\n    /// @notice Indicates whether a user has pending deposit request cancellations.\n    function pendingCancelDepositRequest(IBaseVault vault, address user) external view returns (bool isPending);\n\n    /// @notice Indicates whether a user has claimable deposit request cancellation and returns the total claim\n    ///         value in assets.\n    function claimableCancelDepositRequest(IBaseVault vault, address user) external view returns (uint256 assets);\n}\n"
    },
    "src/vaults/interfaces/investments/IAsyncRedeemManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IRedeemManager} from \"src/vaults/interfaces/investments/IRedeemManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface IAsyncRedeemManager is IRedeemManager {\n    /// @notice Requests share redemption. Vaults have to request redemptions\n    ///         from Centrifuge before actual asset payouts can be done. The redemption\n    ///         requests are added to the order book on the corresponding CP instance. Once the next epoch is\n    ///         executed on the corresponding CP instance, vaults can proceed with asset payouts\n    ///         in case the order got fulfilled.\n    /// @dev    The shares required to fulfill the redemption request have to be locked and are transferred from the\n    ///         owner to the escrow, even though the asset payout can only happen after epoch execution.\n    ///         The receiver becomes the owner of redeem request fulfillment.\n    /// @param  source Deprecated\n    function requestRedeem(IBaseVault vault, uint256 shares, address receiver, address owner, address source)\n        external\n        returns (bool);\n\n    /// @notice Requests the cancellation of an pending redeem request. Vaults have to request the\n    ///         cancellation of outstanding requests from Centrifuge before actual shares can be unlocked and\n    ///         transferred to the owner.\n    ///         While users have outstanding cancellation requests no new redeem requests can be submitted (exception:\n    ///         trigger through governance).\n    ///         Once the next epoch is executed on the corresponding CP instance, vaults can proceed with share payouts\n    ///         if the orders could be cancelled successfully.\n    /// @dev    The cancellation request might fail in case the pending redeem order already got fulfilled on\n    ///         Centrifuge.\n    function cancelRedeemRequest(IBaseVault vault, address owner, address source) external;\n\n    /// @notice Processes owner's redeem request cancellation after the epoch has been executed on the corresponding CP\n    /// instance and the\n    ///         redeem order cancellation has been successfully processed (partial fulfillment possible).\n    ///         Shares are transferred from the escrow to the receiver.\n    /// @dev    The shares required to fulfill the claim have already been reserved for the owner in escrow on\n    ///         fulfillCancelRedeemRequest.\n    ///         Receiver has to pass all the share token restrictions in order to receive the shares.\n    function claimCancelRedeemRequest(IBaseVault vault, address receiver, address owner)\n        external\n        returns (uint256 shares);\n\n    /// @notice Indicates whether a user has pending redeem requests and returns the total share request value.\n    function pendingRedeemRequest(IBaseVault vault, address user) external view returns (uint256 shares);\n\n    /// @notice Indicates whether a user has pending redeem request cancellations.\n    function pendingCancelRedeemRequest(IBaseVault vault, address user) external view returns (bool isPending);\n\n    /// @notice Indicates whether a user has claimable redeem request cancellation and returns the total claim\n    ///         value in shares.\n    function claimableCancelRedeemRequest(IBaseVault vault, address user) external view returns (uint256 shares);\n}\n"
    },
    "src/vaults/interfaces/investments/IAsyncRequestManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IRequestManagerGatewayHandler} from \"src/common/interfaces/IGatewayHandlers.sol\";\n\nimport {IAsyncDepositManager} from \"src/vaults/interfaces/investments/IAsyncDepositManager.sol\";\nimport {IAsyncRedeemManager} from \"src/vaults/interfaces/investments/IAsyncRedeemManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\n/// @dev Vault requests and deposit/redeem bookkeeping per user\nstruct AsyncInvestmentState {\n    /// @dev Shares that can be claimed using `mint()`\n    uint128 maxMint;\n    /// @dev Assets that can be claimed using `withdraw()`\n    uint128 maxWithdraw;\n    /// @dev Weighted average price of deposits, used to convert maxMint to maxDeposit\n    /// @dev Represents priceAssetPerShare, i.e. ASSET_UNIT/SHARE_UNIT\n    uint256 depositPrice;\n    /// @dev Weighted average price of redemptions, used to convert maxWithdraw to maxRedeem\n    /// @dev Represents priceAssetPerShare, i.e. ASSET_UNIT/SHARE_UNIT\n    uint256 redeemPrice;\n    /// @dev Remaining deposit request in assets\n    uint128 pendingDepositRequest;\n    /// @dev Remaining redeem request in shares\n    uint128 pendingRedeemRequest;\n    /// @dev Assets that can be claimed using `claimCancelDepositRequest()`\n    uint128 claimableCancelDepositRequest;\n    /// @dev Shares that can be claimed using `claimCancelRedeemRequest()`\n    uint128 claimableCancelRedeemRequest;\n    /// @dev Indicates whether the depositRequest was requested to be cancelled\n    bool pendingCancelDepositRequest;\n    /// @dev Indicates whether the redeemRequest was requested to be cancelled\n    bool pendingCancelRedeemRequest;\n}\n\ninterface IAsyncRequestManager is IAsyncDepositManager, IAsyncRedeemManager, IRequestManagerGatewayHandler {\n    error ZeroAmountNotAllowed();\n    error TransferNotAllowed();\n    error CancellationIsPending();\n    error NoPendingRequest();\n    error ShareTokenAmountIsZero();\n    error FailedRedeemRequest();\n    error ExceedsDepositLimits();\n    error ShareTokenTransferFailed();\n    error ExceedsMaxRedeem();\n    error ExceedsRedeemLimits();\n\n    /// @notice Returns the investment state\n    function investments(IBaseVault vaultAddr, address investor)\n        external\n        view\n        returns (\n            uint128 maxMint,\n            uint128 maxWithdraw,\n            uint256 depositPrice,\n            uint256 redeemPrice,\n            uint128 pendingDepositRequest,\n            uint128 pendingRedeemRequest,\n            uint128 claimableCancelDepositRequest,\n            uint128 claimableCancelRedeemRequest,\n            bool pendingCancelDepositRequest,\n            bool pendingCancelRedeemRequest\n        );\n}\n"
    },
    "src/vaults/interfaces/investments/IBaseRequestManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IPoolManager} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IPoolEscrow, IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\n\ninterface IBaseRequestManager {\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n\n    error FileUnrecognizedParam();\n    error SenderNotVault();\n    error AssetNotAllowed();\n    error ExceedsMaxDeposit();\n    error AssetMismatch();\n    error VaultAlreadyExists();\n    error VaultDoesNotExist();\n\n    /// @notice Updates contract parameters of type address.\n    /// @param what The bytes32 representation of 'gateway' or 'poolManager'.\n    /// @param data The new contract address.\n    function file(bytes32 what, address data) external;\n\n    /// @notice Converts the assets value to share decimals.\n    function convertToShares(IBaseVault vault, uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Converts the shares value to assets decimals.\n    function convertToAssets(IBaseVault vault, uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice Returns the timestamp of the last share price update for a vaultAddr.\n    function priceLastUpdated(IBaseVault vault) external view returns (uint64 lastUpdated);\n\n    /// @notice Returns the PoolManager contract address.\n    function poolManager() external view returns (IPoolManager poolManager);\n\n    /// @notice The global escrow used for funds that are not yet free to be used for a specific pool\n    function globalEscrow() external view returns (IEscrow escrow);\n\n    /// @notice Escrow per pool. Funds are associated to a specific pool\n    function poolEscrow(PoolId poolId) external view returns (IPoolEscrow);\n\n    /// @notice Adds new vault for `poolId`, `scId` and `asset`.\n    function addVault(PoolId poolId, ShareClassId scId, IBaseVault vault, address asset, AssetId assetId) external;\n\n    /// @notice Removes `vault` from `who`'s authorized callers\n    function removeVault(PoolId poolId, ShareClassId scId, IBaseVault vault, address asset, AssetId assetId) external;\n\n    /// @notice Returns the address of the vault for a given pool, share class and asset\n    function vaultByAssetId(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        view\n        returns (IBaseVault vault);\n}\n"
    },
    "src/vaults/interfaces/investments/IDepositManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface IDepositManager is IBaseRequestManager {\n    /// @notice Processes owner's asset deposit after the epoch has been executed on the corresponding CP instance and\n    /// the deposit order\n    ///         has been successfully processed (partial fulfillment possible).\n    ///         Shares are transferred from the escrow to the receiver. Amount of shares is computed based of the amount\n    ///         of assets and the owner's share price.\n    /// @dev    The assets required to fulfill the deposit are already locked in escrow upon calling requestDeposit.\n    ///         The shares required to fulfill the deposit have already been minted and transferred to the escrow on\n    ///         fulfillDepositRequest.\n    ///         Receiver has to pass all the share token restrictions in order to receive the shares.\n    function deposit(IBaseVault vault, uint256 assets, address receiver, address owner)\n        external\n        returns (uint256 shares);\n\n    /// @notice Processes owner's share mint after the epoch has been executed on the corresponding CP instance and the\n    /// deposit order has\n    ///         been successfully processed (partial fulfillment possible).\n    ///         Shares are transferred from the escrow to the receiver. Amount of assets is computed based of the amount\n    ///         of shares and the owner's share price.\n    /// @dev    The assets required to fulfill the mint are already locked in escrow upon calling requestDeposit.\n    ///         The shares required to fulfill the mint have already been minted and transferred to the escrow on\n    ///         fulfillDepositRequest.\n    ///         Receiver has to pass all the share token restrictions in order to receive the shares.\n    function mint(IBaseVault vault, uint256 shares, address receiver, address owner)\n        external\n        returns (uint256 assets);\n\n    /// @notice Returns the max amount of assets based on the unclaimed amount of shares after at least one successful\n    ///         deposit order fulfillment on the corresponding CP instance.\n    function maxDeposit(IBaseVault vault, address user) external view returns (uint256);\n\n    /// @notice Returns the max amount of shares a user can claim after at least one successful deposit order\n    ///         fulfillment on the corresponding CP instance.\n    function maxMint(IBaseVault vault, address user) external view returns (uint256 shares);\n}\n"
    },
    "src/vaults/interfaces/investments/IRedeemManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface IRedeemManager is IBaseRequestManager {\n    event TriggerRedeemRequest(\n        uint64 indexed poolId,\n        bytes16 indexed scId,\n        address user,\n        address indexed asset,\n        uint256 tokenId,\n        uint128 shares\n    );\n\n    /// @notice Processes owner's share redemption after the epoch has been executed on the corresponding CP instance\n    /// and the redeem order\n    ///         has been successfully processed (partial fulfillment possible).\n    ///         Assets are transferred from the escrow to the receiver. Amount of assets is computed based of the amount\n    ///         of shares and the owner's share price.\n    /// @dev    The shares required to fulfill the redemption were already locked in escrow on requestRedeem and burned\n    ///         on fulfillRedeemRequest.\n    ///         The assets required to fulfill the redemption have already been reserved in escrow on\n    ///         fulfillRedeemtRequest.\n    function redeem(IBaseVault vault, uint256 shares, address receiver, address owner)\n        external\n        returns (uint256 assets);\n\n    /// @notice Processes owner's asset withdrawal after the epoch has been executed on the corresponding CP instance\n    /// and the redeem order\n    ///         has been successfully processed (partial fulfillment possible).\n    ///         Assets are transferred from the escrow to the receiver. Amount of shares is computed based of the amount\n    ///         of shares and the owner's share price.\n    /// @dev    The shares required to fulfill the withdrawal were already locked in escrow on requestRedeem and burned\n    ///         on fulfillRedeemRequest.\n    ///         The assets required to fulfill the withdrawal have already been reserved in escrow on\n    ///         fulfillRedeemtRequest.\n    function withdraw(IBaseVault vault, uint256 assets, address receiver, address owner)\n        external\n        returns (uint256 shares);\n\n    /// @notice Returns the max amount of shares based on the unclaimed number of assets after at least one successful\n    ///         redeem order fulfillment on the corresponding CP instance.\n    function maxRedeem(IBaseVault vault, address user) external view returns (uint256 shares);\n\n    /// @notice Returns the max amount of assets a user can claim after at least one successful redeem order fulfillment\n    ///         on the corresponding CP instance.\n    function maxWithdraw(IBaseVault vault, address user) external view returns (uint256 assets);\n}\n"
    },
    "src/vaults/interfaces/investments/ISyncDepositManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IDepositManager} from \"src/vaults/interfaces/investments/IDepositManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface ISyncDepositManager is IDepositManager {\n    function previewDeposit(IBaseVault vault, address sender, uint256 assets) external view returns (uint256);\n    function previewMint(IBaseVault vault, address sender, uint256 shares) external view returns (uint256);\n}\n"
    },
    "src/vaults/interfaces/investments/ISyncRequestManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {D18} from \"src/misc/types/D18.sol\";\n\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {IUpdateContract} from \"src/vaults/interfaces/IUpdateContract.sol\";\nimport {ISyncDepositManager} from \"src/vaults/interfaces/investments/ISyncDepositManager.sol\";\n\n/// @dev Solely used locally as protection against stack-too-deep\nstruct Prices {\n    /// @dev Price of 1 asset unit per share unit\n    D18 assetPerShare;\n    /// @dev Price of 1 pool unit per asset unit\n    D18 poolPerAsset;\n    /// @dev Price of 1 pool unit per share unit\n    D18 poolPerShare;\n}\n\ninterface ISyncDepositValuation {\n    /// @notice Returns the pool price per share for a given pool and share class, asset, and asset id.\n    // The provided price is defined as POOL_UNIT/SHARE_UNIT.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @return price The pool price per share\n    function pricePoolPerShare(PoolId poolId, ShareClassId scId) external view returns (D18 price);\n}\n\ninterface ISyncRequestManager is ISyncDepositManager, ISyncDepositValuation, IUpdateContract {\n    event SetValuation(PoolId indexed poolId, ShareClassId indexed scId, address valuation);\n    event SetMaxReserve(\n        PoolId indexed poolId, ShareClassId indexed scId, address asset, uint256 tokenId, uint128 maxReserve\n    );\n\n    error ExceedsMaxMint();\n    error ShareTokenDoesNotExist();\n    error SecondaryManagerDoesNotExist();\n\n    /// @notice Sets the valuation for a specific pool and share class.\n    ///\n    /// @param poolId The id of the pool\n    /// @param scId The id of the share class\n    /// @param valuation The address of the valuation contract\n    function setValuation(PoolId poolId, ShareClassId scId, address valuation) external;\n\n    /// @notice Sets the max reserve for a specific pool, share class and asset.\n    ///\n    /// @param poolId The id of the pool\n    /// @param scId The id of the share class\n    /// @param asset The address of the asset\n    /// @param tokenId The asset token id, i.e. 0 for ERC20, or the token id for ERC6909\n    /// @param maxReserve The amount of maximum reserve\n    function setMaxReserve(PoolId poolId, ShareClassId scId, address asset, uint256 tokenId, uint128 maxReserve)\n        external;\n\n    /// @notice Returns the all three prices for a given pool, share class, asset, and asset id.\n    ///\n    /// @param poolId The pool id\n    /// @param scId The share class id\n    /// @param assetId The asset id corresponding to the asset and tokenId\n    /// @return priceData The asset price per share, pool price per asset, and pool price per share\n    function prices(PoolId poolId, ShareClassId scId, AssetId assetId)\n        external\n        view\n        returns (Prices memory priceData);\n}\n"
    },
    "src/vaults/interfaces/token/IShareToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20Metadata} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC7575Share} from \"src/misc/interfaces/IERC7575.sol\";\n\ninterface IERC1404 {\n    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n    /// @param from Sending address\n    /// @param to Receiving address\n    /// @param value Amount of tokens being transferred\n    /// @return Code by which to reference message for rejection reasoning\n    /// @dev Overwrite with your custom transfer restriction logic\n    function detectTransferRestriction(address from, address to, uint256 value) external view returns (uint8);\n\n    /// @notice Returns a human-readable message for a given restriction code\n    /// @param restrictionCode Identifier for looking up a message\n    /// @return Text showing the restriction's reasoning\n    /// @dev Overwrite with your custom message and restrictionCode handling\n    function messageForTransferRestriction(uint8 restrictionCode) external view returns (string memory);\n}\n\ninterface IShareToken is IERC20Metadata, IERC7575Share, IERC1404 {\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event SetHookData(address indexed user, bytes16 data);\n\n    // --- Errors ---\n    error NotAuthorizedOrHook();\n    error ExceedsMaxSupply();\n    error RestrictionsFailed();\n\n    struct Balance {\n        /// @dev The user balance is limited to uint128. This is safe because the decimals are limited to 18,\n        ///      thus the max balance is 2^128-1 / 10**18 = 3.40 * 10**20. This is also enforced on mint.\n        uint128 amount;\n        /// @dev There are 16 bytes that are used to store hook data (e.g. restrictions for users).\n        bytes16 hookData;\n    }\n\n    // --- Administration ---\n    /// @notice returns the hook that transfers perform callbacks to\n    /// @dev    MUST comply to `IHook` interface\n    function hook() external view returns (address);\n\n    /// @notice Updates a contract parameter\n    /// @param what Accepts a bytes32 representation of 'name', 'symbol'\n    function file(bytes32 what, string memory data) external;\n\n    /// @notice Updates a contract parameter\n    /// @param what Accepts a bytes32 representation of 'hook'\n    function file(bytes32 what, address data) external;\n\n    /// @notice updates the vault for a given `asset`\n    function updateVault(address asset, address vault_) external;\n\n    // --- ERC20 overrides ---\n    /// @notice returns the 16 byte hook data of the given `user`.\n    /// @dev    Stored in the 128 most significant bits of the user balance\n    function hookDataOf(address user) external view returns (bytes16);\n\n    /// @notice update the 16 byte hook data of the given `user`\n    function setHookData(address user, bytes16 hookData) external;\n\n    /// @notice Function to mint tokens\n    function mint(address user, uint256 value) external;\n\n    /// @notice Function to burn tokens\n    function burn(address user, uint256 value) external;\n\n    /// @notice Checks if the tokens can be transferred given the input values\n    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);\n\n    /// @notice Performs an authorized transfer, with `sender` as the given sender.\n    /// @dev    Requires allowance if `sender` != `from`\n    function authTransferFrom(address sender, address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "src/vaults/legacy/LegacyVaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {ILegacyVault} from \"src/vaults/legacy/interfaces/ILegacyVault.sol\";\nimport {IInvestmentManager} from \"src/vaults/legacy/interfaces/IInvestmentManager.sol\";\nimport {ILegacyVaultAdapter} from \"src/vaults/legacy/interfaces/ILegacyVaultAdapter.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {AsyncVault} from \"src/vaults/AsyncVault.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {BaseAsyncRedeemVault, IAsyncRedeemVault} from \"src/vaults/BaseVaults.sol\";\n\n/// @title  LegacyVaultAdapter\n/// @notice An adapter connecting legacy ERC-7540 vaults from Centrifuge V2 to Centrifuge V3.\n///\n/// @dev    This adapter acts as an `IInvestmentManager` for a single legacy `ILegacyVault` vault from Centrifuge V2.\n///         At the same time it acts like a new `IAsyncVault` for the `IAsyncRequestManager` manager of Centrifuge V3.\n///         The adapter needs to be deployed per legacy vault and allows a seamless interaction between Centrifuge V2\n///         vaults and Centrifuge V3 infrastructure. Thereby, allowing to migrate existing vaults to the new system.\ncontract LegacyVaultAdapter is AsyncVault, ILegacyVaultAdapter, IInvestmentManager {\n    uint64 public immutable legacyPoolId;\n    bytes16 public immutable legacyTrancheId;\n    ILegacyVault public immutable legacyVault;\n\n    constructor(\n        ILegacyVault legacyVault_,\n        PoolId poolId,\n        uint64 legacyPoolId_,\n        ShareClassId scId,\n        bytes16 legacyTrancheId_,\n        address asset,\n        IShareToken token,\n        address root,\n        IAsyncRequestManager manager\n    ) AsyncVault(poolId, scId, asset, token, root, manager) {\n        require(legacyVault_.poolId() == legacyPoolId_, NotLegacyPoolId(legacyPoolId_, legacyVault_.poolId()));\n        require(\n            legacyVault_.trancheId() == legacyTrancheId_, NotLegacyTrancheId(legacyTrancheId_, legacyVault_.trancheId())\n        );\n        require(legacyVault_.asset() == asset, NotLegacyAsset(asset, legacyVault_.asset()));\n        require(legacyVault_.share() == address(token), NotLegacyShare(address(token), legacyVault_.share()));\n\n        legacyPoolId = legacyPoolId_;\n        legacyTrancheId = legacyTrancheId_;\n        legacyVault = legacyVault_;\n    }\n\n    /// @dev Check if the msg.sender is the legacy vault\n    modifier legacy() {\n        require(msg.sender == address(legacyVault), NotLegacyVault(msg.sender, address(legacyVault)));\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // IInvestmentManager handlers\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IInvestmentManager\n    function requestDeposit(address, /* vault */ uint256 assets, address receiver, address owner, address source)\n        public\n        legacy\n        returns (bool)\n    {\n        return asyncManager().requestDeposit(this, assets, receiver, owner, source);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function requestRedeem(address, /* vault */ uint256 shares, address receiver, address owner, address source)\n        public\n        legacy\n        returns (bool)\n    {\n        return asyncManager().requestRedeem(this, shares, receiver, owner, source);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function cancelDepositRequest(address, /* vault */ address owner, address source) public legacy {\n        return asyncManager().cancelDepositRequest(this, owner, source);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function cancelRedeemRequest(address, /* vault */ address owner, address source) public legacy {\n        return asyncManager().cancelRedeemRequest(this, owner, source);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // IInvestmentManager view methods\n    //----------------------------------------------------------------------------------------------\n\n    function escrow() public view returns (address) {\n        return address(manager.globalEscrow());\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function convertToShares(address, /* vault */ uint256 _assets) public view returns (uint256 shares) {\n        shares = asyncManager().convertToShares(this, _assets);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function convertToAssets(address, /* vault */ uint256 _shares) public view returns (uint256 assets) {\n        assets = asyncManager().convertToAssets(this, _shares);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function maxDeposit(address, /* vault */ address user) public view returns (uint256 assets) {\n        assets = asyncManager().maxDeposit(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function maxMint(address, /* vault */ address user) public view returns (uint256 shares) {\n        shares = asyncManager().maxMint(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function maxWithdraw(address, /* vault */ address user) public view returns (uint256 assets) {\n        assets = asyncManager().maxWithdraw(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function maxRedeem(address, /* vault */ address user) public view returns (uint256 shares) {\n        shares = asyncManager().maxRedeem(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function pendingDepositRequest(address, /* vault */ address user) public view returns (uint256 assets) {\n        assets = asyncManager().pendingDepositRequest(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function pendingRedeemRequest(address, /* vault */ address user) public view returns (uint256 shares) {\n        shares = asyncManager().pendingRedeemRequest(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function pendingCancelDepositRequest(address, /* vault */ address user) public view returns (bool isPending) {\n        isPending = asyncManager().pendingCancelDepositRequest(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function pendingCancelRedeemRequest(address, /* vault */ address user) public view returns (bool isPending) {\n        isPending = asyncManager().pendingCancelRedeemRequest(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function claimableCancelDepositRequest(address, /* vault */ address user) public view returns (uint256 assets) {\n        assets = asyncManager().claimableCancelDepositRequest(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function claimableCancelRedeemRequest(address, /* vault */ address user) public view returns (uint256 shares) {\n        shares = asyncManager().claimableCancelRedeemRequest(this, user);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function priceLastUpdated(address /* vault */ ) public view returns (uint64 lastUpdated) {\n        lastUpdated = manager.priceLastUpdated(this);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // IInvestmentManager vault claim methods\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IInvestmentManager\n    function deposit(address, /* vault */ uint256 assets, address receiver, address owner)\n        public\n        legacy\n        returns (uint256 shares)\n    {\n        shares = asyncManager().deposit(this, assets, receiver, owner);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function mint(address, /* vault */ uint256 shares, address receiver, address owner)\n        public\n        legacy\n        returns (uint256 assets)\n    {\n        assets = asyncManager().mint(this, shares, receiver, owner);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function redeem(address, /* vault */ uint256 shares, address receiver, address owner)\n        public\n        legacy\n        returns (uint256 assets)\n    {\n        assets = asyncManager().redeem(this, shares, receiver, owner);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function withdraw(address, /* vault */ uint256 assets, address receiver, address owner)\n        public\n        legacy\n        returns (uint256 shares)\n    {\n        shares = asyncManager().withdraw(this, assets, receiver, owner);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function claimCancelDepositRequest(address, /* vault */ address receiver, address owner)\n        public\n        legacy\n        returns (uint256 assets)\n    {\n        assets = asyncManager().claimCancelDepositRequest(this, receiver, owner);\n    }\n\n    /// @inheritdoc IInvestmentManager\n    function claimCancelRedeemRequest(address, /* vault */ address receiver, address owner)\n        public\n        legacy\n        returns (uint256 shares)\n    {\n        shares = asyncManager().claimCancelRedeemRequest(this, receiver, owner);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Event emitters\n    //----------------------------------------------------------------------------------------------\n\n    function onDepositClaimable(address controller, uint256 assets, uint256 shares) public override auth {\n        legacyVault.onDepositClaimable(controller, assets, shares);\n    }\n\n    function onCancelDepositClaimable(address controller, uint256 assets) public override auth {\n        legacyVault.onCancelDepositClaimable(controller, assets);\n    }\n\n    function onRedeemRequest(address controller, address owner, uint256 shares)\n        public\n        override(BaseAsyncRedeemVault, IAsyncRedeemVault)\n        auth\n    {\n        legacyVault.onRedeemRequest(controller, owner, shares);\n    }\n\n    function onRedeemClaimable(address controller, uint256 assets, uint256 shares)\n        public\n        override(BaseAsyncRedeemVault, IAsyncRedeemVault)\n        auth\n    {\n        legacyVault.onRedeemClaimable(controller, assets, shares);\n    }\n\n    function onCancelRedeemClaimable(address controller, uint256 shares)\n        public\n        override(BaseAsyncRedeemVault, IAsyncRedeemVault)\n        auth\n    {\n        legacyVault.onCancelRedeemClaimable(controller, shares);\n    }\n}\n"
    },
    "src/vaults/legacy/interfaces/IInvestmentManager.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.5.0;\n\n/// @notice A stripped down version of the Centrifuge V2 investment manager.\n///\n/// @dev This interface is needed to ensure adapters for legacy vaults are provided with the expected interface.\ninterface IInvestmentManager {\n    /// @notice Documentation see Centrifuge V2 repository.\n    function escrow() external view returns (address);\n\n    // --- Outgoing message handling ---\n    /// @notice Documentation see Centrifuge V2 repository.\n    function requestDeposit(address vault, uint256 assets, address receiver, address owner, address source)\n        external\n        returns (bool);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function requestRedeem(address vault, uint256 shares, address receiver, address, /* owner */ address source)\n        external\n        returns (bool);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function cancelDepositRequest(address vault, address owner, address source) external;\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function cancelRedeemRequest(address vault, address owner, address source) external;\n\n    // --- View functions ---\n    /// @notice Documentation see Centrifuge V2 repository.\n    function convertToShares(address vault, uint256 _assets) external view returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function convertToAssets(address vault, uint256 _shares) external view returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function maxDeposit(address vault, address user) external view returns (uint256);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function maxMint(address vault, address user) external view returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function maxWithdraw(address vault, address user) external view returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function maxRedeem(address vault, address user) external view returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function pendingDepositRequest(address vault, address user) external view returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function pendingRedeemRequest(address vault, address user) external view returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function pendingCancelDepositRequest(address vault, address user) external view returns (bool isPending);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function pendingCancelRedeemRequest(address vault, address user) external view returns (bool isPending);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function claimableCancelDepositRequest(address vault, address user) external view returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function claimableCancelRedeemRequest(address vault, address user) external view returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function priceLastUpdated(address vault) external view returns (uint64 lastUpdated);\n\n    // --- Vault claim functions ---\n    /// @notice Documentation see Centrifuge V2 repository.\n    function deposit(address vault, uint256 assets, address receiver, address owner)\n        external\n        returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function mint(address vault, uint256 shares, address receiver, address owner) external returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function redeem(address vault, uint256 shares, address receiver, address owner) external returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function withdraw(address vault, uint256 assets, address receiver, address owner)\n        external\n        returns (uint256 shares);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function claimCancelDepositRequest(address vault, address receiver, address owner)\n        external\n        returns (uint256 assets);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function claimCancelRedeemRequest(address vault, address receiver, address owner)\n        external\n        returns (uint256 shares);\n}\n"
    },
    "src/vaults/legacy/interfaces/ILegacyVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.5.0;\n\n/// @notice A stripped down version of the Centrifuge V2 ERC-7540 vault.\n///\n/// @dev This interface is needed to ensure adapters for legacy vaults are provided with the expected interface.\ninterface ILegacyVault {\n    /// @notice Documentation see Centrifuge V2 repository.\n    function poolId() external view returns (uint64);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function trancheId() external view returns (bytes16);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function asset() external view returns (address);\n\n    /// @notice Documentation see Centrifuge V2 repository.\n    function share() external view returns (address);\n\n    /// @notice Callback when a redeem Request is triggered externally;\n    function onRedeemRequest(address controller, address owner, uint256 shares) external;\n\n    /// @notice Callback when a deposit Request becomes claimable\n    function onDepositClaimable(address owner, uint256 assets, uint256 shares) external;\n\n    /// @notice Callback when a redeem Request becomes claimable\n    function onRedeemClaimable(address owner, uint256 assets, uint256 shares) external;\n\n    /// @notice Callback when a claim deposit Request becomes claimable\n    function onCancelDepositClaimable(address owner, uint256 assets) external;\n\n    /// @notice Callback when a claim redeem Request becomes claimable\n    function onCancelRedeemClaimable(address owner, uint256 shares) external;\n}\n"
    },
    "src/vaults/legacy/interfaces/ILegacyVaultAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\ninterface ILegacyVaultAdapter {\n    error NotLegacyVault(address sender, address legacyVault);\n    error NotLegacyPoolId(uint64 providedPoolId, uint64 legacyPoolId);\n    error NotLegacyTrancheId(bytes16 providedTrancheId, bytes16 legacyTrancheId);\n    error NotLegacyAsset(address providedAsset, address legacyAsset);\n    error NotLegacyShare(address providedShare, address legacyShare);\n}\n"
    },
    "src/vaults/token/ShareToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {IERC20, IERC20Metadata} from \"src/misc/interfaces/IERC20.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IERC7575Share, IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {\n    IHook,\n    HookData,\n    SUCCESS_CODE_ID,\n    SUCCESS_MESSAGE,\n    ERROR_CODE_ID,\n    ERROR_MESSAGE\n} from \"src/common/interfaces/IHook.sol\";\nimport {IShareToken, IERC1404} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\n/// @title  Share Token\n/// @notice Extension of ERC20 + ERC1404,\n///         integrating an external hook optionally for ERC20 callbacks and ERC1404 checks.\ncontract ShareToken is ERC20, IShareToken {\n    using MathLib for uint256;\n\n    mapping(address => Balance) private balances;\n\n    /// @inheritdoc IShareToken\n    address public hook;\n\n    /// @inheritdoc IERC7575Share\n    mapping(address asset => address) public vault;\n\n    constructor(uint8 decimals_) ERC20(decimals_) {}\n\n    modifier authOrHook() {\n        require(wards[msg.sender] == 1 || msg.sender == hook, NotAuthorizedOrHook());\n        _;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // Administration\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareToken\n    function file(bytes32 what, address data) external authOrHook {\n        if (what == \"hook\") hook = data;\n        else revert FileUnrecognizedParam();\n        emit File(what, data);\n    }\n\n    /// @inheritdoc IShareToken\n    function file(bytes32 what, string memory data) public override(ERC20, IShareToken) auth {\n        super.file(what, data);\n    }\n\n    /// @inheritdoc IShareToken\n    function updateVault(address asset, address vault_) external auth {\n        vault[asset] = vault_;\n        emit VaultUpdate(asset, vault_);\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-20 overrides\n    //----------------------------------------------------------------------------------------------\n\n    function _balanceOf(address user) internal view override returns (uint256) {\n        return balances[user].amount;\n    }\n\n    function _setBalance(address user, uint256 value) internal override {\n        balances[user].amount = value.toUint128();\n    }\n\n    /// @inheritdoc IShareToken\n    function hookDataOf(address user) public view returns (bytes16) {\n        return balances[user].hookData;\n    }\n\n    /// @inheritdoc IShareToken\n    function setHookData(address user, bytes16 hookData) public authOrHook {\n        balances[user].hookData = hookData;\n        emit SetHookData(user, hookData);\n    }\n\n    /// @inheritdoc IERC20\n    function transfer(address to, uint256 value) public override(ERC20, IERC20) returns (bool success) {\n        success = super.transfer(to, value);\n        _onTransfer(msg.sender, to, value);\n    }\n\n    /// @inheritdoc IERC20\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override(ERC20, IERC20)\n        returns (bool success)\n    {\n        success = super.transferFrom(from, to, value);\n        _onTransfer(from, to, value);\n    }\n\n    /// @inheritdoc IShareToken\n    function mint(address to, uint256 value) public override(ERC20, IShareToken) {\n        super.mint(to, value);\n        require(totalSupply <= type(uint128).max, ExceedsMaxSupply());\n        _onTransfer(address(0), to, value);\n    }\n\n    /// @inheritdoc IShareToken\n    function burn(address from, uint256 value) public override(ERC20, IShareToken) {\n        super.burn(from, value);\n        _onTransfer(from, address(0), value);\n    }\n\n    function _onTransfer(address from, address to, uint256 value) internal {\n        address hook_ = hook;\n        require(\n            hook_ == address(0)\n                || IHook(hook_).onERC20Transfer(from, to, value, HookData(hookDataOf(from), hookDataOf(to)))\n                    == IHook.onERC20Transfer.selector,\n            RestrictionsFailed()\n        );\n    }\n\n    /// @inheritdoc IShareToken\n    function authTransferFrom(address sender, address from, address to, uint256 value)\n        public\n        auth\n        returns (bool success)\n    {\n        success = _transferFrom(sender, from, to, value);\n        address hook_ = hook;\n        if (hook_ != address(0)) {\n            IHook(hook_).onERC20AuthTransfer(sender, from, to, value, HookData(hookDataOf(from), hookDataOf(to)));\n        }\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-1404\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IShareToken\n    function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n        return detectTransferRestriction(from, to, value) == SUCCESS_CODE_ID;\n    }\n\n    /// @inheritdoc IERC1404\n    function detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\n        address hook_ = hook;\n        if (hook_ == address(0)) return SUCCESS_CODE_ID;\n        return IHook(hook_).checkERC20Transfer(from, to, value, HookData(hookDataOf(from), hookDataOf(to)))\n            ? SUCCESS_CODE_ID\n            : ERROR_CODE_ID;\n    }\n\n    /// @inheritdoc IERC1404\n    function messageForTransferRestriction(uint8 restrictionCode) external pure returns (string memory) {\n        return restrictionCode == SUCCESS_CODE_ID ? SUCCESS_MESSAGE : ERROR_MESSAGE;\n    }\n\n    //----------------------------------------------------------------------------------------------\n    // ERC-165\n    //----------------------------------------------------------------------------------------------\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\n        return interfaceId == type(IERC7575Share).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "test/common/mocks/Mock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\ncontract Mock is Test {\n    // counting calls\n    mapping(bytes32 => uint256) public calls;\n    mapping(bytes32 => uint256[]) calls_with_value; // size: call counts, i_0: msg.value\n\n    // returns\n    mapping(bytes32 => uint256) public values_uint256_return;\n    mapping(bytes32 => uint128) public values_uint128_return;\n    mapping(bytes32 => bool) public values_bool_return;\n\n    // passed parameter\n    mapping(bytes32 => uint8) public values_uint8;\n    mapping(bytes32 => uint64) public values_uint16;\n    mapping(bytes32 => uint64) public values_uint64;\n    mapping(bytes32 => uint128) public values_uint128;\n    mapping(bytes32 => uint256) public values_uint256;\n    mapping(bytes32 => address) public values_address;\n    mapping(bytes32 => bytes32) public values_bytes16;\n    mapping(bytes32 => bytes32) public values_bytes32;\n    mapping(bytes32 => bytes) public values_bytes;\n    mapping(bytes32 => string) public values_string;\n    mapping(bytes32 => mapping(address => uint256)) public values_mapping_address_uint;\n\n    mapping(bytes32 => bool) method_fail;\n\n    function call(bytes32 name) internal {\n        calls[name]++;\n    }\n\n    function callWithValue(bytes32 name, uint256 value) public {\n        calls_with_value[name].push(value);\n    }\n\n    function callsWithValue(bytes32 key) public view returns (uint256[] memory) {\n        return calls_with_value[key];\n    }\n\n    function setReturn(bytes32 name, uint256 returnValue) public {\n        values_uint256_return[name] = returnValue;\n    }\n\n    function setReturn(bytes32 name, uint128 returnValue) public {\n        values_uint128_return[name] = returnValue;\n    }\n\n    function setReturn(bytes32 name, bool returnValue) public {\n        values_bool_return[name] = returnValue;\n    }\n\n    function setFail(bytes32 name, bool flag) public {\n        method_fail[name] = flag;\n    }\n}\n"
    },
    "test/common/mocks/MockAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\nimport \"test/common/mocks/Mock.sol\";\n\ncontract MockAdapter is Auth, Mock, IAdapter {\n    IMessageHandler public immutable gateway;\n\n    uint16 centrifugeId;\n    mapping(bytes => uint256) public sent;\n\n    constructor(uint16 centrifugeId_, IMessageHandler gateway_) Auth(msg.sender) {\n        centrifugeId = centrifugeId_;\n        gateway = gateway_;\n    }\n\n    function execute(bytes memory _message) external {\n        gateway.handle(centrifugeId, _message);\n    }\n\n    function send(uint16, bytes calldata message, uint256, address) public payable returns (bytes32 adapterData) {\n        callWithValue(\"send\", msg.value);\n        values_bytes[\"send\"] = message;\n        sent[message]++;\n        adapterData = bytes32(\"\");\n    }\n\n    function estimate(uint16, bytes calldata, uint256 baseCost) public view returns (uint256 estimation) {\n        estimation = values_uint256_return[\"estimate\"] + baseCost;\n    }\n}\n"
    },
    "test/common/mocks/MockGasService.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/common/mocks/Mock.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {MessageType} from \"src/common/libraries/MessageLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {IGasService} from \"src/common/interfaces/IGasService.sol\";\n\ncontract MockGasService is Mock, IGasService {\n    using BytesLib for bytes;\n\n    function gasLimit(uint16, bytes calldata) public view returns (uint128) {\n        return uint128(values_uint256_return[\"gasLimit\"]);\n    }\n\n    function maxBatchSize(uint16) public view returns (uint128) {\n        return uint128(values_uint256_return[\"maxBatchSize\"]);\n    }\n}\n"
    },
    "test/common/mocks/MockRoot.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/common/mocks/Mock.sol\";\n\ncontract MockRoot is Mock {\n    function endorsed(address) public view returns (bool) {\n        return values_bool_return[\"endorsed_user\"];\n    }\n\n    function paused() public view returns (bool isPaused) {\n        isPaused = values_bool_return[\"isPaused\"];\n    }\n}\n"
    },
    "test/common/types/AccountId.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {AccountId} from \"src/common/types/AccountId.sol\";\n\ncontract AccountIdTest is Test {\n    function testAccountId(uint32 id) public pure {\n        assertEq((AccountId.wrap(id).raw()), id);\n    }\n}\n"
    },
    "test/common/types/AssetId.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {AssetId, newAssetId} from \"src/common/types/AssetId.sol\";\n\ncontract AssetIdTest is Test {\n    function testAssetId(uint32 counter, uint16 centrifugeId) public pure {\n        vm.assume(centrifugeId > 0);\n        AssetId assetId = newAssetId(centrifugeId, counter);\n\n        assertEq(assetId.isNull(), false);\n        assertEq(assetId.centrifugeId(), centrifugeId);\n        assertEq(uint32(assetId.raw()), counter);\n        assertEq(assetId.addr(), address(uint160((uint128(centrifugeId) << 112) + counter)));\n    }\n\n    function testAssetIdIso(uint32 isoCode) public pure {\n        vm.assume(isoCode > 0);\n        AssetId assetId = newAssetId(isoCode);\n\n        assertEq(assetId.isNull(), false);\n        assertEq(assetId.centrifugeId(), uint32(0));\n        assertEq(uint32(assetId.raw()), isoCode);\n        assertEq(assetId.addr(), address(uint160(isoCode)));\n    }\n}\n"
    },
    "test/common/types/PoolId.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {PoolId, newPoolId} from \"src/common/types/PoolId.sol\";\n\ncontract PoolIdTest is Test {\n    function testPoolId(uint48 id, uint16 centrifugeId) public pure {\n        vm.assume(id > 0);\n        PoolId poolId = newPoolId(centrifugeId, id);\n\n        assertEq(poolId.isNull(), false);\n        assertEq(poolId.centrifugeId(), centrifugeId);\n        assertEq(uint48(poolId.raw()), id);\n    }\n}\n"
    },
    "test/common/types/ShareClassId.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {ShareClassId, newShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId, newPoolId} from \"src/common/types/PoolId.sol\";\n\ncontract ShareClassIdTest is Test {\n    function testShareClassId(bytes16 id) public pure {\n        vm.assume(id > 0);\n        ShareClassId scId = ShareClassId.wrap(id);\n        ShareClassId scId2 = ShareClassId.wrap(id);\n\n        assertEq(scId.isNull(), false);\n        assertEq(scId.raw(), id);\n        assertEq(scId == scId2, true);\n    }\n\n    function testNewShareClassId(uint64 poolId_, uint32 index) public pure {\n        PoolId poolId = PoolId.wrap(poolId_);\n        ShareClassId scId = newShareClassId(poolId, index);\n\n        assertEq(scId.raw(), bytes16((uint128(poolId.raw()) << 64) + index));\n    }\n\n    function testShareClassIdCollisionResistance(uint64 poolId1, uint64 poolId2, uint32 index1, uint32 index2)\n        public\n        pure\n    {\n        poolId1 = uint64(bound(poolId1, 2, type(uint64).max - 1));\n        index1 = uint32(bound(index1, 2, type(uint32).max - 1));\n        vm.assume(poolId2 != poolId1);\n        vm.assume(index1 != index2);\n\n        assertNotEq(\n            newShareClassId(PoolId.wrap(poolId1), index1).raw(), newShareClassId(PoolId.wrap(poolId2), index2).raw()\n        );\n\n        ShareClassId scId1 = newShareClassId(PoolId.wrap(poolId1), index1);\n        ShareClassId scId2 = newShareClassId(PoolId.wrap(poolId1 - 1), index1 + 1);\n        ShareClassId scId3 = newShareClassId(PoolId.wrap(poolId1 + 1), index1 - 1);\n        assertNotEq(scId1.raw(), scId2.raw());\n        assertNotEq(scId1.raw(), scId3.raw());\n        assertNotEq(scId2.raw(), scId3.raw());\n    }\n}\n"
    },
    "test/common/unit/AxelarAdapter.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {Mock} from \"test/common/mocks/Mock.sol\";\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {AxelarAdapter, IAdapter, IAxelarAdapter, IAxelarExecutable} from \"src/common/adapters/AxelarAdapter.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\n\ncontract MockAxelarGateway is Mock {\n    function validateContractCall(bytes32, string calldata, string calldata, bytes32) public view returns (bool) {\n        return values_bool_return[\"validateContractCall\"];\n    }\n\n    function callContract(string calldata destinationChain, string calldata contractAddress, bytes calldata payload)\n        public\n    {\n        values_string[\"destinationChain\"] = destinationChain;\n        values_string[\"contractAddress\"] = contractAddress;\n        values_bytes[\"payload\"] = payload;\n    }\n}\n\ncontract MockAxelarGasService is Mock {\n    function estimateGasFee(string calldata, string calldata, bytes calldata, uint256, bytes calldata /* params */ )\n        external\n        view\n        returns (uint256 gasEstimate)\n    {\n        return values_uint256_return[\"estimateGasFee\"];\n    }\n\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable {\n        callWithValue(\"payNativeGasForContractCall\", msg.value);\n        values_address[\"sender\"] = sender;\n        values_string[\"destinationChain\"] = destinationChain;\n        values_string[\"destinationAddress\"] = destinationAddress;\n        values_bytes[\"payload\"] = payload;\n        values_address[\"refundAddress\"] = refundAddress;\n    }\n}\n\ncontract AxelarAdapterTest is Test {\n    using CastLib for *;\n    using AxelarAddressToString for address;\n\n    uint16 constant CENTRIFUGE_CHAIN_ID = 1;\n    string constant AXELAR_CHAIN_ID = \"mainnet\";\n\n    MockAxelarGateway axelarGateway;\n    MockAxelarGasService axelarGasService;\n    AxelarAdapter adapter;\n\n    IMessageHandler constant GATEWAY = IMessageHandler(address(1));\n\n    function setUp() public {\n        axelarGateway = new MockAxelarGateway();\n        axelarGasService = new MockAxelarGasService();\n        adapter = new AxelarAdapter(GATEWAY, address(axelarGateway), address(axelarGasService), address(this));\n    }\n\n    function testDeploy() public view {\n        assertEq(address(adapter.gateway()), address(GATEWAY));\n        assertEq(address(adapter.axelarGateway()), address(axelarGateway));\n        assertEq(address(adapter.axelarGasService()), address(axelarGasService));\n\n        assertEq(adapter.wards(address(this)), 1);\n    }\n\n    function testEstimate(uint256 gasLimit) public {\n        vm.assume(gasLimit > 0);\n\n        bytes memory payload = \"irrelevant\";\n\n        axelarGasService.setReturn(\"estimateGasFee\", gasLimit - 1);\n\n        uint256 estimation = adapter.estimate(CENTRIFUGE_CHAIN_ID, payload, gasLimit);\n        assertEq(estimation, gasLimit - 1);\n    }\n\n    function testIncomingCalls(\n        bytes32 commandId,\n        address validAddress,\n        address invalidAddress,\n        string calldata invalidChain,\n        bytes calldata payload,\n        address invalidOrigin,\n        address relayer\n    ) public {\n        vm.assume(keccak256(abi.encodePacked(invalidAddress)) != keccak256(abi.encodePacked(validAddress)));\n        vm.assume(keccak256(abi.encodePacked(invalidChain)) != keccak256(abi.encodePacked(AXELAR_CHAIN_ID)));\n        vm.assume(invalidOrigin != address(axelarGateway));\n        vm.assume(relayer.code.length == 0);\n        assumeNotZeroAddress(validAddress);\n        assumeNotZeroAddress(invalidAddress);\n\n        vm.mockCall(\n            address(GATEWAY),\n            abi.encodeWithSelector(GATEWAY.handle.selector, CENTRIFUGE_CHAIN_ID, payload),\n            abi.encode()\n        );\n\n        // Correct input, but not yet setup\n        axelarGateway.setReturn(\"validateContractCall\", true);\n        vm.expectRevert(IAxelarExecutable.InvalidAddress.selector);\n        vm.prank(address(relayer));\n        adapter.execute(commandId, AXELAR_CHAIN_ID, validAddress.toAxelarString(), payload);\n\n        adapter.file(\"sources\", AXELAR_CHAIN_ID, CENTRIFUGE_CHAIN_ID, validAddress.toAxelarString());\n\n        // Incorrect address\n        vm.prank(address(relayer));\n        vm.expectRevert(IAxelarExecutable.InvalidAddress.selector);\n        adapter.execute(commandId, AXELAR_CHAIN_ID, invalidAddress.toAxelarString(), payload);\n\n        // address(0) from invalid chain should fail\n        vm.prank(address(relayer));\n        vm.expectRevert(IAxelarExecutable.InvalidAddress.selector);\n        adapter.execute(commandId, invalidChain, address(0).toAxelarString(), payload);\n\n        // Incorrect chain\n        vm.prank(address(relayer));\n        vm.expectRevert(IAxelarExecutable.InvalidAddress.selector);\n        adapter.execute(commandId, invalidChain, validAddress.toAxelarString(), payload);\n\n        // Axelar has not approved the payload\n        axelarGateway.setReturn(\"validateContractCall\", false);\n        vm.prank(address(relayer));\n        vm.expectRevert(IAxelarExecutable.NotApprovedByGateway.selector);\n        adapter.execute(commandId, AXELAR_CHAIN_ID, validAddress.toAxelarString(), payload);\n\n        // Correct\n        axelarGateway.setReturn(\"validateContractCall\", true);\n        vm.prank(address(relayer));\n        adapter.execute(commandId, AXELAR_CHAIN_ID, validAddress.toAxelarString(), payload);\n    }\n\n    function testOutgoingCalls(bytes calldata payload, address invalidOrigin, uint256 gasLimit, address refund)\n        public\n    {\n        vm.assume(invalidOrigin != address(GATEWAY));\n\n        vm.deal(address(this), 0.1 ether);\n        vm.expectRevert(IAdapter.NotGateway.selector);\n        adapter.send{value: 0.1 ether}(CENTRIFUGE_CHAIN_ID, payload, gasLimit, refund);\n\n        vm.deal(address(GATEWAY), 0.1 ether);\n        vm.prank(address(GATEWAY));\n        vm.expectRevert(IAdapter.UnknownChainId.selector);\n        adapter.send{value: 0.1 ether}(CENTRIFUGE_CHAIN_ID, payload, gasLimit, refund);\n\n        adapter.file(\n            \"destinations\", CENTRIFUGE_CHAIN_ID, AXELAR_CHAIN_ID, makeAddr(\"DestinationAdapter\").toAxelarString()\n        );\n\n        vm.deal(address(this), 0.1 ether);\n        vm.prank(address(GATEWAY));\n        adapter.send{value: 0.1 ether}(CENTRIFUGE_CHAIN_ID, payload, gasLimit, refund);\n\n        uint256[] memory call = axelarGasService.callsWithValue(\"payNativeGasForContractCall\");\n        assertEq(call.length, 1);\n        assertEq(call[0], 0.1 ether);\n        assertEq(axelarGasService.values_address(\"sender\"), address(adapter));\n        assertEq(axelarGasService.values_string(\"destinationChain\"), AXELAR_CHAIN_ID);\n        assertEq(axelarGasService.values_string(\"destinationAddress\"), makeAddr(\"DestinationAdapter\").toAxelarString());\n        assertEq(axelarGasService.values_bytes(\"payload\"), payload);\n        assertEq(axelarGasService.values_address(\"refundAddress\"), refund);\n\n        assertEq(axelarGateway.values_string(\"destinationChain\"), AXELAR_CHAIN_ID);\n        assertEq(axelarGateway.values_string(\"contractAddress\"), makeAddr(\"DestinationAdapter\").toAxelarString());\n        assertEq(axelarGateway.values_bytes(\"payload\"), payload);\n    }\n}\n\n// From https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/main/contracts/libs/AddressString.sol#L30C26-L45C6\nlibrary AxelarAddressToString {\n    function toAxelarString(address address_) internal pure returns (string memory) {\n        bytes memory addressBytes = abi.encodePacked(address_);\n        bytes memory characters = \"0123456789abcdef\";\n        bytes memory stringBytes = new bytes(42);\n\n        stringBytes[0] = \"0\";\n        stringBytes[1] = \"x\";\n\n        for (uint256 i; i < 20; ++i) {\n            stringBytes[2 + i * 2] = characters[uint8(addressBytes[i] >> 4)];\n            stringBytes[3 + i * 2] = characters[uint8(addressBytes[i] & 0x0f)];\n        }\n\n        return string(stringBytes);\n    }\n}\n"
    },
    "test/common/unit/GasService.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IMessageProperties} from \"src/common/interfaces/IMessageProperties.sol\";\nimport {MessageType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {GasService, IGasService} from \"src/common/GasService.sol\";\n\ncontract GasServiceTest is Test {\n    using MessageLib for *;\n\n    uint128 constant MESSAGE_GAS_LIMIT = 0.04 ether;\n    uint128 constant MAX_BATCH_SIZE = 10_000_000 ether;\n    uint16 constant CENTRIFUGE_ID = 1;\n\n    GasService service = new GasService(MAX_BATCH_SIZE, MESSAGE_GAS_LIMIT);\n\n    function testGasLimit(bytes calldata message) public view {\n        uint256 messageGasLimit = service.gasLimit(CENTRIFUGE_ID, message);\n        assertEq(messageGasLimit, MESSAGE_GAS_LIMIT);\n    }\n\n    function testMaxBatchSize(bytes calldata) public view {\n        uint256 maxBatchSize = service.maxBatchSize(CENTRIFUGE_ID);\n        assertEq(maxBatchSize, MAX_BATCH_SIZE);\n    }\n}\n"
    },
    "test/common/unit/Gateway.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {Auth, IAuth} from \"src/misc/Auth.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {Recoverable, IRecoverable} from \"src/misc/Recoverable.sol\";\n\nimport {Gateway, IRoot, IGasService, IGateway} from \"src/common/Gateway.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {TransientArrayLib} from \"src/misc/libraries/TransientArrayLib.sol\";\nimport {TransientBytesLib} from \"src/misc/libraries/TransientBytesLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\nimport {IMessageProperties} from \"src/common/interfaces/IMessageProperties.sol\";\nimport {IMessageProcessor} from \"src/common/interfaces/IMessageProcessor.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\n\n// -----------------------------------------\n//     MESSAGE MOCKING\n// -----------------------------------------\n\nPoolId constant POOL_A = PoolId.wrap(23);\nPoolId constant POOL_0 = PoolId.wrap(0);\n\nenum MessageKind {\n    _Invalid,\n    _MessageProof,\n    Recovery,\n    WithPool0,\n    WithPoolA1,\n    WithPoolA2,\n    WithPoolAFail\n}\n\nfunction length(MessageKind kind) pure returns (uint16) {\n    if (kind == MessageKind.WithPool0) return 5;\n    if (kind == MessageKind.WithPoolA1) return 10;\n    if (kind == MessageKind.WithPoolA2) return 15;\n    if (kind == MessageKind.WithPoolAFail) return 10;\n    return 2;\n}\n\nfunction asBytes(MessageKind kind) pure returns (bytes memory) {\n    bytes memory encoded = new bytes(length(kind));\n    encoded[0] = bytes1(uint8(kind));\n    return encoded;\n}\n\nusing {asBytes, length} for MessageKind;\n\n// A MessageLib agnostic processor\ncontract MockProcessor is IMessageProperties {\n    using BytesLib for bytes;\n\n    error HandleError();\n\n    mapping(uint16 => bytes[]) public processed;\n    bool shouldNotFail;\n\n    function disableFailure() public {\n        shouldNotFail = true;\n    }\n\n    function handle(uint16 centrifugeId, bytes memory payload) external {\n        if (payload.toUint8(0) == uint8(MessageKind.WithPoolAFail) && !shouldNotFail) {\n            revert HandleError();\n        }\n        processed[centrifugeId].push(payload);\n    }\n\n    function count(uint16 centrifugeId) external view returns (uint256) {\n        return processed[centrifugeId].length;\n    }\n\n    function isMessageRecovery(bytes calldata message) external pure returns (bool) {\n        return message.toUint8(0) == uint8(MessageKind.Recovery);\n    }\n\n    function messageLength(bytes calldata message) external pure returns (uint16) {\n        return MessageKind(message.toUint8(0)).length();\n    }\n\n    function messagePoolId(bytes calldata message) external pure returns (PoolId) {\n        if (message.toUint8(0) == uint8(MessageKind.WithPool0)) return POOL_0;\n        if (message.toUint8(0) == uint8(MessageKind.WithPoolA1)) return POOL_A;\n        if (message.toUint8(0) == uint8(MessageKind.WithPoolA2)) return POOL_A;\n        revert(\"Unreachable: message never asked for pool\");\n    }\n}\n\ncontract MockPoolRefund is Recoverable {\n    constructor(address authorized) Auth(authorized) {}\n    receive() external payable {}\n}\n\n// -----------------------------------------\n//     GATEWAY EXTENSION\n// -----------------------------------------\n\ncontract GatewayExt is Gateway {\n    constructor(uint16 localCentrifugeId_, IRoot root_, IGasService gasService_, address deployer)\n        Gateway(localCentrifugeId_, root_, gasService_, deployer)\n    {}\n\n    function activeAdapters(uint16 centrifugeId, IAdapter adapter) public view returns (IGateway.Adapter memory) {\n        return _activeAdapters[centrifugeId][adapter];\n    }\n\n    function batchLocatorsLength() public view returns (uint256) {\n        return TransientArrayLib.length(BATCH_LOCATORS_SLOT);\n    }\n\n    function batchGasLimit(uint16 centrifugeId, PoolId poolId) public view returns (uint128) {\n        return TransientStorageLib.tloadUint128(_gasLimitSlot(centrifugeId, poolId));\n    }\n\n    function batchLocators(uint256 index) public view returns (uint16 centrifugeId, PoolId poolId) {\n        return _parseLocator(TransientArrayLib.getBytes32(BATCH_LOCATORS_SLOT)[index]);\n    }\n\n    function outboundBatch(uint16 centrifugeId, PoolId poolId) public view returns (bytes memory) {\n        return TransientBytesLib.get(_outboundBatchSlot(centrifugeId, poolId));\n    }\n}\n\n// -----------------------------------------\n//     GATEWAY TESTS\n// -----------------------------------------\n\ncontract GatewayTest is Test {\n    uint16 constant LOCAL_CENT_ID = 23;\n    uint16 constant REMOTE_CENT_ID = 24;\n\n    uint256 constant ADAPTER_ESTIMATE_1 = 1.5 gwei;\n    uint256 constant ADAPTER_ESTIMATE_2 = 1 gwei;\n    uint256 constant ADAPTER_ESTIMATE_3 = 0.5 gwei;\n\n    bytes32 constant ADAPTER_DATA_1 = bytes32(\"data1\");\n    bytes32 constant ADAPTER_DATA_2 = bytes32(\"data2\");\n    bytes32 constant ADAPTER_DATA_3 = bytes32(\"data3\");\n\n    uint256 constant MESSAGE_GAS_LIMIT = 10.0 gwei;\n    uint256 constant MAX_BATCH_SIZE = 50.0 gwei;\n\n    bool constant ADAPTER_PAID = true;\n\n    IGasService gasService = IGasService(makeAddr(\"GasService\"));\n    IRoot root = IRoot(makeAddr(\"Root\"));\n    IAdapter batchAdapter = IAdapter(makeAddr(\"BatchAdapter\"));\n    IAdapter proofAdapter1 = IAdapter(makeAddr(\"ProofAdapter1\"));\n    IAdapter proofAdapter2 = IAdapter(makeAddr(\"ProofAdapter2\"));\n    IAdapter[] oneAdapter;\n    IAdapter[] threeAdapters;\n\n    MockProcessor processor = new MockProcessor();\n    GatewayExt gateway = new GatewayExt(LOCAL_CENT_ID, IRoot(address(root)), gasService, address(this));\n\n    address immutable ANY = makeAddr(\"ANY\");\n    address immutable TRANSIENT_REFUND = makeAddr(\"TRANSIENT_REFUND\");\n    IRecoverable immutable POOL_REFUND = new MockPoolRefund(address(gateway));\n\n    function _mockAdapter(\n        IAdapter adapter,\n        uint16 centrifugeId,\n        bytes memory message,\n        uint256 gasLimit,\n        address refund,\n        uint256 estimate,\n        bytes32 adapterData\n    ) private {\n        vm.mockCall(\n            address(adapter),\n            abi.encodeWithSelector(IAdapter.estimate.selector, centrifugeId, message, gasLimit),\n            abi.encode(gasLimit + estimate)\n        );\n\n        vm.mockCall(\n            address(adapter),\n            gasLimit + estimate,\n            abi.encodeWithSelector(IAdapter.send.selector, centrifugeId, message, gasLimit, refund),\n            abi.encode(adapterData)\n        );\n    }\n\n    function _mockAdapters(uint16 centrifugeId, bytes memory message, uint256 gasLimit, address refund) internal {\n        _mockAdapter(batchAdapter, centrifugeId, message, gasLimit, refund, ADAPTER_ESTIMATE_1, ADAPTER_DATA_1);\n\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(message));\n        _mockAdapter(proofAdapter1, centrifugeId, proof, gasLimit, refund, ADAPTER_ESTIMATE_2, ADAPTER_DATA_2);\n        _mockAdapter(proofAdapter2, centrifugeId, proof, gasLimit, refund, ADAPTER_ESTIMATE_3, ADAPTER_DATA_3);\n    }\n\n    function _mockGasService() internal {\n        vm.mockCall(\n            address(gasService), abi.encodeWithSelector(IGasService.gasLimit.selector), abi.encode(MESSAGE_GAS_LIMIT)\n        );\n        vm.mockCall(\n            address(gasService), abi.encodeWithSelector(IGasService.maxBatchSize.selector), abi.encode(MAX_BATCH_SIZE)\n        );\n    }\n\n    function _mockPause(bool isPaused) internal {\n        vm.mockCall(address(root), abi.encodeWithSelector(IRoot.paused.selector), abi.encode(isPaused));\n    }\n\n    function assertVotes(bytes memory message, uint16 r1, uint16 r2, uint16 r3) internal view {\n        uint16[8] memory votes = gateway.votes(REMOTE_CENT_ID, keccak256(message));\n        assertEq(votes[0], r1);\n        assertEq(votes[1], r2);\n        assertEq(votes[2], r3);\n    }\n\n    function setUp() public {\n        oneAdapter.push(batchAdapter);\n        threeAdapters.push(batchAdapter);\n        threeAdapters.push(proofAdapter1);\n        threeAdapters.push(proofAdapter2);\n        gateway.file(\"processor\", address(processor));\n\n        _mockPause(false);\n        _mockGasService();\n    }\n\n    function testConstructor() public view {\n        assertEq(gateway.localCentrifugeId(), LOCAL_CENT_ID);\n        assertEq(address(gateway.root()), address(root));\n        assertEq(address(gateway.gasService()), address(gasService));\n\n        (, IRecoverable refund) = gateway.subsidy(POOL_0);\n        assertEq(address(refund), address(gateway));\n\n        assertEq(gateway.wards(address(this)), 1);\n    }\n}\n\ncontract GatewayTestFile is GatewayTest {\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.file(\"unknown\", address(1));\n    }\n\n    function testErrFileUnrecognizedParam() public {\n        vm.expectRevert(IGateway.FileUnrecognizedParam.selector);\n        gateway.file(\"unknown\", address(1));\n    }\n\n    function testGatewayFile() public {\n        vm.expectEmit();\n        emit IGateway.File(\"processor\", address(23));\n        gateway.file(\"processor\", address(23));\n        assertEq(address(gateway.processor()), address(23));\n\n        gateway.file(\"gasService\", address(42));\n        assertEq(address(gateway.gasService()), address(42));\n    }\n}\n\ncontract GatewayTestFileAdapters is GatewayTest {\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.file(\"unknown\", REMOTE_CENT_ID, new IAdapter[](0));\n    }\n\n    function testErrFileUnrecognizedParam() public {\n        vm.expectRevert(IGateway.FileUnrecognizedParam.selector);\n        gateway.file(\"unknown\", REMOTE_CENT_ID, new IAdapter[](0));\n    }\n\n    function testErrEmptyAdapterFile() public {\n        vm.expectRevert(IGateway.EmptyAdapterSet.selector);\n        gateway.file(\"adapters\", REMOTE_CENT_ID, new IAdapter[](0));\n    }\n\n    function testErrExceedsMax() public {\n        IAdapter[] memory tooMuchAdapters = new IAdapter[](gateway.MAX_ADAPTER_COUNT() + 1);\n        vm.expectRevert(IGateway.ExceedsMax.selector);\n        gateway.file(\"adapters\", REMOTE_CENT_ID, tooMuchAdapters);\n    }\n\n    function testErrNoDuplicatedAllowed() public {\n        IAdapter[] memory duplicatedAdapters = new IAdapter[](2);\n        duplicatedAdapters[0] = IAdapter(address(10));\n        duplicatedAdapters[1] = IAdapter(address(10));\n\n        vm.expectRevert(IGateway.NoDuplicatesAllowed.selector);\n        gateway.file(\"adapters\", REMOTE_CENT_ID, duplicatedAdapters);\n    }\n\n    function testGatewayFileAdapters() public {\n        vm.expectEmit();\n        emit IGateway.File(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        assertEq(gateway.activeSessionId(REMOTE_CENT_ID), 0);\n        assertEq(gateway.quorum(REMOTE_CENT_ID), threeAdapters.length);\n\n        for (uint256 i; i < threeAdapters.length; i++) {\n            IGateway.Adapter memory adapter = gateway.activeAdapters(REMOTE_CENT_ID, threeAdapters[i]);\n\n            assertEq(adapter.id, i + 1);\n            assertEq(adapter.quorum, threeAdapters.length);\n            assertEq(adapter.activeSessionId, 0);\n            assertEq(address(gateway.adapters(REMOTE_CENT_ID, i)), address(threeAdapters[i]));\n        }\n    }\n\n    function testGatewayFileAdaptersAdvanceSession() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        assertEq(gateway.activeSessionId(REMOTE_CENT_ID), 0);\n\n        // Using another chain uses a different active session counter\n        gateway.file(\"adapters\", LOCAL_CENT_ID, threeAdapters);\n        assertEq(gateway.activeSessionId(LOCAL_CENT_ID), 0);\n\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        assertEq(gateway.activeSessionId(REMOTE_CENT_ID), 1);\n    }\n}\n\ncontract GatewayTestReceive is GatewayTest {\n    function testGatewayReceive() public {\n        (bool success,) = address(gateway).call{value: 100}(new bytes(0));\n\n        assertEq(success, true);\n\n        (uint96 value,) = gateway.subsidy(POOL_0);\n        assertEq(value, 100);\n\n        assertEq(address(gateway).balance, 100);\n    }\n}\n\ncontract GatewayTestHandle is GatewayTest {\n    function testErrPaused() public {\n        _mockPause(true);\n        vm.expectRevert(IGateway.Paused.selector);\n        gateway.handle(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testErrInvalidAdapter() public {\n        vm.expectRevert(IGateway.InvalidAdapter.selector);\n        gateway.handle(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testErrNonProofAdapter() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        vm.prank(address(batchAdapter));\n        vm.expectRevert(IGateway.NonProofAdapter.selector);\n        gateway.handle(REMOTE_CENT_ID, MessageProofLib.serializeMessageProof(bytes32(\"1\")));\n    }\n\n    function testErrNonProofAdapterWithOneAdapter() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        vm.prank(address(batchAdapter));\n        vm.expectRevert(IGateway.NonProofAdapter.selector);\n        gateway.handle(REMOTE_CENT_ID, MessageProofLib.serializeMessageProof(bytes32(\"1\")));\n    }\n\n    function testErrNonBatchAdapter() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        vm.prank(address(proofAdapter1));\n        vm.expectRevert(IGateway.NonBatchAdapter.selector);\n        gateway.handle(REMOTE_CENT_ID, MessageKind.WithPool0.asBytes());\n    }\n\n    function testErrEmptyMessage() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        vm.prank(address(batchAdapter));\n        vm.expectRevert(BytesLib.SliceOutOfBounds.selector);\n        gateway.handle(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testMessage() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n\n        vm.prank(address(batchAdapter));\n        vm.expectEmit();\n        emit IGateway.ExecuteMessage(REMOTE_CENT_ID, batch);\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), batch);\n    }\n\n    function testMessageFailed() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPoolAFail.asBytes();\n\n        vm.prank(address(batchAdapter));\n        vm.expectEmit();\n        emit IGateway.FailMessage(REMOTE_CENT_ID, batch, abi.encodeWithSignature(\"HandleError()\"));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertEq(gateway.failedMessages(REMOTE_CENT_ID, keccak256(batch)), 1);\n    }\n\n    function testMessageAndProofs() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n        bytes32 batchHash = keccak256(batch);\n        bytes memory proof = MessageProofLib.serializeMessageProof(batchHash);\n        bytes32 batchId = keccak256(abi.encodePacked(REMOTE_CENT_ID, LOCAL_CENT_ID, batchHash));\n        bytes32 proofId = keccak256(abi.encodePacked(REMOTE_CENT_ID, LOCAL_CENT_ID, batchHash));\n\n        vm.prank(address(batchAdapter));\n        vm.expectEmit();\n        emit IGateway.HandleBatch(REMOTE_CENT_ID, batchId, batch, batchAdapter);\n        gateway.handle(REMOTE_CENT_ID, batch);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 1, 0, 0);\n\n        vm.prank(address(proofAdapter1));\n        vm.expectEmit();\n        emit IGateway.HandleProof(REMOTE_CENT_ID, proofId, batchHash, proofAdapter1);\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 1, 1, 0);\n\n        vm.prank(address(proofAdapter2));\n        vm.expectEmit();\n        emit IGateway.HandleProof(REMOTE_CENT_ID, proofId, batchHash, proofAdapter2);\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), batch);\n        assertVotes(batch, 0, 0, 0);\n    }\n\n    function testSameMessageAndProofs() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(batch));\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch, 1, 0, 0);\n\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch, 1, 1, 0);\n\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 2);\n        assertEq(processor.processed(REMOTE_CENT_ID, 1), batch);\n        assertVotes(batch, 0, 0, 0);\n    }\n\n    function testOtherMessageAndProofs() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(batch));\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n\n        bytes memory batch2 = MessageKind.WithPoolA1.asBytes();\n        bytes memory proof2 = MessageProofLib.serializeMessageProof(keccak256(batch2));\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch2);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch2, 1, 0, 0);\n\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof2);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch2, 1, 1, 0);\n\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof2);\n        assertEq(processor.count(REMOTE_CENT_ID), 2);\n        assertEq(processor.processed(REMOTE_CENT_ID, 1), batch2);\n        assertVotes(batch2, 0, 0, 0);\n    }\n\n    function testMessageAfterProofs() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(batch));\n\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 0, 1, 0);\n\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 0, 1, 1);\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch, 0, 0, 0);\n    }\n\n    function testOneFasterAdapter() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(batch));\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 2, 0, 0);\n\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 2, 1, 0);\n\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch, 1, 0, 0);\n\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 1);\n        assertVotes(batch, 1, 1, 0);\n\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 2);\n        assertVotes(batch, 0, 0, 0);\n    }\n\n    function testVotesAfterNewSession() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory batch = MessageKind.WithPool0.asBytes();\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(batch));\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        vm.prank(address(proofAdapter1));\n        gateway.handle(REMOTE_CENT_ID, proof);\n\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        vm.prank(address(proofAdapter2));\n        gateway.handle(REMOTE_CENT_ID, proof);\n        assertEq(processor.count(REMOTE_CENT_ID), 0);\n        assertVotes(batch, 0, 0, 1);\n    }\n\n    function testBatchProcessing() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = abi.encodePacked(message1, message2);\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        assertEq(processor.count(REMOTE_CENT_ID), 2);\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), message1);\n        assertEq(processor.processed(REMOTE_CENT_ID, 1), message2);\n    }\n\n    function testBatchWithFailingMessages() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolAFail.asBytes();\n        bytes memory message3 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = abi.encodePacked(message1, message2, message3);\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        assertEq(processor.count(REMOTE_CENT_ID), 2);\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), message1);\n        assertEq(processor.processed(REMOTE_CENT_ID, 1), message3);\n\n        assertEq(gateway.failedMessages(REMOTE_CENT_ID, keccak256(message2)), 1);\n    }\n\n    function testMultipleSameFailingMessages() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPoolAFail.asBytes();\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        assertEq(gateway.failedMessages(REMOTE_CENT_ID, keccak256(batch)), 2);\n    }\n\n    function testBatchWithMultipleSameFailingMessages() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory message = MessageKind.WithPoolAFail.asBytes();\n        bytes memory batch = abi.encodePacked(message, message);\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        assertEq(gateway.failedMessages(REMOTE_CENT_ID, keccak256(message)), 2);\n    }\n}\n\ncontract GatewayTestRetry is GatewayTest {\n    function testErrPaused() public {\n        _mockPause(true);\n        vm.expectRevert(IGateway.Paused.selector);\n        gateway.retry(REMOTE_CENT_ID, bytes(\"\"));\n    }\n\n    function testErrNotFailedMessage() public {\n        vm.expectRevert(IGateway.NotFailedMessage.selector);\n        gateway.retry(REMOTE_CENT_ID, bytes(\"noMessage\"));\n    }\n\n    function testRecoverFailingMessage() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPoolAFail.asBytes();\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        processor.disableFailure();\n\n        vm.prank(ANY);\n        emit IGateway.ExecuteMessage(REMOTE_CENT_ID, batch);\n        gateway.retry(REMOTE_CENT_ID, batch);\n\n        assertEq(gateway.failedMessages(REMOTE_CENT_ID, keccak256(batch)), 0);\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), batch);\n    }\n\n    function testRecoverMultipleFailingMessage() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPoolAFail.asBytes();\n\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n        vm.prank(address(batchAdapter));\n        gateway.handle(REMOTE_CENT_ID, batch);\n\n        processor.disableFailure();\n\n        vm.prank(ANY);\n        gateway.retry(REMOTE_CENT_ID, batch);\n        vm.prank(ANY);\n        gateway.retry(REMOTE_CENT_ID, batch);\n\n        assertEq(processor.count(REMOTE_CENT_ID), 2);\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), batch);\n        assertEq(processor.processed(REMOTE_CENT_ID, 1), batch);\n        assertEq(gateway.failedMessages(REMOTE_CENT_ID, keccak256(batch)), 0);\n    }\n}\n\ncontract GatewayTestInitiateRecovery is GatewayTest {\n    bytes32 constant BATCH_HASH = bytes32(\"1\");\n\n    function testErrInvalidAdapter() public {\n        vm.expectRevert(IGateway.InvalidAdapter.selector);\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, BATCH_HASH);\n    }\n\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, BATCH_HASH);\n    }\n\n    function testInitiateRecovery() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        vm.expectEmit();\n        emit IGateway.InitiateRecovery(REMOTE_CENT_ID, BATCH_HASH, batchAdapter);\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, BATCH_HASH);\n\n        assertEq(\n            gateway.recoveries(REMOTE_CENT_ID, batchAdapter, BATCH_HASH),\n            block.timestamp + gateway.RECOVERY_CHALLENGE_PERIOD()\n        );\n    }\n}\n\ncontract GatewayTestDisputeRecovery is GatewayTest {\n    bytes32 constant BATCH_HASH = bytes32(\"1\");\n\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, BATCH_HASH);\n    }\n\n    function testDisputeRecovery() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        vm.expectEmit();\n        emit IGateway.DisputeRecovery(REMOTE_CENT_ID, BATCH_HASH, batchAdapter);\n        gateway.disputeRecovery(REMOTE_CENT_ID, batchAdapter, BATCH_HASH);\n\n        assertEq(gateway.recoveries(REMOTE_CENT_ID, batchAdapter, BATCH_HASH), 0);\n    }\n}\n\ncontract GatewayTestExecuteRecovery is GatewayTest {\n    function testErrRecoveryNotInitiated() public {\n        vm.expectRevert(IGateway.RecoveryNotInitiated.selector);\n        gateway.executeRecovery(REMOTE_CENT_ID, batchAdapter, bytes(\"\"));\n    }\n\n    function testErrRecoveryChallengePeriodNotEnded() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(batch);\n\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, batchHash);\n\n        vm.prank(ANY);\n        vm.expectRevert(IGateway.RecoveryChallengePeriodNotEnded.selector);\n        gateway.executeRecovery(REMOTE_CENT_ID, batchAdapter, batch);\n    }\n\n    function testErrRecoveryRecovered() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.Recovery.asBytes();\n        bytes32 batchHash = keccak256(batch);\n\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, batchHash);\n\n        vm.warp(gateway.RECOVERY_CHALLENGE_PERIOD() + 1);\n\n        vm.prank(ANY);\n        vm.expectRevert(IGateway.RecoveryPayloadRecovered.selector);\n        gateway.executeRecovery(REMOTE_CENT_ID, batchAdapter, batch);\n    }\n\n    function testExecuteRecovery() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, oneAdapter);\n\n        bytes memory batch = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(batch);\n\n        gateway.initiateRecovery(REMOTE_CENT_ID, batchAdapter, batchHash);\n\n        vm.warp(gateway.RECOVERY_CHALLENGE_PERIOD() + 1);\n\n        vm.prank(ANY);\n        emit IGateway.ExecuteRecovery(REMOTE_CENT_ID, batch, batchAdapter);\n        gateway.executeRecovery(REMOTE_CENT_ID, batchAdapter, batch);\n\n        assertEq(processor.processed(REMOTE_CENT_ID, 0), batch);\n    }\n}\n\ncontract GatewayTestSetRefundAddress is GatewayTest {\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n    }\n\n    function testSetRefundAddress() public {\n        vm.expectEmit();\n        emit IGateway.SetRefundAddress(POOL_A, POOL_REFUND);\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n\n        (, IRecoverable refund) = gateway.subsidy(POOL_A);\n        assertEq(address(refund), address(POOL_REFUND));\n    }\n}\n\ncontract GatewayTestSetSubsidizePool is GatewayTest {\n    function testErrRefundAddressNotSet() public {\n        vm.deal(ANY, 100);\n        vm.prank(ANY);\n        vm.expectRevert(IGateway.RefundAddressNotSet.selector);\n        gateway.subsidizePool{value: 100}(POOL_A);\n    }\n\n    function testSetSubsidizePool() public {\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n\n        vm.deal(ANY, 100);\n        vm.prank(ANY);\n        vm.expectEmit();\n        emit IGateway.SubsidizePool(POOL_A, ANY, 100);\n        gateway.subsidizePool{value: 100}(POOL_A);\n\n        (uint96 value,) = gateway.subsidy(POOL_A);\n        assertEq(value, 100);\n    }\n}\n\ncontract GatewayTestPayTransaction is GatewayTest {\n    function testErrNotAuthorized() public {\n        vm.deal(ANY, 100);\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.payTransaction{value: 100}(TRANSIENT_REFUND);\n    }\n\n    function testPayTransaction() public {\n        gateway.payTransaction{value: 100}(TRANSIENT_REFUND);\n\n        assertEq(gateway.transactionRefund(), TRANSIENT_REFUND);\n        assertEq(gateway.fuel(), 100);\n    }\n\n    /// forge-config: default.isolate = true\n    function testPayTransactionIsTransactional() public {\n        gateway.payTransaction{value: 100}(TRANSIENT_REFUND);\n\n        assertEq(gateway.transactionRefund(), address(0));\n        assertEq(gateway.fuel(), 0);\n    }\n}\n\ncontract GatewayTestStartBatching is GatewayTest {\n    function testStartBatching() public {\n        gateway.startBatching();\n\n        assertEq(gateway.isBatching(), true);\n    }\n\n    /// forge-config: default.isolate = true\n    function testStartBatchingIsTransactional() public {\n        gateway.startBatching();\n\n        assertEq(gateway.isBatching(), false);\n    }\n}\n\ncontract GatewayTestSend is GatewayTest {\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.send(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testErrPaused() public {\n        _mockPause(true);\n        vm.expectRevert(IGateway.Paused.selector);\n        gateway.send(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testErrEmptyMessage() public {\n        vm.expectRevert(IGateway.EmptyMessage.selector);\n        gateway.send(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testErrEmptyAdapterSet() public {\n        vm.expectRevert(IGateway.EmptyAdapterSet.selector);\n        gateway.send(REMOTE_CENT_ID, MessageKind.WithPoolA1.asBytes());\n    }\n\n    function testErrExceedsMaxBatching() public {\n        gateway.startBatching();\n        uint256 maxMessages = MAX_BATCH_SIZE / MESSAGE_GAS_LIMIT;\n\n        for (uint256 i; i < maxMessages; i++) {\n            gateway.send(REMOTE_CENT_ID, MessageKind.WithPoolA1.asBytes());\n        }\n\n        vm.expectRevert(IGateway.ExceedsMaxBatchSize.selector);\n        gateway.send(REMOTE_CENT_ID, MessageKind.WithPoolA1.asBytes());\n    }\n\n    function testErrNotEnoughTransactionGas() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3 - 1;\n        gateway.payTransaction{value: payment}(TRANSIENT_REFUND);\n\n        _mockAdapters(REMOTE_CENT_ID, message, MESSAGE_GAS_LIMIT, TRANSIENT_REFUND);\n\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        gateway.send(REMOTE_CENT_ID, message);\n    }\n\n    function testMessageWasBatched() public {\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n\n        gateway.startBatching();\n\n        vm.expectEmit();\n        emit IGateway.PrepareMessage(REMOTE_CENT_ID, POOL_A, message);\n        gateway.send(REMOTE_CENT_ID, message);\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), MESSAGE_GAS_LIMIT);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), message);\n        assertEq(gateway.batchLocatorsLength(), 1);\n\n        (uint16 centrifugeId, PoolId poolId) = gateway.batchLocators(0);\n        assertEq(centrifugeId, REMOTE_CENT_ID);\n        assertEq(poolId.raw(), POOL_A.raw());\n    }\n\n    function testSecondMessageWasBatchedSamePoolSameChain() public {\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), MESSAGE_GAS_LIMIT * 2);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), abi.encodePacked(message1, message2));\n        assertEq(gateway.batchLocatorsLength(), 1);\n    }\n\n    function testSecondMessageWasBatchedSamePoolDifferentChain() public {\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID + 1, message2);\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), MESSAGE_GAS_LIMIT);\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID + 1, POOL_A), MESSAGE_GAS_LIMIT);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), message1);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID + 1, POOL_A), message2);\n        assertEq(gateway.batchLocatorsLength(), 2);\n    }\n\n    function testSecondMessageWasBatchedDifferentPoolSameChain() public {\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPool0.asBytes();\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), MESSAGE_GAS_LIMIT);\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_0), MESSAGE_GAS_LIMIT);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), message1);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_0), message2);\n        assertEq(gateway.batchLocatorsLength(), 2);\n    }\n\n    function testSendMessageUnderpaid() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(message);\n\n        _mockAdapters(REMOTE_CENT_ID, message, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        vm.expectEmit();\n        emit IGateway.PrepareMessage(REMOTE_CENT_ID, POOL_A, message);\n        vm.expectEmit();\n        emit IGateway.UnderpaidBatch(REMOTE_CENT_ID, message);\n        gateway.send(REMOTE_CENT_ID, message);\n\n        (uint128 counter, uint128 gasLimit) = gateway.underpaid(REMOTE_CENT_ID, batchHash);\n        assertEq(counter, 1);\n        assertEq(gasLimit, MESSAGE_GAS_LIMIT);\n    }\n\n    function testSendMessageUnderpaidTwice() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(message);\n\n        _mockAdapters(REMOTE_CENT_ID, message, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        gateway.send(REMOTE_CENT_ID, message);\n        gateway.send(REMOTE_CENT_ID, message);\n\n        (uint128 counter, uint128 gasLimit) = gateway.underpaid(REMOTE_CENT_ID, batchHash);\n        assertEq(counter, 2);\n        assertEq(gasLimit, MESSAGE_GAS_LIMIT);\n    }\n\n    function testSendMessageUsingSubsidizedPoolPayment() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(message);\n        bytes32 batchId = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash));\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3 + 1234;\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.subsidizePool{value: payment}(POOL_A);\n\n        _mockAdapters(REMOTE_CENT_ID, message, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        vm.expectEmit();\n        emit IGateway.PrepareMessage(REMOTE_CENT_ID, POOL_A, message);\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId, message, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND));\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter2, ADAPTER_DATA_3);\n        gateway.send(REMOTE_CENT_ID, message);\n\n        (uint256 value,) = gateway.subsidy(POOL_A);\n        assertEq(value, 1234);\n    }\n\n    function testSendMessageUsingSubsidizedPoolPaymentAndPoolRefunding() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n\n        /// Not enough payment\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3 - 1;\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.subsidizePool{value: payment}(POOL_A);\n\n        // The refund system will take this amount to perform the required payment\n        vm.deal(address(POOL_REFUND), 1);\n\n        _mockAdapters(REMOTE_CENT_ID, message, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        vm.expectEmit();\n        emit IGateway.SubsidizePool(POOL_A, address(POOL_REFUND), 1);\n        gateway.send(REMOTE_CENT_ID, message);\n\n        (uint256 value,) = gateway.subsidy(POOL_A);\n        assertEq(value, 0);\n    }\n\n    function testSendMessageUsingTransactionPayment() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(message);\n        bytes32 batchId = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash));\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3 + 1234;\n        gateway.payTransaction{value: payment}(TRANSIENT_REFUND);\n\n        _mockAdapters(REMOTE_CENT_ID, message, MESSAGE_GAS_LIMIT, TRANSIENT_REFUND);\n\n        vm.expectEmit();\n        emit IGateway.PrepareMessage(REMOTE_CENT_ID, POOL_A, message);\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId, message, batchAdapter, ADAPTER_DATA_1, TRANSIENT_REFUND);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter2, ADAPTER_DATA_3);\n        gateway.send(REMOTE_CENT_ID, message);\n\n        assertEq(TRANSIENT_REFUND.balance, 1234);\n        assertEq(gateway.fuel(), 0);\n        assertEq(gateway.transactionRefund(), address(0));\n    }\n}\n\ncontract GatewayTestEndBatching is GatewayTest {\n    function testErrNotAuthorized() public {\n        vm.prank(ANY);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        gateway.endBatching();\n    }\n\n    function testErrNoBatched() public {\n        vm.expectRevert(IGateway.NoBatched.selector);\n        gateway.endBatching();\n    }\n\n    function testSendTwoMessageBatching() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = bytes.concat(message1, message2);\n        bytes32 batchHash = keccak256(batch);\n        bytes32 batchId = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash));\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 * 2 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3;\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.subsidizePool{value: payment}(POOL_A);\n\n        _mockAdapters(REMOTE_CENT_ID, message1, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT * 2, address(POOL_REFUND));\n\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId, batch, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND));\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter2, ADAPTER_DATA_3);\n        gateway.endBatching();\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), 0);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), new bytes(0));\n        assertEq(gateway.batchLocatorsLength(), 0);\n        assertEq(gateway.isBatching(), false);\n    }\n\n    function testSendTwoMessageBatchingDifferentChainSamePool() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        gateway.file(\"adapters\", REMOTE_CENT_ID + 1, threeAdapters);\n\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes32 batchHash1 = keccak256(message1);\n        bytes32 batchHash2 = keccak256(message2);\n        bytes32 batchId1 = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash1));\n        bytes32 batchId2 = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID + 1, batchHash2));\n\n        uint256 payment =\n            MESSAGE_GAS_LIMIT * 3 * 2 + ADAPTER_ESTIMATE_1 * 2 + ADAPTER_ESTIMATE_2 * 2 + ADAPTER_ESTIMATE_3 * 2;\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.subsidizePool{value: payment}(POOL_A);\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID + 1, message2);\n\n        _mockAdapters(REMOTE_CENT_ID, message1, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n        _mockAdapters(REMOTE_CENT_ID + 1, message2, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId1, message1, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND));\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId1, batchHash1, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId1, batchHash1, proofAdapter2, ADAPTER_DATA_3);\n        vm.expectEmit();\n        emit IGateway.SendBatch(\n            REMOTE_CENT_ID + 1, batchId2, message2, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND)\n        );\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID + 1, batchId2, batchHash2, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID + 1, batchId2, batchHash2, proofAdapter2, ADAPTER_DATA_3);\n        gateway.endBatching();\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), 0);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), new bytes(0));\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID + 1, POOL_A), 0);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID + 1, POOL_A), new bytes(0));\n        assertEq(gateway.batchLocatorsLength(), 0);\n        assertEq(gateway.isBatching(), false);\n    }\n\n    function testSendTwoMessageBatchingSameChainDifferentPool() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message1 = MessageKind.WithPool0.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash1 = keccak256(message1);\n        bytes32 batchHash2 = keccak256(message2);\n        bytes32 batchId1 = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash1));\n        bytes32 batchId2 = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash2));\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3;\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.setRefundAddress(POOL_0, POOL_REFUND);\n        gateway.subsidizePool{value: payment}(POOL_A);\n        gateway.subsidizePool{value: payment}(POOL_0);\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        _mockAdapters(REMOTE_CENT_ID, message1, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n        _mockAdapters(REMOTE_CENT_ID, message2, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId1, message1, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND));\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId1, batchHash1, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId1, batchHash1, proofAdapter2, ADAPTER_DATA_3);\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId2, message2, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND));\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId2, batchHash2, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId2, batchHash2, proofAdapter2, ADAPTER_DATA_3);\n        gateway.endBatching();\n\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_A), 0);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_A), new bytes(0));\n        assertEq(gateway.batchGasLimit(REMOTE_CENT_ID, POOL_0), 0);\n        assertEq(gateway.outboundBatch(REMOTE_CENT_ID, POOL_0), new bytes(0));\n        assertEq(gateway.batchLocatorsLength(), 0);\n        assertEq(gateway.isBatching(), false);\n    }\n\n    function testSendTwoMessageBatchingUsingTransactionPayment() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = bytes.concat(message1, message2);\n\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        uint256 payment =\n            MESSAGE_GAS_LIMIT * 2 * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3 + 1234;\n        gateway.payTransaction{value: payment}(TRANSIENT_REFUND);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT * 2, TRANSIENT_REFUND);\n\n        gateway.endBatching();\n\n        assertEq(TRANSIENT_REFUND.balance, 1234);\n        assertEq(gateway.fuel(), 0);\n        assertEq(gateway.transactionRefund(), address(0));\n    }\n\n    function testSendMessageUnderpaid() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = bytes.concat(message1, message2);\n        bytes32 batchHash = keccak256(batch);\n\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT * 2, address(POOL_REFUND));\n        gateway.endBatching();\n\n        (uint128 counter, uint128 gasLimit) = gateway.underpaid(REMOTE_CENT_ID, batchHash);\n        assertEq(counter, 1);\n        assertEq(gasLimit, MESSAGE_GAS_LIMIT * 2);\n    }\n}\n\ncontract GatewayTestRepay is GatewayTest {\n    function testErrPaused() public {\n        _mockPause(true);\n        vm.expectRevert(IGateway.Paused.selector);\n        gateway.repay(REMOTE_CENT_ID, new bytes(0));\n    }\n\n    function testErrNotUnderpaidBatch() public {\n        bytes memory batch = MessageKind.WithPoolA1.asBytes();\n\n        vm.expectRevert(IGateway.NotUnderpaidBatch.selector);\n        gateway.repay(REMOTE_CENT_ID, batch);\n    }\n\n    function testErrInsufficientFundsForRepayment() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        bytes memory batch = MessageKind.WithPoolA1.asBytes();\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n        gateway.send(REMOTE_CENT_ID, batch);\n\n        vm.expectRevert(IGateway.InsufficientFundsForRepayment.selector);\n        gateway.repay(REMOTE_CENT_ID, batch);\n    }\n\n    function testCorrectRepay() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        bytes memory batch = MessageKind.WithPoolA1.asBytes();\n        bytes32 batchHash = keccak256(batch);\n        bytes32 batchId = keccak256(abi.encodePacked(LOCAL_CENT_ID, REMOTE_CENT_ID, batchHash));\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT, address(POOL_REFUND));\n        gateway.send(REMOTE_CENT_ID, batch);\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3;\n        vm.expectEmit();\n        emit IGateway.SendBatch(REMOTE_CENT_ID, batchId, batch, batchAdapter, ADAPTER_DATA_1, address(POOL_REFUND));\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter1, ADAPTER_DATA_2);\n        vm.expectEmit();\n        emit IGateway.SendProof(REMOTE_CENT_ID, batchId, batchHash, proofAdapter2, ADAPTER_DATA_3);\n        vm.expectEmit();\n        emit IGateway.RepayBatch(REMOTE_CENT_ID, batch);\n        gateway.repay{value: payment}(REMOTE_CENT_ID, batch);\n    }\n\n    function testErrInsufficientFundsForRepaymentWithBatches() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = bytes.concat(message1, message2);\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT * 2, address(POOL_REFUND));\n        gateway.endBatching();\n\n        // Expected: MESSAGE_GAS_LIMIT * 2 * 3 + ...\n        uint256 payment = MESSAGE_GAS_LIMIT * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3;\n        vm.expectRevert(IGateway.InsufficientFundsForRepayment.selector);\n        gateway.repay{value: payment}(REMOTE_CENT_ID, batch);\n    }\n\n    function testCorrectRepayForBatches() public {\n        gateway.file(\"adapters\", REMOTE_CENT_ID, threeAdapters);\n        bytes memory message1 = MessageKind.WithPoolA1.asBytes();\n        bytes memory message2 = MessageKind.WithPoolA2.asBytes();\n        bytes memory batch = bytes.concat(message1, message2);\n        gateway.setRefundAddress(POOL_A, POOL_REFUND);\n        gateway.startBatching();\n        gateway.send(REMOTE_CENT_ID, message1);\n        gateway.send(REMOTE_CENT_ID, message2);\n\n        _mockAdapters(REMOTE_CENT_ID, batch, MESSAGE_GAS_LIMIT * 2, address(POOL_REFUND));\n        gateway.endBatching();\n\n        uint256 payment = MESSAGE_GAS_LIMIT * 2 * 3 + ADAPTER_ESTIMATE_1 + ADAPTER_ESTIMATE_2 + ADAPTER_ESTIMATE_3;\n\n        vm.expectEmit();\n        emit IGateway.RepayBatch(REMOTE_CENT_ID, batch);\n        gateway.repay{value: payment}(REMOTE_CENT_ID, batch);\n    }\n}\n"
    },
    "test/common/unit/Guardian.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Guardian, ISafe, IRoot, IRootMessageSender} from \"src/common/Guardian.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract GuardianTest is Test {\n    ISafe immutable adminSafe = ISafe(makeAddr(\"adminSafe\"));\n    IRoot immutable root = IRoot(makeAddr(\"root\"));\n    IRootMessageSender messageDispatcher = IRootMessageSender(makeAddr(\"messageDispatcher\"));\n\n    function testGuardian() public {\n        Guardian guardian = new Guardian(adminSafe, root, messageDispatcher);\n        assertEq(address(guardian.safe()), address(adminSafe));\n        assertEq(address(guardian.root()), address(root));\n        assertEq(address(guardian.sender()), address(messageDispatcher));\n    }\n}\n"
    },
    "test/common/unit/TokenRecoverer.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth, IAuth} from \"src/misc/Auth.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {TokenRecoverer, ITokenRecoverer} from \"src/common/TokenRecoverer.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract TestTokenRecoverer is Test {\n    uint256 constant AMOUNT = 100;\n    uint256 constant TOKEN_ID = 23;\n    address immutable TOKEN = makeAddr(\"erc20\");\n    address immutable RECEIVER = makeAddr(\"receiver\");\n    IRoot immutable ROOT = IRoot(makeAddr(\"root\"));\n    IRecoverable immutable RECOVERABLE = IRecoverable(makeAddr(\"recoverable\"));\n\n    TokenRecoverer tokenRecoverer = new TokenRecoverer(ROOT, address(this));\n\n    function testErrNotAuthorized() public {\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        tokenRecoverer.recoverTokens(RECOVERABLE, address(0), 0, address(0), 0);\n    }\n\n    function testSuccess() public {\n        // We need to compute the selector directly to avoid collition\n        bytes4 recoverTokensSelector = bytes4(keccak256(\"recoverTokens(address,uint256,address,uint256)\"));\n\n        vm.mockCall(\n            address(ROOT),\n            abi.encodeWithSelector(IRoot.relyContract.selector, RECOVERABLE, address(tokenRecoverer)),\n            abi.encode(0)\n        );\n        vm.mockCall(\n            address(RECOVERABLE),\n            abi.encodeWithSelector(recoverTokensSelector, TOKEN, TOKEN_ID, RECEIVER, AMOUNT),\n            abi.encode(0)\n        );\n        vm.mockCall(\n            address(ROOT),\n            abi.encodeWithSelector(IRoot.denyContract.selector, RECOVERABLE, address(tokenRecoverer)),\n            abi.encode(0)\n        );\n\n        emit ITokenRecoverer.RecoverTokens(RECOVERABLE, TOKEN, TOKEN_ID, RECEIVER, AMOUNT);\n        tokenRecoverer.recoverTokens(RECOVERABLE, TOKEN, TOKEN_ID, RECEIVER, AMOUNT);\n    }\n}\n"
    },
    "test/common/unit/WormholeAdapter.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {Mock} from \"test/common/mocks/Mock.sol\";\n\nimport {WormholeAdapter} from \"src/common/adapters/WormholeAdapter.sol\";\nimport {IWormholeAdapter} from \"src/common/interfaces/IWormholeAdapter.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\ncontract MockWormholeDeliveryProvider {\n    uint16 public immutable chainId = 2;\n}\n\ncontract MockWormholeRelayer is Mock {\n    address public getDefaultDeliveryProvider = address(new MockWormholeDeliveryProvider());\n\n    function sendPayloadToEvm(\n        uint16 targetChain,\n        address targetAddress,\n        bytes memory payload,\n        uint256 receiverValue,\n        uint256 gasLimit,\n        uint16 refundChain,\n        address refundAddress\n    ) external payable returns (uint64 sequence) {\n        values_uint256[\"value\"] = msg.value;\n        values_uint16[\"targetChain\"] = targetChain;\n        values_address[\"targetAddress\"] = targetAddress;\n        values_bytes[\"payload\"] = payload;\n        values_uint256[\"receiverValue\"] = receiverValue;\n        values_uint256[\"gasLimit\"] = gasLimit;\n        values_uint16[\"refundChain\"] = refundChain;\n        values_address[\"refundAddress\"] = refundAddress;\n\n        return 0;\n    }\n\n    function quoteEVMDeliveryPrice(uint16, uint256, uint256 gasLimit)\n        external\n        pure\n        returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused)\n    {\n        nativePriceQuote = gasLimit * 2;\n        targetChainRefundPerGasUnused = 0;\n    }\n}\n\ncontract WormholeAdapterTest is Test {\n    using CastLib for *;\n\n    MockWormholeRelayer relayer;\n    WormholeAdapter adapter;\n\n    uint16 constant CENTRIFUGE_CHAIN_ID = 1;\n    uint16 constant WORMHOLE_CHAIN_ID = 2;\n    IMessageHandler constant GATEWAY = IMessageHandler(address(1));\n\n    function setUp() public {\n        relayer = new MockWormholeRelayer();\n        adapter = new WormholeAdapter(GATEWAY, address(relayer), address(this));\n    }\n\n    function testDeploy() public view {\n        assertEq(address(adapter.gateway()), address(GATEWAY));\n        assertEq(address(adapter.relayer()), address(relayer));\n        assertEq(adapter.localWormholeId(), 2);\n\n        assertEq(adapter.wards(address(this)), 1);\n    }\n\n    function testEstimate(uint64 gasLimit) public view {\n        bytes memory payload = \"irrelevant\";\n        assertEq(adapter.estimate(CENTRIFUGE_CHAIN_ID, payload, gasLimit), uint128(gasLimit) * 2);\n    }\n\n    function testFiling(address validAddress) public {\n        adapter.file(\"sources\", CENTRIFUGE_CHAIN_ID, WORMHOLE_CHAIN_ID, validAddress);\n        adapter.file(\"destinations\", CENTRIFUGE_CHAIN_ID, WORMHOLE_CHAIN_ID, makeAddr(\"DestinationAdapter\"));\n\n        vm.expectRevert(IWormholeAdapter.FileUnrecognizedParam.selector);\n        adapter.file(\"random\", CENTRIFUGE_CHAIN_ID, WORMHOLE_CHAIN_ID, makeAddr(\"DestinationAdapter\"));\n\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        adapter.file(\"destinations\", CENTRIFUGE_CHAIN_ID, WORMHOLE_CHAIN_ID, makeAddr(\"DestinationAdapter\"));\n    }\n\n    function testIncomingCalls(\n        bytes memory payload,\n        address validAddress,\n        address invalidAddress,\n        uint16 invalidChain,\n        address invalidOrigin\n    ) public {\n        vm.assume(keccak256(abi.encodePacked(invalidAddress)) != keccak256(abi.encodePacked(validAddress)));\n        vm.assume(invalidChain != WORMHOLE_CHAIN_ID);\n        vm.assume(invalidOrigin != address(relayer));\n        assumeNotZeroAddress(validAddress);\n        assumeNotZeroAddress(invalidAddress);\n\n        bytes[] memory vaas;\n\n        vm.mockCall(\n            address(GATEWAY),\n            abi.encodeWithSelector(GATEWAY.handle.selector, CENTRIFUGE_CHAIN_ID, payload),\n            abi.encode()\n        );\n\n        // Correct input, but not yet setup\n        vm.prank(address(relayer));\n        vm.expectRevert(IWormholeAdapter.InvalidSource.selector);\n        adapter.receiveWormholeMessages(\n            payload, vaas, validAddress.toBytes32LeftPadded(), WORMHOLE_CHAIN_ID, bytes32(0)\n        );\n\n        adapter.file(\"sources\", CENTRIFUGE_CHAIN_ID, WORMHOLE_CHAIN_ID, validAddress);\n\n        // Incorrect address\n        vm.prank(address(relayer));\n        vm.expectRevert(IWormholeAdapter.InvalidSource.selector);\n        adapter.receiveWormholeMessages(\n            payload, vaas, invalidAddress.toBytes32LeftPadded(), WORMHOLE_CHAIN_ID, bytes32(0)\n        );\n\n        // address(0) from invalid chain should fail\n        vm.prank(address(relayer));\n        vm.expectRevert(IWormholeAdapter.InvalidSource.selector);\n        adapter.receiveWormholeMessages(payload, vaas, address(0).toBytes32LeftPadded(), invalidChain, bytes32(0));\n\n        // Incorrect chain\n        vm.expectRevert(IWormholeAdapter.NotWormholeRelayer.selector);\n        adapter.receiveWormholeMessages(\n            payload, vaas, validAddress.toBytes32LeftPadded(), WORMHOLE_CHAIN_ID, bytes32(0)\n        );\n\n        // Correct\n        vm.prank(address(relayer));\n        adapter.receiveWormholeMessages(\n            payload, vaas, validAddress.toBytes32LeftPadded(), WORMHOLE_CHAIN_ID, bytes32(0)\n        );\n    }\n\n    function testOutgoingCalls(bytes calldata payload, address invalidOrigin, uint256 gasLimit, address refund)\n        public\n    {\n        vm.assume(invalidOrigin != address(GATEWAY));\n\n        vm.deal(address(this), 0.1 ether);\n        vm.expectRevert(IAdapter.NotGateway.selector);\n        adapter.send{value: 0.1 ether}(CENTRIFUGE_CHAIN_ID, payload, gasLimit, refund);\n\n        vm.deal(address(GATEWAY), 0.1 ether);\n        vm.prank(address(GATEWAY));\n        vm.expectRevert(IAdapter.UnknownChainId.selector);\n        adapter.send{value: 0.1 ether}(CENTRIFUGE_CHAIN_ID, payload, gasLimit, refund);\n\n        adapter.file(\"destinations\", CENTRIFUGE_CHAIN_ID, WORMHOLE_CHAIN_ID, makeAddr(\"DestinationAdapter\"));\n\n        vm.deal(address(this), 0.1 ether);\n        vm.prank(address(GATEWAY));\n        adapter.send{value: 0.1 ether}(CENTRIFUGE_CHAIN_ID, payload, gasLimit, refund);\n\n        assertEq(relayer.values_uint256(\"value\"), 0.1 ether);\n        assertEq(relayer.values_uint16(\"targetChain\"), WORMHOLE_CHAIN_ID);\n        assertEq(relayer.values_address(\"targetAddress\"), makeAddr(\"DestinationAdapter\"));\n        assertEq(relayer.values_bytes(\"payload\"), payload);\n        assertEq(relayer.values_uint256(\"receiverValue\"), 0);\n        assertEq(relayer.values_uint256(\"gasLimit\"), gasLimit);\n        assertEq(relayer.values_uint16(\"refundChain\"), WORMHOLE_CHAIN_ID);\n        assertEq(relayer.values_address(\"refundAddress\"), refund);\n    }\n}\n"
    },
    "test/common/unit/libraries/MessageLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MessageType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract TestMessageProofCompatibility is Test {\n    function testMessageProofCompatibility() public pure {\n        assertEq(uint8(MessageType._MessageProof), MessageProofLib.MESSAGE_PROOF_ID);\n    }\n}\n\n// The following tests check that the function composition of deserializing and serializing equals to the identity:\n//       I = deserialize Âº serialize\n// NOTE. To fully ensure a good testing, use different values for each field.\ncontract TestMessageLibIdentities is Test {\n    using MessageLib for *;\n\n    function testInitiateRecovery(bytes32 hash_, bytes32 adapter, uint16 centrifugeId) public pure {\n        MessageLib.InitiateRecovery memory a =\n            MessageLib.InitiateRecovery({hash: hash_, adapter: adapter, centrifugeId: centrifugeId});\n        MessageLib.InitiateRecovery memory b = MessageLib.deserializeInitiateRecovery(a.serialize());\n\n        assertEq(a.hash, b.hash);\n        assertEq(a.adapter, b.adapter);\n        assertEq(a.centrifugeId, b.centrifugeId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n    }\n\n    function testDisputeRecovery(bytes32 hash_, bytes32 adapter, uint16 centrifugeId) public pure {\n        MessageLib.DisputeRecovery memory a =\n            MessageLib.DisputeRecovery({hash: hash_, adapter: adapter, centrifugeId: centrifugeId});\n        MessageLib.DisputeRecovery memory b = MessageLib.deserializeDisputeRecovery(a.serialize());\n\n        assertEq(a.hash, b.hash);\n        assertEq(a.adapter, b.adapter);\n        assertEq(a.centrifugeId, b.centrifugeId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n    }\n\n    function testScheduleUpgrade(bytes32 target) public pure {\n        MessageLib.ScheduleUpgrade memory a = MessageLib.ScheduleUpgrade({target: target});\n        MessageLib.ScheduleUpgrade memory b = MessageLib.deserializeScheduleUpgrade(a.serialize());\n\n        assertEq(a.target, b.target);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n    }\n\n    function testCancelUpgrade(bytes32 target) public pure {\n        MessageLib.CancelUpgrade memory a = MessageLib.CancelUpgrade({target: target});\n        MessageLib.CancelUpgrade memory b = MessageLib.deserializeCancelUpgrade(a.serialize());\n\n        assertEq(a.target, b.target);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n    }\n\n    function testRecoverTokens(bytes32 target, bytes32 token, uint256 tokenId, bytes32 to, uint256 amount)\n        public\n        pure\n    {\n        MessageLib.RecoverTokens memory a =\n            MessageLib.RecoverTokens({target: target, token: token, tokenId: tokenId, to: to, amount: amount});\n        MessageLib.RecoverTokens memory b = MessageLib.deserializeRecoverTokens(a.serialize());\n\n        assertEq(a.target, b.target);\n        assertEq(a.token, b.token);\n        assertEq(a.tokenId, b.tokenId);\n        assertEq(a.to, b.to);\n        assertEq(a.amount, b.amount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length, \"XXX\");\n    }\n\n    function testRegisterAsset(uint128 assetId, uint8 decimals) public pure {\n        MessageLib.RegisterAsset memory a = MessageLib.RegisterAsset({assetId: assetId, decimals: decimals});\n        MessageLib.RegisterAsset memory b = MessageLib.deserializeRegisterAsset(a.serialize());\n\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.decimals, b.decimals);\n\n        assertEq(bytes(a.serialize()).length, a.serialize().messageLength());\n    }\n\n    function testNotifyPool(uint64 poolId) public pure {\n        MessageLib.NotifyPool memory a = MessageLib.NotifyPool({poolId: poolId});\n        MessageLib.NotifyPool memory b = MessageLib.deserializeNotifyPool(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testNotifyShareClass(\n        uint64 poolId,\n        bytes16 scId,\n        string calldata name,\n        bytes32 symbol,\n        uint8 decimals,\n        bytes32 salt,\n        bytes32 hook\n    ) public pure {\n        MessageLib.NotifyShareClass memory a = MessageLib.NotifyShareClass({\n            poolId: poolId,\n            scId: scId,\n            name: name,\n            symbol: symbol,\n            decimals: decimals,\n            salt: salt,\n            hook: hook\n        });\n        MessageLib.NotifyShareClass memory b = MessageLib.deserializeNotifyShareClass(a.serialize());\n\n        string calldata slicedName = bytes(name).length > 128 ? name[0:128] : name;\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(slicedName, b.name);\n        assertEq(a.symbol, b.symbol);\n        assertEq(a.decimals, b.decimals);\n        assertEq(a.salt, b.salt);\n        assertEq(a.hook, b.hook);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testNotifyPricePoolPerShare(uint64 poolId, bytes16 scId, uint128 price, uint64 timestamp) public pure {\n        MessageLib.NotifyPricePoolPerShare memory a =\n            MessageLib.NotifyPricePoolPerShare({poolId: poolId, scId: scId, price: price, timestamp: timestamp});\n        MessageLib.NotifyPricePoolPerShare memory b = MessageLib.deserializeNotifyPricePoolPerShare(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.price, b.price);\n        assertEq(a.timestamp, b.timestamp);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n    }\n\n    function testNotifyPricePoolPerAsset(uint64 poolId, bytes16 scId, uint128 assetId, uint128 price, uint64 timestamp)\n        public\n        pure\n    {\n        MessageLib.NotifyPricePoolPerAsset memory a = MessageLib.NotifyPricePoolPerAsset({\n            poolId: poolId,\n            scId: scId,\n            assetId: assetId,\n            price: price,\n            timestamp: timestamp\n        });\n        MessageLib.NotifyPricePoolPerAsset memory b = MessageLib.deserializeNotifyPricePoolPerAsset(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.price, b.price);\n        assertEq(a.timestamp, b.timestamp);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testNotifyShareMetadata(uint64 poolId, bytes16 scId, string calldata name, bytes32 symbol) public pure {\n        MessageLib.NotifyShareMetadata memory a =\n            MessageLib.NotifyShareMetadata({poolId: poolId, scId: scId, name: name, symbol: symbol});\n        MessageLib.NotifyShareMetadata memory b = MessageLib.deserializeNotifyShareMetadata(a.serialize());\n\n        string calldata slicedName = bytes(name).length > 128 ? name[0:128] : name;\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(slicedName, b.name);\n        assertEq(a.symbol, b.symbol);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testUpdateShareHook(uint64 poolId, bytes16 scId, bytes32 hook) public pure {\n        MessageLib.UpdateShareHook memory a = MessageLib.UpdateShareHook({poolId: poolId, scId: scId, hook: hook});\n        MessageLib.UpdateShareHook memory b = MessageLib.deserializeUpdateShareHook(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.hook, b.hook);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testTransferShares(uint64 poolId, bytes16 scId, bytes32 receiver, uint128 amount) public pure {\n        MessageLib.TransferShares memory a =\n            MessageLib.TransferShares({poolId: poolId, scId: scId, receiver: receiver, amount: amount});\n        MessageLib.TransferShares memory b = MessageLib.deserializeTransferShares(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.receiver, b.receiver);\n        assertEq(a.amount, b.amount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testUpdateRestriction(uint64 poolId, bytes16 scId, bytes memory payload) public pure {\n        MessageLib.UpdateRestriction memory a =\n            MessageLib.UpdateRestriction({poolId: poolId, scId: scId, payload: payload});\n        MessageLib.UpdateRestriction memory b = MessageLib.deserializeUpdateRestriction(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.payload, b.payload);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n\n        // Check the payload length is correctly encoded as little endian\n        assertEq(a.payload.length, uint8(a.serialize()[a.serialize().messageLength() - a.payload.length - 1]));\n    }\n\n    function testUpdateRestrictionMember(bytes32 user, uint64 validUntil) public pure {\n        MessageLib.UpdateRestrictionMember memory aa =\n            MessageLib.UpdateRestrictionMember({user: user, validUntil: validUntil});\n        MessageLib.UpdateRestrictionMember memory bb = MessageLib.deserializeUpdateRestrictionMember(aa.serialize());\n\n        assertEq(aa.user, bb.user);\n        assertEq(aa.validUntil, bb.validUntil);\n\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateRestrictionFreeze(bytes32 user) public pure {\n        MessageLib.UpdateRestrictionFreeze memory aa = MessageLib.UpdateRestrictionFreeze({user: user});\n        MessageLib.UpdateRestrictionFreeze memory bb = MessageLib.deserializeUpdateRestrictionFreeze(aa.serialize());\n\n        assertEq(aa.user, bb.user);\n\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateRestrictionUnfreeze(bytes32 user) public pure {\n        MessageLib.UpdateRestrictionUnfreeze memory aa = MessageLib.UpdateRestrictionUnfreeze({user: user});\n        MessageLib.UpdateRestrictionUnfreeze memory bb = MessageLib.deserializeUpdateRestrictionUnfreeze(aa.serialize());\n\n        assertEq(aa.user, bb.user);\n\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateContract(uint64 poolId, bytes16 scId, bytes32 target, bytes memory payload) public pure {\n        MessageLib.UpdateContract memory a =\n            MessageLib.UpdateContract({poolId: poolId, scId: scId, target: target, payload: payload});\n        MessageLib.UpdateContract memory b = MessageLib.deserializeUpdateContract(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.target, b.target);\n        assertEq(a.payload, b.payload);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n\n        // Check the payload length is correctly encoded as little endian\n        assertEq(a.payload.length, uint8(a.serialize()[a.serialize().messageLength() - a.payload.length - 1]));\n    }\n\n    function testUpdateContractVaultUpdate(bytes32 vaultOrFactory, uint128 assetId, uint8 kind) public pure {\n        MessageLib.UpdateContractVaultUpdate memory a =\n            MessageLib.UpdateContractVaultUpdate({vaultOrFactory: vaultOrFactory, assetId: assetId, kind: kind});\n        MessageLib.UpdateContractVaultUpdate memory b = MessageLib.deserializeUpdateContractVaultUpdate(a.serialize());\n\n        assertEq(a.vaultOrFactory, b.vaultOrFactory);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.kind, b.kind);\n\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateContractUpdateManager(bytes32 who, bool canManage) public pure {\n        MessageLib.UpdateContractUpdateManager memory a =\n            MessageLib.UpdateContractUpdateManager({who: who, canManage: canManage});\n        MessageLib.UpdateContractUpdateManager memory b =\n            MessageLib.deserializeUpdateContractUpdateManager(a.serialize());\n\n        assertEq(a.who, b.who);\n        assertEq(a.canManage, b.canManage);\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateContractMaxAssetPriceAge(uint128 assetId, uint64 maxPriceAge) public pure {\n        MessageLib.UpdateContractMaxAssetPriceAge memory a =\n            MessageLib.UpdateContractMaxAssetPriceAge({assetId: assetId, maxPriceAge: maxPriceAge});\n        MessageLib.UpdateContractMaxAssetPriceAge memory b =\n            MessageLib.deserializeUpdateContractMaxAssetPriceAge(a.serialize());\n\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.maxPriceAge, b.maxPriceAge);\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateContractMaxSharePriceAge(uint64 maxPriceAge) public pure {\n        MessageLib.UpdateContractMaxSharePriceAge memory a =\n            MessageLib.UpdateContractMaxSharePriceAge({maxPriceAge: maxPriceAge});\n        MessageLib.UpdateContractMaxSharePriceAge memory b =\n            MessageLib.deserializeUpdateContractMaxSharePriceAge(a.serialize());\n\n        assertEq(a.maxPriceAge, b.maxPriceAge);\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateContractValuation(bytes32 valuation) public pure {\n        MessageLib.UpdateContractValuation memory a = MessageLib.UpdateContractValuation({valuation: valuation});\n        MessageLib.UpdateContractValuation memory b = MessageLib.deserializeUpdateContractValuation(a.serialize());\n\n        assertEq(a.valuation, b.valuation);\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testUpdateContractSyncDepositMaxReserve(uint128 assetId, uint128 maxReserve) public pure {\n        MessageLib.UpdateContractSyncDepositMaxReserve memory a =\n            MessageLib.UpdateContractSyncDepositMaxReserve({assetId: assetId, maxReserve: maxReserve});\n        MessageLib.UpdateContractSyncDepositMaxReserve memory b =\n            MessageLib.deserializeUpdateContractSyncDepositMaxReserve(a.serialize());\n\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.maxReserve, b.maxReserve);\n        // This message is a submessage and has not static message length defined\n    }\n\n    function testDepositRequest(uint64 poolId, bytes16 scId, bytes32 investor, uint128 assetId, uint128 amount)\n        public\n        pure\n    {\n        MessageLib.DepositRequest memory a = MessageLib.DepositRequest({\n            poolId: poolId,\n            scId: scId,\n            investor: investor,\n            assetId: assetId,\n            amount: amount\n        });\n        MessageLib.DepositRequest memory b = MessageLib.deserializeDepositRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.amount, b.amount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testRedeemRequest(uint64 poolId, bytes16 scId, bytes32 investor, uint128 assetId, uint128 amount)\n        public\n        pure\n    {\n        MessageLib.RedeemRequest memory a =\n            MessageLib.RedeemRequest({poolId: poolId, scId: scId, investor: investor, assetId: assetId, amount: amount});\n        MessageLib.RedeemRequest memory b = MessageLib.deserializeRedeemRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.amount, b.amount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testFulfilledDepositRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 assetAmount,\n        uint128 shareAmount\n    ) public pure {\n        MessageLib.FulfilledDepositRequest memory a = MessageLib.FulfilledDepositRequest({\n            poolId: poolId,\n            scId: scId,\n            investor: investor,\n            assetId: assetId,\n            assetAmount: assetAmount,\n            shareAmount: shareAmount\n        });\n        MessageLib.FulfilledDepositRequest memory b = MessageLib.deserializeFulfilledDepositRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.assetAmount, b.assetAmount);\n        assertEq(a.shareAmount, b.shareAmount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testFulfilledRedeemRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 assetAmount,\n        uint128 shareAmount\n    ) public pure {\n        MessageLib.FulfilledRedeemRequest memory a = MessageLib.FulfilledRedeemRequest({\n            poolId: poolId,\n            scId: scId,\n            investor: investor,\n            assetId: assetId,\n            assetAmount: assetAmount,\n            shareAmount: shareAmount\n        });\n        MessageLib.FulfilledRedeemRequest memory b = MessageLib.deserializeFulfilledRedeemRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.assetAmount, b.assetAmount);\n        assertEq(a.shareAmount, b.shareAmount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testCancelDepositRequest(uint64 poolId, bytes16 scId, bytes32 investor, uint128 assetId) public pure {\n        MessageLib.CancelDepositRequest memory a =\n            MessageLib.CancelDepositRequest({poolId: poolId, scId: scId, investor: investor, assetId: assetId});\n        MessageLib.CancelDepositRequest memory b = MessageLib.deserializeCancelDepositRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testCancelRedeemRequest(uint64 poolId, bytes16 scId, bytes32 investor, uint128 assetId) public pure {\n        MessageLib.CancelRedeemRequest memory a =\n            MessageLib.CancelRedeemRequest({poolId: poolId, scId: scId, investor: investor, assetId: assetId});\n        MessageLib.CancelRedeemRequest memory b = MessageLib.deserializeCancelRedeemRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testFulfilledCancelDepositRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 cancelledAmount\n    ) public pure {\n        MessageLib.FulfilledCancelDepositRequest memory a = MessageLib.FulfilledCancelDepositRequest({\n            poolId: poolId,\n            scId: scId,\n            investor: investor,\n            assetId: assetId,\n            cancelledAmount: cancelledAmount\n        });\n        MessageLib.FulfilledCancelDepositRequest memory b =\n            MessageLib.deserializeFulfilledCancelDepositRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.cancelledAmount, b.cancelledAmount);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testFulfilledCancelRedeemRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 cancelledShares\n    ) public pure {\n        MessageLib.FulfilledCancelRedeemRequest memory a = MessageLib.FulfilledCancelRedeemRequest({\n            poolId: poolId,\n            scId: scId,\n            investor: investor,\n            assetId: assetId,\n            cancelledShares: cancelledShares\n        });\n        MessageLib.FulfilledCancelRedeemRequest memory b =\n            MessageLib.deserializeFulfilledCancelRedeemRequest(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.investor, b.investor);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.cancelledShares, b.cancelledShares);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testUpdateHoldingAmount(\n        uint64 poolId,\n        bytes16 scId,\n        uint128 assetId,\n        bytes32 who,\n        uint128 amount,\n        uint128 pricePerUnit,\n        uint64 timestamp,\n        bool isIncrease\n    ) public pure {\n        MessageLib.UpdateHoldingAmount memory a = MessageLib.UpdateHoldingAmount({\n            poolId: poolId,\n            scId: scId,\n            assetId: assetId,\n            who: who,\n            amount: amount,\n            pricePerUnit: pricePerUnit,\n            timestamp: timestamp,\n            isIncrease: isIncrease\n        });\n\n        MessageLib.UpdateHoldingAmount memory b = MessageLib.deserializeUpdateHoldingAmount(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.who, b.who);\n        assertEq(a.amount, b.amount);\n        assertEq(a.pricePerUnit, b.pricePerUnit);\n        assertEq(a.timestamp, b.timestamp);\n        assertEq(a.isIncrease, b.isIncrease);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testUpdateShares(uint64 poolId, bytes16 scId, uint128 shares, uint64 timestamp, bool isIssuance)\n        public\n        pure\n    {\n        MessageLib.UpdateShares memory a = MessageLib.UpdateShares({\n            poolId: poolId,\n            scId: scId,\n            shares: shares,\n            timestamp: timestamp,\n            isIssuance: isIssuance\n        });\n\n        MessageLib.UpdateShares memory b = MessageLib.deserializeUpdateShares(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.shares, b.shares);\n        assertEq(a.timestamp, b.timestamp);\n        assertEq(a.isIssuance, b.isIssuance);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testApprovedDeposits(\n        uint64 poolId,\n        bytes16 scId,\n        uint128 assetId,\n        uint128 assetAmount,\n        uint128 pricePoolPerAsset\n    ) public pure {\n        MessageLib.ApprovedDeposits memory a = MessageLib.ApprovedDeposits({\n            poolId: poolId,\n            scId: scId,\n            assetId: assetId,\n            assetAmount: assetAmount,\n            pricePoolPerAsset: pricePoolPerAsset\n        });\n\n        MessageLib.ApprovedDeposits memory b = MessageLib.deserializeApprovedDeposits(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.assetAmount, b.assetAmount);\n        assertEq(a.pricePoolPerAsset, b.pricePoolPerAsset);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testRevokedShares(\n        uint64 poolId,\n        bytes16 scId,\n        uint128 assetId,\n        uint128 assetAmount,\n        uint128 shareAmount,\n        uint128 pricePoolPerShare\n    ) public pure {\n        MessageLib.RevokedShares memory a = MessageLib.RevokedShares({\n            poolId: poolId,\n            scId: scId,\n            assetId: assetId,\n            assetAmount: assetAmount,\n            shareAmount: shareAmount,\n            pricePoolPerShare: pricePoolPerShare\n        });\n\n        MessageLib.RevokedShares memory b = MessageLib.deserializeRevokedShares(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.assetId, b.assetId);\n        assertEq(a.assetAmount, b.assetAmount);\n        assertEq(a.shareAmount, b.shareAmount);\n        assertEq(a.pricePoolPerShare, b.pricePoolPerShare);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testTriggerIssueShares(uint64 poolId, bytes16 scId, bytes32 who, uint128 shares) public pure {\n        MessageLib.TriggerIssueShares memory a =\n            MessageLib.TriggerIssueShares({poolId: poolId, scId: scId, who: who, shares: shares});\n\n        MessageLib.TriggerIssueShares memory b = MessageLib.deserializeTriggerIssueShares(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.who, b.who);\n        assertEq(a.shares, b.shares);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testTriggerSubmitQueuedShares(uint64 poolId, bytes16 scId) public pure {\n        MessageLib.TriggerSubmitQueuedShares memory a =\n            MessageLib.TriggerSubmitQueuedShares({poolId: poolId, scId: scId});\n        MessageLib.TriggerSubmitQueuedShares memory b = MessageLib.deserializeTriggerSubmitQueuedShares(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testTriggerSubmitQueuedAssets(uint64 poolId, bytes16 scId, uint128 assetId) public pure {\n        MessageLib.TriggerSubmitQueuedAssets memory a =\n            MessageLib.TriggerSubmitQueuedAssets({poolId: poolId, scId: scId, assetId: assetId});\n        MessageLib.TriggerSubmitQueuedAssets memory b = MessageLib.deserializeTriggerSubmitQueuedAssets(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.assetId, b.assetId);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n\n    function testSetQueue(uint64 poolId, bytes16 scId, bool enabled) public pure {\n        MessageLib.SetQueue memory a = MessageLib.SetQueue({poolId: poolId, scId: scId, enabled: enabled});\n        MessageLib.SetQueue memory b = MessageLib.deserializeSetQueue(a.serialize());\n\n        assertEq(a.poolId, b.poolId);\n        assertEq(a.scId, b.scId);\n        assertEq(a.enabled, b.enabled);\n\n        assertEq(a.serialize().messageLength(), a.serialize().length);\n        assertEq(a.serialize().messagePoolId().raw(), a.poolId);\n    }\n}\n"
    },
    "test/common/unit/libraries/MessageProofLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract TestMessageProofLibIdentities is Test {\n    using MessageProofLib for *;\n\n    function testMessageProof(bytes32 hash_) public pure {\n        assertEq(hash_, MessageProofLib.deserializeMessageProof(MessageProofLib.serializeMessageProof(hash_)));\n    }\n}\n"
    },
    "test/hooks/integration/FreelyTransferable.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {RedemptionRestrictions} from \"src/hooks/RedemptionRestrictions.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\n\ncontract RedemptionRestrictionsTest is BaseTest {\n    using CastLib for *;\n\n    function testRedemptionRestrictionsHook(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128 / 2));\n\n        (, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, 6, redemptionRestrictionsHook, bytes16(bytes(\"1\")), address(erc20), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        RedemptionRestrictions hook = RedemptionRestrictions(redemptionRestrictionsHook);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), defaultPrice, uint64(block.timestamp)\n        );\n\n        // Anyone can deposit\n        address investor = makeAddr(\"Investor\");\n        erc20.mint(investor, amount);\n\n        vm.startPrank(investor);\n        erc20.approve(vault_, amount);\n        (bool isMember,) = hook.isMember(address(shareToken), investor);\n        assertEq(isMember, false);\n        vault.requestDeposit(amount, investor, investor);\n        vm.stopPrank();\n\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(),\n            vault.scId().raw(),\n            bytes32(bytes20(investor)),\n            assetId,\n            uint128(amount),\n            uint128(amount)\n        );\n\n        vm.prank(investor);\n        vault.deposit(amount, investor, investor);\n\n        // Can transfer to anyone\n        address investor2 = makeAddr(\"Investor2\");\n        vm.prank(investor);\n        shareToken.transfer(investor2, amount / 2);\n\n        // Not everyone can redeem\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vm.prank(investor);\n        vault.requestRedeem(amount / 2, investor, investor);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        (isMember,) = hook.isMember(address(shareToken), investor);\n        assertEq(isMember, true);\n\n        vm.prank(investor);\n        vault.requestRedeem(amount / 2, investor, investor);\n        uint128 fulfillment = uint128(amount / 2);\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(investor)), assetId, fulfillment, fulfillment\n        );\n\n        vm.prank(investor);\n        vault.redeem(amount / 2, investor, investor);\n    }\n}\n"
    },
    "test/hub/integration/BaseTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IMulticall} from \"src/misc/interfaces/IMulticall.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\nimport {MessageLib, VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId, newAssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {IGasService} from \"src/common/interfaces/IGasService.sol\";\n\nimport {HubDeployer, ISafe} from \"script/HubDeployer.s.sol\";\nimport {MESSAGE_COST_ENV} from \"script/CommonDeployer.s.sol\";\nimport {AccountType} from \"src/hub/interfaces/IHub.sol\";\nimport {JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\n\nimport {MockVaults} from \"test/hub/mocks/MockVaults.sol\";\nimport {MockValuation} from \"test/misc/mocks/MockValuation.sol\";\n\ncontract BaseTest is HubDeployer, Test {\n    uint16 constant CHAIN_CP = 5;\n    uint16 constant CHAIN_CV = 6;\n\n    string constant SC_NAME = \"ExampleName\";\n    string constant SC_SYMBOL = \"ExampleSymbol\";\n    bytes32 constant SC_SALT = bytes32(\"ExampleSalt\");\n    bytes32 constant SC_HOOK = bytes32(\"ExampleHookData\");\n\n    address immutable ADMIN = address(adminSafe);\n    address immutable FM = makeAddr(\"FM\");\n    address immutable ANY = makeAddr(\"Anyone\");\n    bytes32 immutable INVESTOR = bytes32(\"Investor\");\n\n    AssetId immutable USDC_C2 = newAssetId(CHAIN_CV, 1);\n    AssetId immutable EUR_STABLE_C2 = newAssetId(CHAIN_CV, 2);\n\n    uint128 constant INVESTOR_AMOUNT = 100 * 1e6; // USDC_C2\n    uint128 constant SHARE_AMOUNT = 10 * 1e18; // Share from USD\n    uint128 constant APPROVED_INVESTOR_AMOUNT = INVESTOR_AMOUNT / 5;\n    uint128 constant APPROVED_SHARE_AMOUNT = SHARE_AMOUNT / 5;\n    D18 immutable NAV_PER_SHARE = d18(2, 1);\n\n    AccountId constant ASSET_USDC_ACCOUNT = AccountId.wrap(0x01);\n    AccountId constant EQUITY_ACCOUNT = AccountId.wrap(0x02);\n    AccountId constant LOSS_ACCOUNT = AccountId.wrap(0x03);\n    AccountId constant GAIN_ACCOUNT = AccountId.wrap(0x04);\n    AccountId constant ASSET_EUR_STABLE_ACCOUNT = AccountId.wrap(0x05);\n\n    uint64 constant GAS = 100 wei;\n\n    MockVaults cv;\n    MockValuation valuation;\n\n    function _mockStuff() private {\n        cv = new MockVaults(CHAIN_CV, gateway);\n        wire(CHAIN_CV, cv, address(this));\n\n        valuation = new MockValuation(hubRegistry);\n    }\n\n    function setUp() public virtual {\n        // Pre deployment\n        vm.setEnv(MESSAGE_COST_ENV, vm.toString(GAS));\n\n        // Deployment\n        deployHub(CHAIN_CP, ISafe(ADMIN), address(this), true);\n        _mockStuff();\n        removeHubDeployerAccess(address(this));\n\n        // Initialize accounts\n        vm.deal(FM, 1 ether);\n\n        // Label contracts & actors (for debugging)\n        vm.label(address(identityValuation), \"IdentityValuation\");\n        vm.label(address(hubRegistry), \"HubRegistry\");\n        vm.label(address(accounting), \"Accounting\");\n        vm.label(address(holdings), \"Holdings\");\n        vm.label(address(shareClassManager), \"ShareClassManager\");\n        vm.label(address(hub), \"Hub\");\n        vm.label(address(gateway), \"Gateway\");\n        vm.label(address(messageProcessor), \"MessageProcessor\");\n        vm.label(address(messageDispatcher), \"MessageDispatcher\");\n        vm.label(address(cv), \"CV\");\n\n        // We should not use the block ChainID\n        vm.chainId(0xDEAD);\n    }\n\n    function _assertEqAccountValue(PoolId poolId, AccountId accountId, bool expectedIsPositive, uint128 expectedValue)\n        internal\n        view\n    {\n        (bool isPositive, uint128 value) = accounting.accountValue(poolId, accountId);\n        assertEq(isPositive, expectedIsPositive, \"Mismatch: Accounting.accountValue - isPositive\");\n        assertEq(value, expectedValue, \"Mismatch: Accounting.accountValue - value\");\n    }\n}\n"
    },
    "test/hub/integration/BatchingAndPayment.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/hub/integration/BaseTest.sol\";\n\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\n\ncontract TestBatchingAndPayment is BaseTest {\n    /// Test the following:\n    /// - multicall()\n    ///    - notifyPool(poolA)\n    ///    - notifyPool(poolA)\n    ///\n    /// will send one message. The batch sent is [NotifyPool, NotifyPool].\n    ///\n    /// forge-config: default.isolate = true\n    function testMultipleMulticallSamePool() public {\n        PoolId poolA = hubRegistry.poolId(CHAIN_CP, 1);\n        vm.startPrank(ADMIN);\n        guardian.createPool(poolA, FM, USD);\n\n        vm.startPrank(FM);\n\n        (bytes[] memory cs, uint256 c) = (new bytes[](2), 0);\n        cs[c++] = abi.encodeWithSelector(hub.notifyPool.selector, poolA, CHAIN_CV);\n        cs[c++] = abi.encodeWithSelector(hub.notifyPool.selector, poolA, CHAIN_CV);\n        assertEq(c, cs.length);\n\n        hub.multicall{value: GAS * 2}(cs);\n    }\n\n    /// Test the following:\n    /// - multicall()\n    ///    - notifyPool(poolA)\n    ///    - notifyPool(poolB)\n    ///\n    /// will send two messages because they are different pools.\n    ///\n    /// forge-config: default.isolate = true\n    function testMultipleMulticallDifferentPools() public {\n        vm.startPrank(ADMIN);\n\n        PoolId poolA = hubRegistry.poolId(CHAIN_CP, 1);\n        PoolId poolB = hubRegistry.poolId(CHAIN_CP, 2);\n        guardian.createPool(poolA, FM, USD);\n        guardian.createPool(poolB, FM, USD);\n\n        vm.startPrank(FM);\n\n        (bytes[] memory cs, uint256 c) = (new bytes[](2), 0);\n        cs[c++] = abi.encodeWithSelector(hub.notifyPool.selector, poolA, CHAIN_CV);\n        cs[c++] = abi.encodeWithSelector(hub.notifyPool.selector, poolB, CHAIN_CV);\n        assertEq(c, cs.length);\n\n        hub.multicall{value: GAS * 2}(cs);\n    }\n}\n"
    },
    "test/hub/integration/Cases.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/hub/integration/BaseTest.sol\";\n\ncontract TestCases is BaseTest {\n    using CastLib for string;\n    using CastLib for bytes32;\n    using MathLib for *;\n    using MessageLib for *;\n    using PricingLib for *;\n\n    /// forge-config: default.isolate = true\n    function testPoolCreation() public returns (PoolId poolId, ShareClassId scId) {\n        cv.registerAsset(USDC_C2, 6);\n        cv.registerAsset(EUR_STABLE_C2, 12);\n\n        poolId = hubRegistry.poolId(CHAIN_CP, 1);\n        vm.prank(ADMIN);\n        guardian.createPool(poolId, FM, USD);\n\n        scId = shareClassManager.previewNextShareClassId(poolId);\n\n        vm.startPrank(FM);\n        hub.setPoolMetadata(poolId, bytes(\"Testing pool\"));\n        hub.addShareClass(poolId, SC_NAME, SC_SYMBOL, SC_SALT);\n        hub.notifyPool{value: GAS}(poolId, CHAIN_CV);\n        hub.notifyShareClass{value: GAS}(poolId, scId, CHAIN_CV, SC_HOOK);\n\n        hub.createAccount(poolId, ASSET_USDC_ACCOUNT, true);\n        hub.createAccount(poolId, EQUITY_ACCOUNT, false);\n        hub.createAccount(poolId, LOSS_ACCOUNT, false);\n        hub.createAccount(poolId, GAIN_ACCOUNT, false);\n        hub.createAccount(poolId, ASSET_EUR_STABLE_ACCOUNT, true);\n        hub.createHolding(\n            poolId, scId, USDC_C2, identityValuation, ASSET_USDC_ACCOUNT, EQUITY_ACCOUNT, GAIN_ACCOUNT, LOSS_ACCOUNT\n        );\n        hub.createHolding(\n            poolId, scId, EUR_STABLE_C2, valuation, ASSET_EUR_STABLE_ACCOUNT, EQUITY_ACCOUNT, GAIN_ACCOUNT, LOSS_ACCOUNT\n        );\n        hub.updateContract{value: GAS}(\n            poolId,\n            scId,\n            CHAIN_CV,\n            bytes32(\"target\"),\n            MessageLib.UpdateContractVaultUpdate({\n                vaultOrFactory: bytes32(\"factory\"),\n                assetId: USDC_C2.raw(),\n                kind: uint8(VaultUpdateKind.DeployAndLink)\n            }).serialize()\n        );\n\n        MessageLib.NotifyPool memory m0 = MessageLib.deserializeNotifyPool(cv.popMessage());\n        assertEq(m0.poolId, poolId.raw());\n\n        MessageLib.NotifyShareClass memory m1 = MessageLib.deserializeNotifyShareClass(cv.popMessage());\n        assertEq(m1.poolId, poolId.raw());\n        assertEq(m1.scId, scId.raw());\n        assertEq(m1.name, SC_NAME);\n        assertEq(m1.symbol, SC_SYMBOL.toBytes32());\n        assertEq(m1.decimals, 18);\n        assertEq(m1.salt, SC_SALT);\n        assertEq(m1.hook, SC_HOOK);\n\n        MessageLib.UpdateContract memory m2 = MessageLib.deserializeUpdateContract(cv.popMessage());\n        assertEq(m2.scId, scId.raw());\n        assertEq(m2.target, bytes32(\"target\"));\n\n        MessageLib.UpdateContractVaultUpdate memory m3 = MessageLib.deserializeUpdateContractVaultUpdate(m2.payload);\n        assertEq(m3.assetId, USDC_C2.raw());\n        assertEq(m3.vaultOrFactory, bytes32(\"factory\"));\n        assertEq(m3.kind, uint8(VaultUpdateKind.DeployAndLink));\n    }\n\n    /// forge-config: default.isolate = true\n    function testDeposit() public returns (PoolId poolId, ShareClassId scId) {\n        (poolId, scId) = testPoolCreation();\n\n        cv.requestDeposit(poolId, scId, USDC_C2, INVESTOR, INVESTOR_AMOUNT);\n\n        vm.startPrank(FM);\n        hub.approveDeposits{value: GAS}(\n            poolId, scId, USDC_C2, shareClassManager.nowDepositEpoch(scId, USDC_C2), APPROVED_INVESTOR_AMOUNT\n        );\n        hub.issueShares{value: GAS}(\n            poolId, scId, USDC_C2, shareClassManager.nowIssueEpoch(scId, USDC_C2), NAV_PER_SHARE\n        );\n\n        vm.startPrank(ANY);\n        vm.deal(ANY, GAS);\n        hub.notifyDeposit{value: GAS}(\n            poolId, scId, USDC_C2, INVESTOR, shareClassManager.maxDepositClaims(scId, INVESTOR, USDC_C2)\n        );\n\n        MessageLib.ApprovedDeposits memory m0 = MessageLib.deserializeApprovedDeposits(cv.popMessage());\n        assertEq(m0.poolId, poolId.raw());\n        assertEq(m0.scId, scId.raw());\n        assertEq(m0.assetId, USDC_C2.raw());\n        assertEq(m0.assetAmount, APPROVED_INVESTOR_AMOUNT);\n\n        MessageLib.IssuedShares memory m1 = MessageLib.deserializeIssuedShares(cv.popMessage());\n        assertEq(m1.poolId, poolId.raw());\n        assertEq(m1.scId, scId.raw());\n        assertEq(m1.pricePoolPerShare, NAV_PER_SHARE.raw());\n\n        MessageLib.FulfilledDepositRequest memory m2 = MessageLib.deserializeFulfilledDepositRequest(cv.popMessage());\n        assertEq(m2.poolId, poolId.raw());\n        assertEq(m2.scId, scId.raw());\n        assertEq(m2.investor, INVESTOR);\n        assertEq(m2.assetId, USDC_C2.raw());\n        assertEq(m2.assetAmount, APPROVED_INVESTOR_AMOUNT);\n        assertEq(\n            m2.shareAmount,\n            PricingLib.convertWithPrice(\n                APPROVED_INVESTOR_AMOUNT,\n                hubRegistry.decimals(USDC_C2),\n                hubRegistry.decimals(poolId),\n                NAV_PER_SHARE.reciprocal()\n            ).toUint128()\n        );\n    }\n\n    /// forge-config: default.isolate = true\n    function testRedeem() public returns (PoolId poolId, ShareClassId scId) {\n        (poolId, scId) = testDeposit();\n\n        cv.requestRedeem(poolId, scId, USDC_C2, INVESTOR, SHARE_AMOUNT);\n\n        uint128 revokedAssetAmount = PricingLib.convertWithPrice(\n            APPROVED_SHARE_AMOUNT, hubRegistry.decimals(poolId), hubRegistry.decimals(USDC_C2), NAV_PER_SHARE\n        ).toUint128();\n\n        vm.startPrank(FM);\n        hub.approveRedeems(\n            poolId, scId, USDC_C2, shareClassManager.nowRedeemEpoch(scId, USDC_C2), APPROVED_SHARE_AMOUNT\n        );\n        hub.revokeShares{value: GAS}(\n            poolId, scId, USDC_C2, shareClassManager.nowRevokeEpoch(scId, USDC_C2), NAV_PER_SHARE\n        );\n\n        vm.startPrank(ANY);\n        vm.deal(ANY, GAS);\n        hub.notifyRedeem{value: GAS}(\n            poolId, scId, USDC_C2, INVESTOR, shareClassManager.maxRedeemClaims(scId, INVESTOR, USDC_C2)\n        );\n\n        MessageLib.RevokedShares memory m0 = MessageLib.deserializeRevokedShares(cv.popMessage());\n        assertEq(m0.poolId, poolId.raw());\n        assertEq(m0.scId, scId.raw());\n        assertEq(m0.assetId, USDC_C2.raw());\n        assertEq(m0.assetAmount, revokedAssetAmount);\n\n        MessageLib.FulfilledRedeemRequest memory m1 = MessageLib.deserializeFulfilledRedeemRequest(cv.popMessage());\n        assertEq(m1.poolId, poolId.raw());\n        assertEq(m1.scId, scId.raw());\n        assertEq(m1.investor, INVESTOR);\n        assertEq(m1.assetId, USDC_C2.raw());\n        assertEq(m1.assetAmount, revokedAssetAmount);\n        assertEq(m1.shareAmount, APPROVED_SHARE_AMOUNT);\n    }\n\n    /// forge-config: default.isolate = true\n    function testCalUpdateHolding() public {\n        (PoolId poolId, ShareClassId scId) = testPoolCreation();\n        uint128 poolDecimals = (10 ** hubRegistry.decimals(USD.raw())).toUint128();\n        uint128 assetDecimals = (10 ** hubRegistry.decimals(USDC_C2.raw())).toUint128();\n\n        cv.updateHoldingAmount(poolId, scId, USDC_C2, 1000 * assetDecimals, D18.wrap(1e18), true);\n\n        assertEq(holdings.amount(poolId, scId, USDC_C2), 1000 * assetDecimals);\n        assertEq(holdings.value(poolId, scId, USDC_C2), 1000 * poolDecimals);\n        _assertEqAccountValue(poolId, EQUITY_ACCOUNT, true, 1000 * poolDecimals);\n        _assertEqAccountValue(poolId, ASSET_USDC_ACCOUNT, true, 1000 * poolDecimals);\n\n        cv.updateHoldingAmount(poolId, scId, USDC_C2, 600 * assetDecimals, D18.wrap(1e18), false);\n\n        assertEq(holdings.amount(poolId, scId, USDC_C2), 400 * assetDecimals);\n        assertEq(holdings.value(poolId, scId, USDC_C2), 400 * poolDecimals);\n        _assertEqAccountValue(poolId, ASSET_USDC_ACCOUNT, true, 400 * poolDecimals);\n        _assertEqAccountValue(poolId, EQUITY_ACCOUNT, true, 400 * poolDecimals);\n    }\n\n    /// forge-config: default.isolate = true\n    function testCalUpdateShares() public {\n        (PoolId poolId, ShareClassId scId) = testPoolCreation();\n\n        cv.updateShares(poolId, scId, 100, true);\n\n        (uint128 totalIssuance,) = shareClassManager.metrics(scId);\n        assertEq(totalIssuance, 100);\n\n        cv.updateShares(poolId, scId, 45, false);\n\n        (uint128 totalIssuance2,) = shareClassManager.metrics(scId);\n        assertEq(totalIssuance2, 55);\n    }\n\n    /// forge-config: default.isolate = true\n    function testNotifyPricePoolPerShare() public {\n        (PoolId poolId, ShareClassId scId) = testPoolCreation();\n        D18 sharePrice = d18(100, 1);\n        D18 identityPrice = d18(1, 1);\n        D18 poolPerEurPrice = d18(4, 1);\n        AssetId poolCurrency = hubRegistry.currency(poolId);\n\n        valuation.setPrice(EUR_STABLE_C2.addr(), poolCurrency.addr(), poolPerEurPrice);\n\n        vm.startPrank(FM);\n        hub.updatePricePerShare(poolId, scId, sharePrice);\n        hub.notifyAssetPrice{value: GAS}(poolId, scId, EUR_STABLE_C2);\n        hub.notifyAssetPrice{value: GAS}(poolId, scId, USDC_C2);\n        hub.notifySharePrice{value: GAS}(poolId, scId, CHAIN_CV);\n\n        MessageLib.NotifyPricePoolPerAsset memory m0 = MessageLib.deserializeNotifyPricePoolPerAsset(cv.popMessage());\n        assertEq(m0.poolId, poolId.raw());\n        assertEq(m0.scId, scId.raw());\n        assertEq(m0.assetId, EUR_STABLE_C2.raw());\n        assertEq(m0.price, poolPerEurPrice.inner(), \"EUR price mismatch\");\n        assertEq(m0.timestamp, block.timestamp.toUint64());\n\n        MessageLib.NotifyPricePoolPerAsset memory m1 = MessageLib.deserializeNotifyPricePoolPerAsset(cv.popMessage());\n        assertEq(m1.poolId, poolId.raw());\n        assertEq(m1.scId, scId.raw());\n        assertEq(m1.assetId, USDC_C2.raw());\n        assertEq(m1.price, identityPrice.inner(), \"USDC price mismatch\");\n        assertEq(m1.timestamp, block.timestamp.toUint64());\n\n        MessageLib.NotifyPricePoolPerShare memory m2 = MessageLib.deserializeNotifyPricePoolPerShare(cv.popMessage());\n        assertEq(m2.poolId, poolId.raw());\n        assertEq(m2.scId, scId.raw());\n        assertEq(m2.price, sharePrice.raw(), \"Share price mismatch\");\n        assertEq(m2.timestamp, block.timestamp.toUint64());\n    }\n}\n"
    },
    "test/hub/mocks/MockVaults.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth} from \"src/misc/Auth.sol\";\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\n\nimport {MessageType, MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\n\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract MockVaults is Test, Auth, IAdapter {\n    using MessageLib for *;\n    using CastLib for string;\n    using BytesLib for bytes;\n\n    IMessageHandler public handler;\n    uint16 public sourceChainId;\n\n    bytes[] public lastMessages;\n\n    constructor(uint16 centrifugeId, IMessageHandler handler_) Auth(msg.sender) {\n        handler = handler_;\n        sourceChainId = centrifugeId;\n    }\n\n    function registerAsset(AssetId assetId, uint8 decimals) public {\n        handler.handle(\n            sourceChainId, MessageLib.RegisterAsset({assetId: assetId.raw(), decimals: decimals}).serialize()\n        );\n    }\n\n    function requestDeposit(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint128 amount)\n        public\n    {\n        handler.handle(\n            sourceChainId,\n            MessageLib.DepositRequest({\n                poolId: poolId.raw(),\n                scId: scId.raw(),\n                investor: investor,\n                assetId: assetId.raw(),\n                amount: amount\n            }).serialize()\n        );\n    }\n\n    function requestRedeem(PoolId poolId, ShareClassId scId, AssetId assetId, bytes32 investor, uint128 amount)\n        public\n    {\n        handler.handle(\n            sourceChainId,\n            MessageLib.RedeemRequest({\n                poolId: poolId.raw(),\n                scId: scId.raw(),\n                investor: investor,\n                assetId: assetId.raw(),\n                amount: amount\n            }).serialize()\n        );\n    }\n\n    function send(uint16, bytes memory data, uint256, address) external payable returns (bytes32 adapterData) {\n        while (data.length > 0) {\n            uint16 messageLength = data.messageLength();\n            bytes memory message = data.slice(0, messageLength);\n\n            lastMessages.push(message);\n\n            data = data.slice(messageLength, data.length - messageLength);\n        }\n\n        adapterData = bytes32(\"\");\n    }\n\n    function updateHoldingAmount(\n        PoolId poolId,\n        ShareClassId scId,\n        AssetId assetId,\n        uint128 amount,\n        D18 pricePoolPerAsset,\n        bool isIncrease\n    ) public {\n        handler.handle(\n            sourceChainId,\n            MessageLib.UpdateHoldingAmount({\n                poolId: poolId.raw(),\n                scId: scId.raw(),\n                assetId: assetId.raw(),\n                who: bytes32(0),\n                amount: amount,\n                pricePerUnit: pricePoolPerAsset.raw(),\n                timestamp: 0,\n                isIncrease: isIncrease\n            }).serialize()\n        );\n    }\n\n    function updateShares(PoolId poolId, ShareClassId scId, uint128 amount, bool isIssuance) public {\n        handler.handle(\n            sourceChainId,\n            MessageLib.UpdateShares({\n                poolId: poolId.raw(),\n                scId: scId.raw(),\n                shares: amount,\n                timestamp: 0,\n                isIssuance: isIssuance\n            }).serialize()\n        );\n    }\n\n    function estimate(uint16, bytes calldata, uint256 baseCost) external pure returns (uint256) {\n        return baseCost;\n    }\n\n    function resetMessages() external {\n        delete lastMessages;\n    }\n\n    function messageCount() external view returns (uint256) {\n        return lastMessages.length;\n    }\n\n    function popMessage() external returns (bytes memory message) {\n        require(lastMessages.length > 0, \"mockVaults/no-msgs\");\n\n        message = lastMessages[0];\n\n        for (uint256 i = 1; i < lastMessages.length; i++) {\n            lastMessages[i - 1] = lastMessages[i];\n        }\n\n        lastMessages.pop();\n    }\n}\n"
    },
    "test/hub/unit/Accounting.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {Accounting} from \"src/hub/Accounting.sol\";\nimport {IAccounting, JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\n\nenum AccountType {\n    Asset,\n    Equity,\n    Loss,\n    Gain\n}\n\nPoolId constant POOL_A = PoolId.wrap(33);\nPoolId constant POOL_B = PoolId.wrap(44);\n\ncontract AccountingTest is Test {\n    AccountId immutable CASH_ACCOUNT = AccountId.wrap(1);\n    AccountId immutable BOND1_INVESTMENT_ACCOUNT = AccountId.wrap(101);\n    AccountId immutable FEES_EXPENSE_ACCOUNT = AccountId.wrap(401);\n    AccountId immutable FEES_PAYABLE_ACCOUNT = AccountId.wrap(201);\n    AccountId immutable EQUITY_ACCOUNT = AccountId.wrap(301);\n    AccountId immutable GAIN_ACCOUNT = AccountId.wrap(302);\n    AccountId immutable NON_INITIALIZED_ACCOUNT = AccountId.wrap(999);\n    JournalEntry[] EMPTY_JOURNAL_ENTRY;\n\n    Accounting accounting = new Accounting(address(this));\n\n    function setUp() public {\n        accounting.createAccount(POOL_A, CASH_ACCOUNT, true);\n        accounting.createAccount(POOL_A, BOND1_INVESTMENT_ACCOUNT, true);\n        accounting.createAccount(POOL_A, FEES_EXPENSE_ACCOUNT, true);\n        accounting.createAccount(POOL_A, FEES_PAYABLE_ACCOUNT, false);\n        accounting.createAccount(POOL_A, EQUITY_ACCOUNT, false);\n        accounting.createAccount(POOL_A, GAIN_ACCOUNT, false);\n    }\n\n    function beforeTestSetup(bytes4 testSelector) public pure returns (bytes[] memory beforeTestCalldata) {\n        if (testSelector == this.testJournalId.selector) {\n            beforeTestCalldata = new bytes[](1);\n            beforeTestCalldata[0] = abi.encode(this.setupJournalId.selector);\n        }\n    }\n\n    function _assertEqValue(PoolId poolId, AccountId accountId, bool expectedIsPositive, uint128 expectedValue)\n        internal\n        view\n    {\n        (bool isPositive, uint128 value) = accounting.accountValue(poolId, accountId);\n        assertEq(isPositive, expectedIsPositive, \"Mismatch: Accounting.accountValue - isPositive\");\n        assertEq(value, expectedValue, \"Mismatch: Accounting.accountValue - value\");\n    }\n\n    function testAccount() public {\n        vm.expectEmit();\n        emit IAccounting.CreateAccount(POOL_B, CASH_ACCOUNT, true);\n        accounting.createAccount(POOL_B, CASH_ACCOUNT, true);\n\n        vm.expectEmit();\n        emit IAccounting.SetAccountMetadata(POOL_B, CASH_ACCOUNT, \"cash\");\n        accounting.setAccountMetadata(POOL_B, CASH_ACCOUNT, \"cash\");\n\n        (,,,, bytes memory metadata) = accounting.accounts(POOL_B, CASH_ACCOUNT);\n        assertEq(metadata, \"cash\");\n    }\n\n    function testDebitsAndCredits() public {\n        accounting.unlock(POOL_A);\n\n        vm.expectEmit();\n        emit IAccounting.Debit(POOL_A, CASH_ACCOUNT, 500);\n        accounting.addDebit(CASH_ACCOUNT, 500);\n\n        vm.expectEmit();\n        emit IAccounting.Credit(POOL_A, EQUITY_ACCOUNT, 500);\n        accounting.addCredit(EQUITY_ACCOUNT, 500);\n\n        accounting.addDebit(BOND1_INVESTMENT_ACCOUNT, 245);\n        accounting.addDebit(FEES_EXPENSE_ACCOUNT, 5);\n        accounting.addCredit(CASH_ACCOUNT, 250);\n        accounting.lock();\n\n        _assertEqValue(POOL_A, CASH_ACCOUNT, true, 250);\n        _assertEqValue(POOL_A, EQUITY_ACCOUNT, true, 500);\n        _assertEqValue(POOL_A, BOND1_INVESTMENT_ACCOUNT, true, 245);\n        _assertEqValue(POOL_A, FEES_EXPENSE_ACCOUNT, true, 5);\n    }\n\n    function testPoolIsolation() public {\n        accounting.createAccount(POOL_B, CASH_ACCOUNT, true);\n        accounting.createAccount(POOL_B, EQUITY_ACCOUNT, false);\n\n        accounting.unlock(POOL_A);\n        accounting.addDebit(CASH_ACCOUNT, 500);\n        accounting.addCredit(EQUITY_ACCOUNT, 500);\n        accounting.lock();\n\n        accounting.unlock(POOL_B);\n        accounting.addDebit(CASH_ACCOUNT, 120);\n        accounting.addCredit(EQUITY_ACCOUNT, 120);\n        accounting.lock();\n\n        _assertEqValue(POOL_A, CASH_ACCOUNT, true, 500);\n        _assertEqValue(POOL_A, EQUITY_ACCOUNT, true, 500);\n        _assertEqValue(POOL_B, CASH_ACCOUNT, true, 120);\n        _assertEqValue(POOL_B, EQUITY_ACCOUNT, true, 120);\n    }\n\n    function testUnequalDebitsAndCredits(uint128 v) public {\n        vm.assume(v != 5);\n        vm.assume(v < type(uint128).max - 250);\n\n        accounting.unlock(POOL_A);\n        accounting.addDebit(CASH_ACCOUNT, 500);\n        accounting.addCredit(EQUITY_ACCOUNT, 500);\n        accounting.addDebit(BOND1_INVESTMENT_ACCOUNT, 245);\n        accounting.addDebit(FEES_EXPENSE_ACCOUNT, v);\n        accounting.addCredit(CASH_ACCOUNT, 250);\n\n        vm.expectRevert(IAccounting.Unbalanced.selector);\n        accounting.lock();\n    }\n\n    function testDoubleUnlock() public {\n        accounting.unlock(POOL_A);\n\n        vm.expectRevert(IAccounting.AccountingAlreadyUnlocked.selector);\n        accounting.unlock(POOL_B);\n    }\n\n    function testUpdateEntryWithoutUnlocking() public {\n        vm.expectRevert(IAccounting.AccountingLocked.selector);\n        accounting.addDebit(CASH_ACCOUNT, 1);\n\n        vm.expectRevert(IAccounting.AccountingLocked.selector);\n        accounting.addCredit(EQUITY_ACCOUNT, 1);\n    }\n\n    function testNotWard() public {\n        address unauthorized = makeAddr(\"unauthorized\");\n        vm.prank(unauthorized);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.unlock(POOL_A);\n\n        accounting.unlock(POOL_A);\n\n        vm.startPrank(unauthorized);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.addDebit(CASH_ACCOUNT, 500);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.addCredit(EQUITY_ACCOUNT, 500);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.addJournal(EMPTY_JOURNAL_ENTRY, EMPTY_JOURNAL_ENTRY);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.lock();\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.createAccount(POOL_A, NON_INITIALIZED_ACCOUNT, true);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        accounting.setAccountMetadata(POOL_A, CASH_ACCOUNT, \"cash\");\n    }\n\n    function testErrWhenNonExistentAccount() public {\n        accounting.unlock(POOL_A);\n        vm.expectRevert(IAccounting.AccountDoesNotExist.selector);\n        accounting.addDebit(NON_INITIALIZED_ACCOUNT, 500);\n\n        vm.expectRevert(IAccounting.AccountDoesNotExist.selector);\n        accounting.addCredit(NON_INITIALIZED_ACCOUNT, 500);\n\n        vm.expectRevert(IAccounting.AccountDoesNotExist.selector);\n        accounting.setAccountMetadata(POOL_A, NON_INITIALIZED_ACCOUNT, \"\");\n\n        vm.expectRevert(IAccounting.AccountDoesNotExist.selector);\n        accounting.accountValue(POOL_A, NON_INITIALIZED_ACCOUNT);\n    }\n\n    function testUpdateMetadata() public {\n        accounting.setAccountMetadata(POOL_A, CASH_ACCOUNT, \"cash\");\n        accounting.setAccountMetadata(POOL_A, EQUITY_ACCOUNT, \"equity\");\n\n        (,,,, bytes memory metadata1) = accounting.accounts(POOL_A, CASH_ACCOUNT);\n        (,,,, bytes memory metadata2) = accounting.accounts(POOL_A, EQUITY_ACCOUNT);\n        (,,,, bytes memory metadata3) = accounting.accounts(POOL_B, EQUITY_ACCOUNT);\n        assertEq(metadata1, \"cash\");\n        assertEq(metadata2, \"equity\");\n        assertEq(metadata3, \"\");\n    }\n\n    function testCreatingExistingAccount() public {\n        vm.expectRevert(IAccounting.AccountExists.selector);\n        accounting.createAccount(POOL_A, CASH_ACCOUNT, true);\n    }\n\n    function setupJournalId() public {\n        // Unlock and lock POOL_A in a separate transaction,\n        // so it has a different pool counter and its transient storage is cleared.\n        accounting.unlock(POOL_A);\n        accounting.lock();\n    }\n\n    function testJournalId() public {\n        vm.expectEmit();\n        emit IAccounting.StartJournalId(POOL_A, (uint256(POOL_A.raw()) << 128) | 2);\n        accounting.unlock(POOL_A);\n\n        vm.expectEmit();\n        emit IAccounting.EndJournalId(POOL_A, (uint256(POOL_A.raw()) << 128) | 2);\n        accounting.lock();\n\n        vm.expectEmit();\n        emit IAccounting.StartJournalId(POOL_A, (uint256(POOL_A.raw()) << 128) | 2);\n        accounting.unlock(POOL_A);\n\n        vm.expectEmit();\n        emit IAccounting.EndJournalId(POOL_A, (uint256(POOL_A.raw()) << 128) | 2);\n        accounting.lock();\n\n        vm.expectEmit();\n        emit IAccounting.StartJournalId(POOL_B, (uint256(POOL_B.raw()) << 128) | 1);\n        accounting.unlock(POOL_B);\n\n        vm.expectEmit();\n        emit IAccounting.EndJournalId(POOL_B, (uint256(POOL_B.raw()) << 128) | 1);\n        accounting.lock();\n    }\n}\n"
    },
    "test/hub/unit/Holdings.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {d18} from \"src/misc/types/D18.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {Holdings} from \"src/hub/Holdings.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {AccountType} from \"src/hub/interfaces/IHub.sol\";\nimport {IHoldings, HoldingAccount} from \"src/hub/interfaces/IHoldings.sol\";\n\nPoolId constant POOL_A = PoolId.wrap(42);\nShareClassId constant SC_1 = ShareClassId.wrap(bytes16(\"1\"));\nAssetId constant ASSET_A = AssetId.wrap(2);\nShareClassId constant NON_SC = ShareClassId.wrap(0);\nAssetId constant NON_ASSET = AssetId.wrap(0);\nAssetId constant POOL_CURRENCY = AssetId.wrap(23);\n\ncontract HubRegistryMock {\n    function currency(PoolId) external pure returns (AssetId) {\n        return POOL_CURRENCY;\n    }\n\n    function decimals(PoolId) external pure returns (uint8) {\n        return 2;\n    }\n\n    function decimals(AssetId) external pure returns (uint8) {\n        return 6;\n    }\n}\n\ncontract TestCommon is Test {\n    IHubRegistry immutable hubRegistry = IHubRegistry(address(new HubRegistryMock()));\n    IERC7726 immutable itemValuation = IERC7726(address(23));\n    IERC7726 immutable customValuation = IERC7726(address(42));\n    Holdings holdings = new Holdings(hubRegistry, address(this));\n\n    function mockGetQuote(IERC7726 valuation, uint128 baseAmount, uint128 quoteAmount) public {\n        vm.mockCall(\n            address(valuation),\n            abi.encodeWithSelector(\n                IERC7726.getQuote.selector, uint256(baseAmount), ASSET_A.addr(), POOL_CURRENCY.addr()\n            ),\n            abi.encode(uint256(quoteAmount))\n        );\n    }\n}\n\ncontract TestCreate is TestCommon {\n    function testSuccess() public {\n        HoldingAccount[] memory accounts = new HoldingAccount[](2);\n        accounts[0] = HoldingAccount(AccountId.wrap(0xAA00), 1);\n        accounts[1] = HoldingAccount(AccountId.wrap(0xBB00), 2);\n\n        vm.expectEmit();\n        emit IHoldings.Create(POOL_A, SC_1, ASSET_A, itemValuation, false, accounts);\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, accounts);\n\n        (uint128 amount, uint128 amountValue, IERC7726 valuation, bool isLiability) =\n            holdings.holding(POOL_A, SC_1, ASSET_A);\n\n        assertEq(address(valuation), address(itemValuation));\n        assertEq(amount, 0);\n        assertEq(amountValue, 0);\n        assertEq(isLiability, false);\n\n        assertEq(AccountId.unwrap(holdings.accountId(POOL_A, SC_1, ASSET_A, 1)), 0xAA00);\n        assertEq(AccountId.unwrap(holdings.accountId(POOL_A, SC_1, ASSET_A, 2)), 0xBB00);\n    }\n\n    function testErrNotAuthorized() public {\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n    }\n\n    function testErrWrongValuation() public {\n        vm.expectRevert(IHoldings.WrongValuation.selector);\n        holdings.create(POOL_A, SC_1, ASSET_A, IERC7726(address(0)), false, new HoldingAccount[](0));\n    }\n\n    function testErrWrongShareClass() public {\n        vm.expectRevert(IHoldings.WrongShareClassId.selector);\n        holdings.create(POOL_A, NON_SC, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n    }\n}\n\ncontract TestIncrease is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20_000_000);\n\n        vm.expectEmit();\n        emit IHoldings.Increase(POOL_A, SC_1, ASSET_A, d18(50, 8), 8_000_000, 50_00);\n        uint128 value = holdings.increase(POOL_A, SC_1, ASSET_A, d18(50, 8), 8_000_000);\n        assertEq(value, 50_00);\n\n        (uint128 amount, uint128 amountValue, IERC7726 valuation,) = holdings.holding(POOL_A, SC_1, ASSET_A);\n        assertEq(amount, 28_000_000);\n        assertEq(amountValue, 250_00);\n        assertEq(address(valuation), address(itemValuation)); // Does not change\n    }\n\n    function testErrNotAuthorized() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(1, 1), 0);\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(1, 1), 0);\n    }\n}\n\ncontract TestDecrease is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20_000_000);\n\n        vm.expectEmit();\n        emit IHoldings.Decrease(POOL_A, SC_1, ASSET_A, d18(50, 8), 8_000_000, 50_00);\n        uint128 value = holdings.decrease(POOL_A, SC_1, ASSET_A, d18(50, 8), 8_000_000);\n\n        assertEq(value, 50_00);\n\n        (uint128 amount, uint128 amountValue, IERC7726 valuation,) = holdings.holding(POOL_A, SC_1, ASSET_A);\n        assertEq(amount, 12_000_000);\n        assertEq(amountValue, 150_00);\n        assertEq(address(valuation), address(itemValuation)); // Does not change\n    }\n\n    function testErrNotAuthorized() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        holdings.decrease(POOL_A, SC_1, ASSET_A, d18(1, 1), 0);\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.decrease(POOL_A, SC_1, ASSET_A, d18(1, 1), 0);\n    }\n}\n\ncontract TestUpdate is TestCommon {\n    function testUpdateMore() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20_000_000);\n\n        vm.expectEmit();\n        emit IHoldings.Update(POOL_A, SC_1, ASSET_A, true, 50_00);\n        mockGetQuote(itemValuation, 20_000_000, 250_00);\n        (bool isPositive, uint128 diff) = holdings.update(POOL_A, SC_1, ASSET_A);\n\n        assertEq(diff, 50_00);\n        assert(isPositive);\n\n        (, uint128 amountValue,,) = holdings.holding(POOL_A, SC_1, ASSET_A);\n        assertEq(amountValue, 250_00);\n    }\n\n    function testUpdateLess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20_000_000);\n\n        vm.expectEmit();\n        emit IHoldings.Update(POOL_A, SC_1, ASSET_A, false, 50_00);\n        mockGetQuote(itemValuation, 20_000_000, 150_00);\n\n        (bool isPositive, uint128 diff) = holdings.update(POOL_A, SC_1, ASSET_A);\n\n        assertEq(diff, 50_00);\n        assert(!isPositive);\n\n        (, uint128 amountValue,,) = holdings.holding(POOL_A, SC_1, ASSET_A);\n        assertEq(amountValue, 150_00);\n    }\n\n    function testUpdateEquals() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20_000_000);\n\n        vm.expectEmit();\n        emit IHoldings.Update(POOL_A, SC_1, ASSET_A, true, 0);\n        mockGetQuote(itemValuation, 20_000_000, 200_00);\n        (bool isPositive, uint128 diff) = holdings.update(POOL_A, SC_1, ASSET_A);\n\n        assertEq(diff, 0);\n        assert(isPositive);\n\n        (, uint128 amountValue,,) = holdings.holding(POOL_A, SC_1, ASSET_A);\n        assertEq(amountValue, 200_00);\n    }\n\n    function testErrNotAuthorized() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        holdings.update(POOL_A, SC_1, ASSET_A);\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.update(POOL_A, SC_1, ASSET_A);\n    }\n}\n\ncontract TestUpdateValuation is TestCommon {\n    IERC7726 immutable newValuation = IERC7726(address(42));\n\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.expectEmit();\n        emit IHoldings.UpdateValuation(POOL_A, SC_1, ASSET_A, newValuation);\n        holdings.updateValuation(POOL_A, SC_1, ASSET_A, newValuation);\n\n        assertEq(address(holdings.valuation(POOL_A, SC_1, ASSET_A)), address(newValuation));\n    }\n\n    function testErrNotAuthorized() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        holdings.updateValuation(POOL_A, SC_1, ASSET_A, newValuation);\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.updateValuation(POOL_A, SC_1, ASSET_A, newValuation);\n    }\n}\n\ncontract TestSetAccountId is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.expectEmit();\n        emit IHoldings.SetAccountId(POOL_A, SC_1, ASSET_A, 1, AccountId.wrap(0xAA00));\n        holdings.setAccountId(POOL_A, SC_1, ASSET_A, 1, AccountId.wrap(0xAA00));\n\n        assertEq(AccountId.unwrap(holdings.accountId(POOL_A, SC_1, ASSET_A, 1)), 0xAA00);\n    }\n\n    function testErrNotAuthorized() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        holdings.setAccountId(POOL_A, SC_1, ASSET_A, 1, AccountId.wrap(0xAA00));\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.setAccountId(POOL_A, SC_1, ASSET_A, 1, AccountId.wrap(0xAA00));\n    }\n}\n\ncontract TestValue is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20_000_000);\n\n        uint128 value = holdings.value(POOL_A, SC_1, ASSET_A);\n\n        assertEq(value, 200_00);\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.value(POOL_A, SC_1, ASSET_A);\n    }\n}\n\ncontract TestAmount is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n        holdings.increase(POOL_A, SC_1, ASSET_A, d18(200, 20), 20);\n\n        uint128 value = holdings.amount(POOL_A, SC_1, ASSET_A);\n\n        assertEq(value, 20);\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.amount(POOL_A, SC_1, ASSET_A);\n    }\n}\n\ncontract TestValuation is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        IERC7726 valuation = holdings.valuation(POOL_A, SC_1, ASSET_A);\n\n        assertEq(address(valuation), address(itemValuation));\n    }\n\n    function testErrHoldingNotFound() public {\n        vm.expectRevert(IHoldings.HoldingNotFound.selector);\n        holdings.valuation(POOL_A, SC_1, ASSET_A);\n    }\n}\n\ncontract TestExists is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, false, new HoldingAccount[](0));\n\n        assert(holdings.exists(POOL_A, SC_1, ASSET_A));\n        assert(!holdings.exists(POOL_A, SC_1, POOL_CURRENCY));\n    }\n}\n\ncontract TestLiability is TestCommon {\n    function testSuccess() public {\n        holdings.create(POOL_A, SC_1, ASSET_A, itemValuation, true, new HoldingAccount[](0));\n\n        assert(holdings.isLiability(POOL_A, SC_1, ASSET_A));\n    }\n}\n"
    },
    "test/hub/unit/Hub.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {D18} from \"src/misc/types/D18.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {IHoldings} from \"src/hub/interfaces/IHoldings.sol\";\nimport {IAccounting, JournalEntry} from \"src/hub/interfaces/IAccounting.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\nimport {IHub} from \"src/hub/interfaces/IHub.sol\";\nimport {Hub} from \"src/hub/Hub.sol\";\n\ncontract TestCommon is Test {\n    uint16 constant CHAIN_A = 23;\n    PoolId constant POOL_A = PoolId.wrap(1);\n    ShareClassId constant SC_A = ShareClassId.wrap(bytes16(uint128(2)));\n    AssetId constant ASSET_A = AssetId.wrap(3);\n    address constant ADMIN = address(1);\n    JournalEntry[] EMPTY;\n\n    IHubRegistry immutable hubRegistry = IHubRegistry(makeAddr(\"HubRegistry\"));\n    IHoldings immutable holdings = IHoldings(makeAddr(\"Holdings\"));\n    IAccounting immutable accounting = IAccounting(makeAddr(\"Accounting\"));\n    IShareClassManager immutable scm = IShareClassManager(makeAddr(\"ShareClassManager\"));\n    IGateway immutable gateway = IGateway(makeAddr(\"Gateway\"));\n\n    Hub hub = new Hub(scm, hubRegistry, accounting, holdings, gateway, address(this));\n\n    function setUp() public {\n        vm.mockCall(\n            address(hubRegistry), abi.encodeWithSelector(hubRegistry.manager.selector, POOL_A, ADMIN), abi.encode(true)\n        );\n\n        vm.mockCall(address(accounting), abi.encodeWithSelector(accounting.unlock.selector, POOL_A), abi.encode(true));\n\n        vm.mockCall(address(gateway), abi.encodeWithSelector(gateway.startBatching.selector), abi.encode());\n        vm.mockCall(address(gateway), abi.encodeWithSelector(gateway.endBatching.selector), abi.encode());\n        vm.mockCall(address(gateway), abi.encodeWithSelector(gateway.isBatching.selector), abi.encode(true));\n    }\n}\n\ncontract TestMainMethodsChecks is TestCommon {\n    function testErrNotAuthotized() public {\n        vm.startPrank(makeAddr(\"noGateway\"));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.registerAsset(AssetId.wrap(0), 0);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.depositRequest(PoolId.wrap(0), ShareClassId.wrap(0), bytes32(0), AssetId.wrap(0), 0);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.redeemRequest(PoolId.wrap(0), ShareClassId.wrap(0), bytes32(0), AssetId.wrap(0), 0);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.cancelDepositRequest(PoolId.wrap(0), ShareClassId.wrap(0), bytes32(0), AssetId.wrap(0));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.cancelRedeemRequest(PoolId.wrap(0), ShareClassId.wrap(0), bytes32(0), AssetId.wrap(0));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.updateHoldingAmount(PoolId.wrap(0), ShareClassId.wrap(0), AssetId.wrap(0), 0, D18.wrap(1), false);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.increaseShareIssuance(PoolId.wrap(0), ShareClassId.wrap(0), 0);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        hub.decreaseShareIssuance(PoolId.wrap(0), ShareClassId.wrap(0), 0);\n\n        vm.stopPrank();\n    }\n\n    function testErrNotManager() public {\n        vm.startPrank(makeAddr(\"noPoolAdmin\"));\n        vm.mockCall(\n            address(hubRegistry),\n            abi.encodeWithSelector(hubRegistry.manager.selector, POOL_A, makeAddr(\"noPoolAdmin\")),\n            abi.encode(false)\n        );\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.notifyPool(POOL_A, 0);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.notifyShareClass(POOL_A, ShareClassId.wrap(0), 0, bytes32(\"\"));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.notifyShareMetadata(POOL_A, ShareClassId.wrap(0), 0);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateShareHook(POOL_A, ShareClassId.wrap(0), 0, bytes32(\"\"));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.notifySharePrice(POOL_A, ShareClassId.wrap(0), 0);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.notifyAssetPrice(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.setPoolMetadata(POOL_A, bytes(\"\"));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateManager(POOL_A, address(0), false);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.addShareClass(POOL_A, \"\", \"\", bytes32(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.approveDeposits(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), 0, 0);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.approveRedeems(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), 0, 0);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.issueShares(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), 0, D18.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.revokeShares(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), 0, D18.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateRestriction(POOL_A, ShareClassId.wrap(0), 0, bytes(\"\"));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateContract(POOL_A, ShareClassId.wrap(0), 0, bytes32(0), bytes(\"\"));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updatePricePerShare(POOL_A, ShareClassId.wrap(0), D18.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.createHolding(\n            POOL_A,\n            ShareClassId.wrap(0),\n            AssetId.wrap(0),\n            IERC7726(address(0)),\n            AccountId.wrap(0),\n            AccountId.wrap(0),\n            AccountId.wrap(0),\n            AccountId.wrap(0)\n        );\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.createLiability(\n            POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), IERC7726(address(0)), AccountId.wrap(0), AccountId.wrap(0)\n        );\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateHoldingValue(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateHoldingValuation(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), IERC7726(address(0)));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.setHoldingAccountId(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0), 0, AccountId.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.createAccount(POOL_A, AccountId.wrap(0), false);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.setAccountMetadata(POOL_A, AccountId.wrap(0), bytes(\"\"));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.updateJournal(POOL_A, EMPTY, EMPTY);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.triggerIssueShares(0, POOL_A, ShareClassId.wrap(0), address(0), 0);\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.triggerSubmitQueuedShares(0, POOL_A, ShareClassId.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.triggerSubmitQueuedAssets(POOL_A, ShareClassId.wrap(0), AssetId.wrap(0));\n\n        vm.expectRevert(IHub.NotManager.selector);\n        hub.setQueue(0, POOL_A, ShareClassId.wrap(0), true);\n\n        vm.stopPrank();\n    }\n}\n\ncontract TestNotifyShareClass is TestCommon {\n    function testErrShareClassNotFound() public {\n        vm.mockCall(address(scm), abi.encodeWithSelector(scm.exists.selector, POOL_A, SC_A), abi.encode(false));\n\n        vm.prank(ADMIN);\n        vm.expectRevert(IShareClassManager.ShareClassNotFound.selector);\n        hub.notifyShareClass(POOL_A, SC_A, 23, bytes32(\"\"));\n    }\n}\n\ncontract TestCreateHolding is TestCommon {\n    function testErrAssetNotFound() public {\n        vm.mockCall(\n            address(hubRegistry), abi.encodeWithSelector(hubRegistry.isRegistered.selector, ASSET_A), abi.encode(false)\n        );\n\n        vm.prank(ADMIN);\n        vm.expectRevert(IHubRegistry.AssetNotFound.selector);\n        hub.createHolding(\n            POOL_A,\n            SC_A,\n            ASSET_A,\n            IERC7726(address(1)),\n            AccountId.wrap(1),\n            AccountId.wrap(1),\n            AccountId.wrap(1),\n            AccountId.wrap(1)\n        );\n    }\n}\n\ncontract TestCreateLiability is TestCommon {\n    function testErrAssetNotFound() public {\n        vm.mockCall(\n            address(hubRegistry), abi.encodeWithSelector(hubRegistry.isRegistered.selector, ASSET_A), abi.encode(false)\n        );\n\n        bytes[] memory cs = new bytes[](1);\n        cs[0] = abi.encodeWithSelector(\n            hub.createLiability.selector, SC_A, ASSET_A, IERC7726(address(1)), AccountId.wrap(1), AccountId.wrap(1)\n        );\n\n        vm.prank(ADMIN);\n        vm.expectRevert(IHubRegistry.AssetNotFound.selector);\n        hub.createLiability(POOL_A, SC_A, ASSET_A, IERC7726(address(1)), AccountId.wrap(1), AccountId.wrap(1));\n    }\n}\n"
    },
    "test/hub/unit/HubRegistry.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {PoolId, newPoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {HubRegistry} from \"src/hub/HubRegistry.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\n\ncontract HubRegistryTest is Test {\n    using MathLib for uint256;\n\n    HubRegistry registry;\n\n    uint16 constant CENTRIFUGE_ID = 23;\n    AssetId constant USD = AssetId.wrap(840);\n    ShareClassId constant SC_A = ShareClassId.wrap(bytes16(\"sc\"));\n    PoolId constant POOL_A = PoolId.wrap(33);\n    PoolId constant POOL_B = PoolId.wrap(44);\n\n    IShareClassManager shareClassManager = IShareClassManager(makeAddr(\"shareClassManager\"));\n\n    modifier nonZero(address addr) {\n        vm.assume(addr != address(0));\n        _;\n    }\n\n    modifier notThisContract(address addr) {\n        vm.assume(address(this) != addr);\n        _;\n    }\n\n    function setUp() public {\n        registry = new HubRegistry(address(this));\n    }\n\n    function testPoolRegistration(address fundAdmin) public nonZero(fundAdmin) notThisContract(fundAdmin) {\n        PoolId poolId = registry.poolId(CENTRIFUGE_ID, 1);\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        registry.registerPool(poolId, address(this), USD);\n\n        vm.expectRevert(IHubRegistry.EmptyAccount.selector);\n        registry.registerPool(poolId, address(0), USD);\n\n        vm.expectRevert(IHubRegistry.EmptyCurrency.selector);\n        registry.registerPool(poolId, address(this), AssetId.wrap(0));\n\n        vm.expectEmit();\n        emit IHubRegistry.NewPool(newPoolId(CENTRIFUGE_ID, 1), fundAdmin, USD);\n        registry.registerPool(poolId, fundAdmin, USD);\n\n        assertEq(poolId.centrifugeId(), CENTRIFUGE_ID);\n        assertEq(poolId.raw(), newPoolId(CENTRIFUGE_ID, 1).raw());\n\n        assertTrue(registry.manager(poolId, fundAdmin));\n        assertFalse(registry.manager(poolId, address(this)));\n    }\n\n    function testUpdateManager(address fundAdmin, address additionalAdmin)\n        public\n        nonZero(fundAdmin)\n        nonZero(additionalAdmin)\n        notThisContract(fundAdmin)\n        notThisContract(additionalAdmin)\n    {\n        vm.assume(fundAdmin != additionalAdmin);\n        PoolId poolId = registry.poolId(CENTRIFUGE_ID, 1);\n        registry.registerPool(poolId, fundAdmin, USD);\n\n        assertFalse(registry.manager(poolId, additionalAdmin));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        registry.updateManager(poolId, additionalAdmin, true);\n\n        PoolId nonExistingPool = PoolId.wrap(0xDEAD);\n        vm.expectRevert(abi.encodeWithSelector(IHubRegistry.NonExistingPool.selector, nonExistingPool));\n        registry.updateManager(nonExistingPool, additionalAdmin, true);\n\n        vm.expectRevert(IHubRegistry.EmptyAccount.selector);\n        registry.updateManager(poolId, address(0), true);\n\n        // Approve a new admin\n        vm.expectEmit();\n        emit IHubRegistry.UpdateManager(poolId, additionalAdmin, true);\n        registry.updateManager(poolId, additionalAdmin, true);\n        assertTrue(registry.manager(poolId, additionalAdmin));\n\n        // Remove an existing admin\n        vm.expectEmit();\n        emit IHubRegistry.UpdateManager(poolId, additionalAdmin, false);\n        registry.updateManager(poolId, additionalAdmin, false);\n        assertFalse(registry.manager(poolId, additionalAdmin));\n    }\n\n    function testSetMetadata(bytes calldata metadata) public {\n        address fundAdmin = makeAddr(\"fundAdmin\");\n\n        PoolId poolId = registry.poolId(CENTRIFUGE_ID, 1);\n        registry.registerPool(poolId, fundAdmin, USD);\n\n        assertEq(registry.metadata(poolId).length, 0);\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        registry.setMetadata(poolId, metadata);\n\n        PoolId nonExistingPool = PoolId.wrap(0xDEAD);\n        vm.expectRevert(abi.encodeWithSelector(IHubRegistry.NonExistingPool.selector, nonExistingPool));\n        registry.setMetadata(nonExistingPool, metadata);\n\n        vm.expectEmit();\n        emit IHubRegistry.SetMetadata(poolId, metadata);\n        registry.setMetadata(poolId, metadata);\n        assertEq(registry.metadata(poolId), metadata);\n    }\n\n    function testUpdateDependency(bytes32 what, address dependency) public nonZero(dependency) {\n        assertEq(address(registry.dependency(what)), address(0));\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        registry.updateDependency(what, dependency);\n\n        vm.expectEmit();\n        emit IHubRegistry.UpdateDependency(what, dependency);\n        registry.updateDependency(what, dependency);\n        assertEq(address(registry.dependency(what)), address(dependency));\n    }\n\n    function testUpdateCurrency(AssetId currency) public nonZero(currency.addr()) {\n        address fundAdmin = makeAddr(\"fundAdmin\");\n\n        PoolId poolId = registry.poolId(CENTRIFUGE_ID, 1);\n        registry.registerPool(poolId, fundAdmin, USD);\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        registry.updateCurrency(poolId, currency);\n\n        PoolId nonExistingPool = PoolId.wrap(0xDEAD);\n        vm.expectRevert(abi.encodeWithSelector(IHubRegistry.NonExistingPool.selector, nonExistingPool));\n        registry.updateCurrency(nonExistingPool, currency);\n\n        vm.expectRevert(IHubRegistry.EmptyCurrency.selector);\n        registry.updateCurrency(poolId, AssetId.wrap(0));\n\n        vm.assume(AssetId.unwrap(registry.currency(poolId)) != AssetId.unwrap(currency));\n        vm.expectEmit();\n        emit IHubRegistry.UpdateCurrency(poolId, currency);\n        registry.updateCurrency(poolId, currency);\n        assertEq(AssetId.unwrap(registry.currency(poolId)), AssetId.unwrap(currency));\n    }\n\n    function testExists() public {\n        PoolId poolId = registry.poolId(CENTRIFUGE_ID, 1);\n        registry.registerPool(poolId, makeAddr(\"fundManager\"), USD);\n        assertEq(registry.exists(poolId), true);\n\n        PoolId nonExistingPool = PoolId.wrap(0xDEAD);\n        assertEq(registry.exists(nonExistingPool), false);\n    }\n}\n"
    },
    "test/hub/unit/ShareClassManager.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\n\nimport {\n    IShareClassManager,\n    EpochInvestAmounts,\n    EpochRedeemAmounts,\n    UserOrder,\n    ShareClassMetadata,\n    ShareClassMetrics,\n    QueuedOrder,\n    RequestType\n} from \"src/hub/interfaces/IShareClassManager.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\nimport {IHubRegistry} from \"src/hub/interfaces/IHubRegistry.sol\";\nimport {ShareClassManager} from \"src/hub/ShareClassManager.sol\";\n\nuint64 constant POOL_ID = 42;\nuint32 constant SC_ID_INDEX = 1;\nShareClassId constant SC_ID = ShareClassId.wrap(bytes16((uint128(POOL_ID) << 64) + SC_ID_INDEX));\naddress constant POOL_CURRENCY = address(840);\nAssetId constant USDC = AssetId.wrap(69);\nAssetId constant OTHER_STABLE = AssetId.wrap(1337);\nuint8 constant DECIMALS_USDC = 6;\nuint8 constant DECIMALS_OTHER_STABLE = 12;\nuint8 constant DECIMALS_POOL = 18;\nuint128 constant DENO_USDC = uint128(10 ** DECIMALS_USDC);\nuint128 constant DENO_OTHER_STABLE = uint128(10 ** DECIMALS_OTHER_STABLE);\nuint128 constant DENO_POOL = uint128(10 ** DECIMALS_POOL);\nuint128 constant OTHER_STABLE_PER_POOL = 100;\nuint128 constant MIN_REQUEST_AMOUNT_USDC = DENO_USDC;\nuint128 constant MAX_REQUEST_AMOUNT_USDC = 1e18;\nuint128 constant MIN_REQUEST_AMOUNT_SHARES = DENO_POOL;\nuint128 constant MAX_REQUEST_AMOUNT_SHARES = type(uint128).max / 1e10;\nstring constant SC_NAME = \"ExampleName\";\nstring constant SC_SYMBOL = \"ExampleSymbol\";\nbytes32 constant SC_SALT = bytes32(\"ExampleSalt\");\nbytes32 constant SC_SECOND_SALT = bytes32(\"AnotherExampleSalt\");\n\nuint32 constant STORAGE_INDEX_METRICS = 3;\n\ncontract HubRegistryMock {\n    function currency(PoolId) external pure returns (AssetId) {\n        return AssetId.wrap(uint64(uint160(POOL_CURRENCY)));\n    }\n\n    function decimals(PoolId) external pure returns (uint8) {\n        return DECIMALS_POOL;\n    }\n\n    function decimals(AssetId assetId) external pure returns (uint8) {\n        if (assetId.eq(USDC)) {\n            return DECIMALS_USDC;\n        } else if (assetId.eq(OTHER_STABLE)) {\n            return DECIMALS_OTHER_STABLE;\n        } else {\n            revert(\"IHubRegistry.decimals() - Unknown assetId\");\n        }\n    }\n}\n\nabstract contract ShareClassManagerBaseTest is Test {\n    using MathLib for uint128;\n    using MathLib for uint256;\n    using CastLib for string;\n    using PricingLib for *;\n\n    ShareClassManager public shareClass;\n\n    address hubRegistryMock = address(new HubRegistryMock());\n\n    PoolId poolId = PoolId.wrap(POOL_ID);\n    ShareClassId scId = SC_ID;\n    bytes32 investor = bytes32(\"investor\");\n\n    modifier notThisContract(address addr) {\n        vm.assume(address(this) != addr);\n        _;\n    }\n\n    function setUp() public virtual {\n        shareClass = new ShareClassManager(IHubRegistry(hubRegistryMock), address(this));\n\n        vm.expectEmit();\n        emit IShareClassManager.AddShareClass(poolId, scId, SC_ID_INDEX, SC_NAME, SC_SYMBOL, SC_SALT);\n        shareClass.addShareClass(poolId, SC_NAME, SC_SYMBOL, SC_SALT);\n\n        assertEq(IHubRegistry(hubRegistryMock).currency(poolId).addr(), POOL_CURRENCY);\n        assertEq(IHubRegistry(hubRegistryMock).decimals(poolId), DECIMALS_POOL);\n        assertEq(IHubRegistry(hubRegistryMock).decimals(USDC), DECIMALS_USDC);\n        assertEq(IHubRegistry(hubRegistryMock).decimals(OTHER_STABLE), DECIMALS_OTHER_STABLE);\n    }\n\n    function _intoPoolAmount(AssetId assetId, uint128 amount) internal view returns (uint128) {\n        return PricingLib.convertWithPrice(\n            amount,\n            IHubRegistry(hubRegistryMock).decimals(assetId),\n            IHubRegistry(hubRegistryMock).decimals(poolId),\n            _pricePoolPerAsset(assetId)\n        ).toUint128();\n    }\n\n    function _intoAssetAmount(AssetId assetId, uint128 amount) internal view returns (uint128) {\n        return PricingLib.convertWithPrice(\n            amount,\n            IHubRegistry(hubRegistryMock).decimals(poolId),\n            IHubRegistry(hubRegistryMock).decimals(assetId),\n            _pricePoolPerAsset(assetId).reciprocal()\n        ).toUint128();\n    }\n\n    function _calcSharesIssued(AssetId assetId, uint128 depositAmountAsset, D18 pricePoolPerShare)\n        internal\n        view\n        returns (uint128)\n    {\n        return pricePoolPerShare.reciprocalMulUint256(\n            PricingLib.convertWithPrice(\n                depositAmountAsset,\n                IHubRegistry(hubRegistryMock).decimals(assetId),\n                IHubRegistry(hubRegistryMock).decimals(poolId),\n                _pricePoolPerAsset(assetId)\n            ),\n            MathLib.Rounding.Down\n        ).toUint128();\n    }\n\n    function _pricePoolPerAsset(AssetId assetId) internal pure returns (D18) {\n        if (assetId.eq(USDC)) {\n            return d18(1, 1);\n        } else if (assetId.eq(OTHER_STABLE)) {\n            return d18(1, OTHER_STABLE_PER_POOL);\n        } else {\n            revert(\"ShareClassManagerBaseTest._priceAssetPerPool() - Unknown assetId\");\n        }\n    }\n\n    function _assertDepositRequestEq(AssetId asset, bytes32 investor_, UserOrder memory expected) internal view {\n        (uint128 pending, uint32 lastUpdate) = shareClass.depositRequest(scId, asset, investor_);\n\n        assertEq(pending, expected.pending, \"Mismatch: Deposit UserOrder.pending\");\n        assertEq(lastUpdate, expected.lastUpdate, \"Mismatch: Deposit UserOrder.lastUpdate\");\n    }\n\n    function _assertQueuedDepositRequestEq(AssetId asset, bytes32 investor_, QueuedOrder memory expected)\n        internal\n        view\n    {\n        (bool isCancelling, uint128 amount) = shareClass.queuedDepositRequest(scId, asset, investor_);\n\n        assertEq(isCancelling, expected.isCancelling, \"isCancelling deposit mismatch\");\n        assertEq(amount, expected.amount, \"amount deposit mismatch\");\n    }\n\n    function _assertRedeemRequestEq(AssetId asset, bytes32 investor_, UserOrder memory expected) internal view {\n        (uint128 pending, uint32 lastUpdate) = shareClass.redeemRequest(scId, asset, investor_);\n\n        assertEq(pending, expected.pending, \"Mismatch: Redeem UserOrder.pending\");\n        assertEq(lastUpdate, expected.lastUpdate, \"Mismatch: Redeem UserOrder.lastUpdate\");\n    }\n\n    function _assertQueuedRedeemRequestEq(AssetId asset, bytes32 investor_, QueuedOrder memory expected)\n        internal\n        view\n    {\n        (bool isCancelling, uint128 amount) = shareClass.queuedRedeemRequest(scId, asset, investor_);\n\n        assertEq(isCancelling, expected.isCancelling, \"isCancelling deposit mismatch\");\n        assertEq(amount, expected.amount, \"amount deposit mismatch\");\n    }\n\n    function _assertEpochInvestAmountsEq(AssetId assetId, uint32 epochId, EpochInvestAmounts memory expected)\n        internal\n        view\n    {\n        (\n            uint128 pendingAssetAmount,\n            uint128 approvedAssetAmount,\n            uint128 approvedPoolAmount,\n            D18 pricePoolPerAsset,\n            D18 navPoolPerShare,\n            uint64 issuedAt\n        ) = shareClass.epochInvestAmounts(scId, assetId, epochId);\n\n        assertEq(pendingAssetAmount, expected.pendingAssetAmount, \"Mismatch: EpochInvestAmount.pendingAssetAmount\");\n        assertEq(approvedAssetAmount, expected.approvedAssetAmount, \"Mismatch: EpochInvestAmount.approvedAssetAmount\");\n        assertEq(approvedPoolAmount, expected.approvedPoolAmount, \"Mismatch: EpochInvestAmount.approvedPoolAmount\");\n        assertEq(\n            pricePoolPerAsset.raw(), expected.pricePoolPerAsset.raw(), \"Mismatch: EpochInvestAmount.pricePoolPerAsset\"\n        );\n        assertEq(navPoolPerShare.raw(), expected.navPoolPerShare.raw(), \"Mismatch: EpochInvestAmount.navPoolPerShare\");\n        assertEq(issuedAt, expected.issuedAt, \"Mismatch: EpochInvestAmount.issuedAt\");\n    }\n\n    function _assertEpochRedeemAmountsEq(AssetId assetId, uint32 epochId, EpochRedeemAmounts memory expected)\n        internal\n        view\n    {\n        (\n            uint128 pendingShareAmount,\n            uint128 approvedShareAmount,\n            uint128 payoutAssetAmount,\n            D18 pricePoolPerAsset,\n            D18 navPoolPerShare,\n            uint64 revokedAt\n        ) = shareClass.epochRedeemAmounts(scId, assetId, epochId);\n\n        assertEq(pendingShareAmount, expected.pendingShareAmount, \"Mismatch: EpochRedeemAmount.pendingShareAmount\");\n        assertEq(approvedShareAmount, expected.approvedShareAmount, \"Mismatch: EpochRedeemAmount.approvedShareAmount\");\n        assertEq(payoutAssetAmount, expected.payoutAssetAmount, \"Mismatch: EpochRedeemAmount.payoutAssetAmount\");\n        assertEq(\n            pricePoolPerAsset.raw(), expected.pricePoolPerAsset.raw(), \"Mismatch: EpochRedeemAmount.pricePoolPerAsset\"\n        );\n        assertEq(navPoolPerShare.raw(), expected.navPoolPerShare.raw(), \"Mismatch: EpochRedeemAmount.navPoolPerShare\");\n        assertEq(revokedAt, expected.revokedAt, \"Mismatch: EpochRedeemAmount.issuedAt\");\n    }\n\n    function _mockTotalIssuance(uint128 amount) internal {\n        vm.store(\n            address(shareClass), keccak256(abi.encode(scId, uint256(STORAGE_INDEX_METRICS))), bytes32(uint256(amount))\n        );\n        assertEq(_totalIssuance(), amount);\n    }\n\n    function _totalIssuance() internal view returns (uint128 totalIssuance_) {\n        (totalIssuance_,) = shareClass.metrics(scId);\n    }\n\n    function _nowDeposit(AssetId assetId) internal view returns (uint32) {\n        return shareClass.nowDepositEpoch(scId, assetId);\n    }\n\n    function _nowIssue(AssetId assetId) internal view returns (uint32) {\n        return shareClass.nowIssueEpoch(scId, assetId);\n    }\n\n    function _nowRedeem(AssetId assetId) internal view returns (uint32) {\n        return shareClass.nowRedeemEpoch(scId, assetId);\n    }\n\n    function _nowRevoke(AssetId assetId) internal view returns (uint32) {\n        return shareClass.nowRevokeEpoch(scId, assetId);\n    }\n}\n\n///@dev Contains all simple tests which are expected to succeed\ncontract ShareClassManagerSimpleTest is ShareClassManagerBaseTest {\n    using MathLib for uint128;\n    using CastLib for string;\n\n    function testDeployment(address nonWard) public view {\n        vm.assume(nonWard != address(shareClass.hubRegistry()) && nonWard != address(this));\n\n        assertEq(address(shareClass.hubRegistry()), hubRegistryMock);\n        assertEq(shareClass.nowDepositEpoch(scId, USDC), 1);\n        assertEq(shareClass.nowRedeemEpoch(scId, USDC), 1);\n        assertEq(shareClass.shareClassCount(poolId), 1);\n        assert(shareClass.shareClassIds(poolId, scId));\n\n        assertEq(shareClass.wards(address(this)), 1);\n        assertEq(shareClass.wards(address(shareClass.hubRegistry())), 0);\n\n        assertEq(shareClass.wards(nonWard), 0);\n    }\n\n    function testDefaultGetShareClassNavPerShare() public view {\n        (uint128 totalIssuance, D18 navPerShare) = shareClass.metrics(scId);\n        assertEq(totalIssuance, 0);\n        assertEq(navPerShare.inner(), 0);\n    }\n\n    function testExistence() public view {\n        assert(shareClass.exists(poolId, scId));\n        assert(!shareClass.exists(poolId, ShareClassId.wrap(bytes16(0))));\n    }\n\n    function testDefaultMetadata() public view {\n        (string memory name, string memory symbol, bytes32 salt) = shareClass.metadata(scId);\n\n        assertEq(name, SC_NAME);\n        assertEq(symbol, SC_SYMBOL);\n        assertEq(salt, SC_SALT);\n    }\n\n    function testUpdateMetadata(string memory name, string memory symbol) public {\n        vm.assume(bytes(name).length > 0 && bytes(name).length <= 128);\n        vm.assume(bytes(symbol).length > 0 && bytes(symbol).length <= 32);\n\n        vm.expectEmit();\n        emit IShareClassManager.UpdateMetadata(poolId, scId, name, symbol);\n        shareClass.updateMetadata(poolId, scId, name, symbol);\n\n        (string memory name_, string memory symbol_,) = shareClass.metadata(scId);\n\n        assertEq(name, name_, \"Metadata name mismatch\");\n        assertEq(symbol, symbol_, \"Metadata symbol mismatch\");\n    }\n\n    function testPreviewNextShareClassId() public view {\n        ShareClassId preview = shareClass.previewNextShareClassId(poolId);\n        ShareClassId calc = ShareClassId.wrap(bytes16((uint128(POOL_ID) << 64) + SC_ID_INDEX + 1));\n\n        assertEq(ShareClassId.unwrap(preview), ShareClassId.unwrap(calc));\n    }\n\n    function testAddShareClass(string memory name, string memory symbol, bytes32 salt) public {\n        vm.assume(bytes(name).length > 0 && bytes(name).length <= 128);\n        vm.assume(bytes(symbol).length > 0 && bytes(symbol).length <= 32);\n        vm.assume(salt != bytes32(0));\n        vm.assume(salt != SC_SALT);\n\n        ShareClassId nextScId = shareClass.previewNextShareClassId(poolId);\n\n        emit IShareClassManager.AddShareClass(poolId, nextScId, 2, name, symbol, salt);\n        shareClass.addShareClass(poolId, name, symbol, salt);\n\n        assertEq(shareClass.shareClassCount(poolId), 2);\n        assert(shareClass.shareClassIds(poolId, nextScId));\n        assert(ShareClassId.unwrap(shareClass.previewNextShareClassId(poolId)) != ShareClassId.unwrap(nextScId));\n    }\n\n    function testPreviewShareClassId(uint32 index) public view {\n        assertEq(shareClass.previewShareClassId(poolId, index).raw(), bytes16((uint128(poolId.raw()) << 64) + index));\n    }\n\n    function testUpdatePricePerShare() public {\n        vm.expectEmit();\n        emit IShareClassManager.UpdateShareClass(poolId, scId, d18(2, 1));\n        shareClass.updatePricePerShare(poolId, scId, d18(2, 1));\n    }\n\n    function testIncreaseShareClassIssuance(uint128 amount) public {\n        vm.expectEmit();\n        emit IShareClassManager.RemoteIssueShares(poolId, scId, amount);\n        shareClass.increaseShareClassIssuance(poolId, scId, amount);\n\n        (uint128 totalIssuance_, D18 navPerShareMetric) = shareClass.metrics(scId);\n        assertEq(totalIssuance_, amount);\n        assertEq(navPerShareMetric.inner(), 0, \"navPerShare metric should not be updated\");\n    }\n\n    function testDecreaseShareClassIssuance(uint128 amount) public {\n        shareClass.increaseShareClassIssuance(poolId, scId, amount);\n        vm.expectEmit();\n        emit IShareClassManager.RemoteRevokeShares(poolId, scId, amount);\n        shareClass.decreaseShareClassIssuance(poolId, scId, amount);\n\n        (uint128 totalIssuance_, D18 navPerShareMetric) = shareClass.metrics(scId);\n        assertEq(totalIssuance_, 0, \"TotalIssuance should be reset\");\n        assertEq(navPerShareMetric.inner(), 0, \"navPerShare metric should not be updated\");\n    }\n\n    function testMaxDepositClaims() public {\n        assertEq(shareClass.maxDepositClaims(scId, investor, USDC), 0);\n\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n        assertEq(shareClass.maxDepositClaims(scId, investor, USDC), 0);\n    }\n\n    function testMaxRedeemClaims() public {\n        assertEq(shareClass.maxRedeemClaims(scId, investor, USDC), 0);\n\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n        assertEq(shareClass.maxRedeemClaims(scId, investor, USDC), 0);\n    }\n}\n\n///@dev Contains all deposit related tests which are expected to succeed and don't make use of transient storage\ncontract ShareClassManagerDepositsNonTransientTest is ShareClassManagerBaseTest {\n    using MathLib for *;\n\n    function _deposit(uint128 depositAmountUsdc_, uint128 approvedAmountUsdc_)\n        internal\n        returns (uint128 depositAmountUsdc, uint128 approvedAmountUsdc, uint128 approvedPool)\n    {\n        depositAmountUsdc = uint128(bound(depositAmountUsdc_, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        approvedAmountUsdc = uint128(bound(approvedAmountUsdc_, MIN_REQUEST_AMOUNT_USDC - 1, depositAmountUsdc));\n        approvedPool = _intoPoolAmount(USDC, approvedAmountUsdc);\n\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), approvedAmountUsdc, _pricePoolPerAsset(USDC));\n    }\n\n    function testRequestDeposit(uint128 amount) public {\n        amount = uint128(bound(amount, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n\n        assertEq(shareClass.pendingDeposit(scId, USDC), 0);\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, 0));\n\n        vm.expectEmit();\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, shareClass.nowDepositEpoch(scId, USDC), investor, amount, amount, 0, false\n        );\n        shareClass.requestDeposit(poolId, scId, amount, investor, USDC);\n\n        assertEq(shareClass.pendingDeposit(scId, USDC), amount);\n        _assertDepositRequestEq(USDC, investor, UserOrder(amount, 1));\n    }\n\n    function testCancelDepositRequest(uint128 amount) public {\n        amount = uint128(bound(amount, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        shareClass.requestDeposit(poolId, scId, amount, investor, USDC);\n\n        vm.expectEmit();\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, shareClass.nowDepositEpoch(scId, USDC), investor, 0, 0, 0, false\n        );\n        (uint128 cancelledShares) = shareClass.cancelDepositRequest(poolId, scId, investor, USDC);\n\n        assertEq(cancelledShares, amount);\n        assertEq(shareClass.pendingDeposit(scId, USDC), 0);\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, 1));\n    }\n\n    function testApproveDepositsSingleAssetManyInvestors(\n        uint8 numInvestors,\n        uint128 depositAmount,\n        uint128 approvedUsdc\n    ) public {\n        numInvestors = uint8(bound(numInvestors, 1, 100));\n        depositAmount = uint128(bound(depositAmount, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        approvedUsdc = uint128(bound(approvedUsdc, 1, numInvestors * depositAmount));\n\n        uint128 deposits = 0;\n        for (uint16 i = 0; i < numInvestors; i++) {\n            bytes32 investor = bytes32(uint256(keccak256(abi.encodePacked(\"investor_\", i))));\n            uint128 investorDeposit = depositAmount + i;\n            deposits += investorDeposit;\n            shareClass.requestDeposit(poolId, scId, investorDeposit, investor, USDC);\n\n            assertEq(shareClass.pendingDeposit(scId, USDC), deposits);\n        }\n\n        assertEq(_nowDeposit(USDC), 1);\n\n        vm.expectEmit();\n        emit IShareClassManager.ApproveDeposits(\n            poolId,\n            scId,\n            USDC,\n            _nowDeposit(USDC),\n            _intoPoolAmount(USDC, approvedUsdc),\n            approvedUsdc,\n            deposits - approvedUsdc\n        );\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), approvedUsdc, _pricePoolPerAsset(USDC));\n\n        assertEq(shareClass.pendingDeposit(scId, USDC), deposits - approvedUsdc);\n\n        // Only one epoch should have passed\n        assertEq(_nowDeposit(USDC), 2);\n\n        _assertEpochInvestAmountsEq(\n            USDC,\n            1,\n            EpochInvestAmounts(\n                deposits,\n                approvedUsdc,\n                _intoPoolAmount(USDC, approvedUsdc),\n                _pricePoolPerAsset(USDC),\n                d18(0),\n                0 /* Not yet issued */\n            )\n        );\n    }\n\n    function testApproveDepositsTwoAssetsSameEpoch(uint128 depositAmount, uint128 approvedUSDC) public {\n        uint128 depositAmountUsdc = uint128(bound(depositAmount, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        uint128 depositAmountOther =\n            uint128(bound(depositAmount, MIN_REQUEST_AMOUNT_USDC / 100, MAX_REQUEST_AMOUNT_USDC / 100));\n        uint128 approvedUsdc = uint128(bound(approvedUSDC, MIN_REQUEST_AMOUNT_USDC - 1, depositAmountUsdc));\n        uint128 approvedOtherStable =\n            uint128(bound(approvedUSDC, MIN_REQUEST_AMOUNT_USDC / 100 - 1, depositAmountOther));\n\n        bytes32 investorUsdc = bytes32(\"investorUsdc\");\n        bytes32 investorOther = bytes32(\"investorOther\");\n\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investorUsdc, USDC);\n        shareClass.requestDeposit(poolId, scId, depositAmountOther, investorOther, OTHER_STABLE);\n\n        assertEq(_nowDeposit(USDC), 1);\n        assertEq(_nowDeposit(OTHER_STABLE), 1);\n\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), approvedUsdc, _pricePoolPerAsset(USDC));\n        shareClass.approveDeposits(\n            poolId, scId, OTHER_STABLE, _nowDeposit(OTHER_STABLE), approvedOtherStable, _pricePoolPerAsset(OTHER_STABLE)\n        );\n\n        assertEq(_nowDeposit(USDC), 2);\n        assertEq(_nowDeposit(OTHER_STABLE), 2);\n\n        _assertEpochInvestAmountsEq(\n            USDC,\n            1,\n            EpochInvestAmounts(\n                depositAmountUsdc,\n                approvedUsdc,\n                _intoPoolAmount(USDC, approvedUsdc),\n                _pricePoolPerAsset(USDC),\n                d18(0),\n                0 /* Not yet issued */\n            )\n        );\n        _assertEpochInvestAmountsEq(\n            OTHER_STABLE,\n            1,\n            EpochInvestAmounts(\n                depositAmountOther,\n                approvedOtherStable,\n                _intoPoolAmount(OTHER_STABLE, approvedOtherStable),\n                _pricePoolPerAsset(OTHER_STABLE),\n                d18(0),\n                0 /* Not yet issued */\n            )\n        );\n    }\n\n    function testIssueSharesSingleEpoch(\n        uint128 navPoolPerShare_,\n        uint128 fuzzDepositAmountUsdc,\n        uint128 fuzzApprovedAmountUsdc\n    ) public {\n        D18 navPoolPerShare = d18(uint128(bound(navPoolPerShare_, 1e14, type(uint128).max / 1e18)));\n        (uint128 depositAmountUsdc, uint128 approvedAmountUsdc, uint128 approvedPool) =\n            _deposit(fuzzDepositAmountUsdc, fuzzApprovedAmountUsdc);\n\n        uint128 shares = _calcSharesIssued(USDC, approvedAmountUsdc, navPoolPerShare);\n\n        assertEq(_totalIssuance(), 0, \"Mismatch: totalIssuance\");\n\n        (uint128 issuedShareAmount, uint128 depositAssetAmount, uint128 depositPoolAmount) =\n            shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), navPoolPerShare);\n        assertEq(issuedShareAmount, shares, \"Mismatch: return issuedShareAmount\");\n        assertEq(depositAssetAmount, approvedAmountUsdc, \"Mismatch: return depositAssetAmount\");\n        assertEq(depositPoolAmount, approvedPool, \"Mismatch: return depositPoolAmount\");\n\n        assertEq(_totalIssuance(), shares, \"Mismatch: totalIssuance\");\n\n        _assertEpochInvestAmountsEq(\n            USDC,\n            1,\n            EpochInvestAmounts(\n                depositAmountUsdc,\n                approvedAmountUsdc,\n                _intoPoolAmount(USDC, approvedAmountUsdc),\n                _pricePoolPerAsset(USDC),\n                navPoolPerShare,\n                block.timestamp.toUint64() /* Not yet issued */\n            )\n        );\n    }\n\n    function testClaimDepositZeroApproved() public {\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n        shareClass.requestDeposit(poolId, scId, 10, bytes32(\"investorOther\"), USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), 1, d18(1));\n\n        shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), d18(1));\n\n        vm.expectEmit();\n        emit IShareClassManager.ClaimDeposit(poolId, scId, 1, investor, USDC, 0, 1, 0, block.timestamp.toUint64());\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n    }\n\n    function testFullClaimDepositSingleEpoch() public {\n        uint128 approvedAmountUsdc = 100 * DENO_USDC;\n        uint128 depositAmountUsdc = approvedAmountUsdc;\n        uint128 approvedPool = _intoPoolAmount(USDC, approvedAmountUsdc);\n        assertEq(approvedPool, 100 * DENO_POOL);\n\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), approvedAmountUsdc, _pricePoolPerAsset(USDC));\n\n        vm.expectRevert(IShareClassManager.IssuanceRequired.selector);\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n        D18 navPoolPerShare = d18(11, 10);\n        (uint128 issuedShareAmount,,) = shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), navPoolPerShare);\n\n        vm.expectEmit();\n        emit IShareClassManager.ClaimDeposit(\n            poolId,\n            scId,\n            1,\n            investor,\n            USDC,\n            approvedAmountUsdc,\n            depositAmountUsdc - approvedAmountUsdc,\n            issuedShareAmount,\n            block.timestamp.toUint64()\n        );\n        (uint128 payoutShareAmount, uint128 depositAssetAmount, uint128 cancelledAssetAmount, bool canClaimAgain) =\n            shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n        assertEq(issuedShareAmount, payoutShareAmount, \"Mismatch: payoutShareAmount\");\n        assertEq(approvedAmountUsdc, depositAssetAmount, \"Mismatch: depositAssetAmount\");\n        assertEq(0, cancelledAssetAmount, \"Mismatch: cancelledAssetAmount\");\n        assertEq(false, canClaimAgain, \"Mismatch: canClaimAgain\");\n        assertEq(_totalIssuance(), issuedShareAmount);\n\n        _assertDepositRequestEq(USDC, investor, UserOrder(depositAmountUsdc - approvedAmountUsdc, 2));\n    }\n\n    function testClaimDepositSingleEpoch(\n        uint128 navPoolPerShare_,\n        uint128 fuzzDepositAmountUsdc,\n        uint128 fuzzApprovedAmountUsdc\n    ) public {\n        D18 navPoolPerShare = d18(uint128(bound(navPoolPerShare_, 1e14, type(uint128).max / 1e18)));\n        (uint128 depositAmountUsdc, uint128 approvedAmountUsdc,) =\n            _deposit(fuzzDepositAmountUsdc, fuzzApprovedAmountUsdc);\n\n        vm.expectRevert(IShareClassManager.IssuanceRequired.selector);\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n        (uint128 issuedShareAmount,,) = shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), navPoolPerShare);\n\n        vm.expectEmit();\n        emit IShareClassManager.ClaimDeposit(\n            poolId,\n            scId,\n            1,\n            investor,\n            USDC,\n            approvedAmountUsdc,\n            depositAmountUsdc - approvedAmountUsdc,\n            issuedShareAmount,\n            block.timestamp.toUint64()\n        );\n        (uint128 payoutShareAmount, uint128 depositAssetAmount, uint128 cancelledAssetAmount, bool canClaimAgain) =\n            shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n        assertEq(issuedShareAmount, payoutShareAmount, \"Mismatch: payoutShareAmount\");\n        assertEq(approvedAmountUsdc, depositAssetAmount, \"Mismatch: depositAssetAmount\");\n        assertEq(0, cancelledAssetAmount, \"Mismatch: cancelledAssetAmount\");\n        assertEq(false, canClaimAgain, \"Mismatch: canClaimAgain\");\n        assertEq(_totalIssuance(), issuedShareAmount);\n\n        _assertDepositRequestEq(USDC, investor, UserOrder(depositAmountUsdc - approvedAmountUsdc, 2));\n    }\n\n    function testClaimDepositSkippedEpochsNoPayout(uint8 skippedEpochs) public {\n        vm.assume(skippedEpochs > 0);\n\n        D18 navPoolPerShare = d18(1e18);\n        uint128 approvedAmountUsdc = 1;\n        uint32 lastUpdate = _nowDeposit(USDC);\n\n        // Other investor should eat up the single approved asset amount\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n        shareClass.requestDeposit(poolId, scId, MAX_REQUEST_AMOUNT_USDC, bytes32(\"bigPockets\"), USDC);\n\n        // Approve a few epochs without payout\n        for (uint256 i = 0; i < skippedEpochs; i++) {\n            shareClass.approveDeposits(\n                poolId, scId, USDC, _nowDeposit(USDC), approvedAmountUsdc, _pricePoolPerAsset(USDC)\n            );\n            shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), navPoolPerShare);\n        }\n\n        // Claim all epochs without expected payout due to low deposit amount\n        for (uint256 i = 0; i < skippedEpochs; i++) {\n            vm.expectEmit();\n            emit IShareClassManager.ClaimDeposit(\n                poolId, scId, lastUpdate, investor, USDC, 0, 1, 0, block.timestamp.toUint64()\n            );\n            (uint128 payout, uint128 payment, uint128 cancelled, bool canClaimAgain) =\n                shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n            assertEq(payout, 0, \"Mismatch: payout\");\n            assertEq(payment, 0, \"Mismatch: payment\");\n            assertEq(cancelled, 0, \"Mismatch: cancelled\");\n            assertEq(canClaimAgain, i < skippedEpochs - 1, \"Mismatch: canClaimAgain\");\n            lastUpdate += 1;\n            _assertDepositRequestEq(USDC, investor, UserOrder(1, lastUpdate));\n        }\n    }\n\n    function testClaimDepositSkippedEpochsNothingRemaining(uint128 depositAmountUsdc_, uint8 skippedEpochs) public {\n        vm.assume(skippedEpochs > 0);\n\n        D18 nonZeroPrice = d18(1e18);\n        uint128 depositAmountUsdc = uint128(bound(depositAmountUsdc_, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n\n        // Approve one epoch with full payout and a few subsequent ones without payout\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), depositAmountUsdc, nonZeroPrice);\n        shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), nonZeroPrice);\n\n        // Request deposit with another investors to enable approvals after first epoch\n        shareClass.requestDeposit(poolId, scId, MAX_REQUEST_AMOUNT_USDC, bytes32(\"bigPockets\"), USDC);\n\n        // Approve more epochs which should all be skipped when investor claims first epoch\n        for (uint256 i = 0; i < skippedEpochs; i++) {\n            shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), 1, nonZeroPrice);\n            shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), nonZeroPrice);\n        }\n\n        // Expect only single claim to be required\n        (uint128 payout, uint128 payment, uint128 cancelled, bool canClaimAgain) =\n            shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n        assertNotEq(payout, 0, \"Mismatch: payout\");\n        assertEq(payment, depositAmountUsdc, \"Mismatch: payment\");\n        assertEq(cancelled, 0, \"Mismatch: cancelled\");\n        assertEq(canClaimAgain, false, \"Mismatch: canClaimAgain - all claimed\");\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, 2 + uint32(skippedEpochs)));\n\n        vm.expectRevert(IShareClassManager.NoOrderFound.selector);\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n    }\n\n    function testClaimDepositManyEpochs(uint128 navPoolPerShare_, uint128 depositAmountUsdc_, uint8 epochs) public {\n        D18 poolPerShare = d18(uint128(bound(navPoolPerShare_, 1e10, type(uint128).max / 1e18)));\n        epochs = uint8(bound(epochs, 3, 50));\n        uint128 depositAmountUsdc = uint128(bound(depositAmountUsdc_, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        vm.assume(depositAmountUsdc % epochs == 0);\n\n        uint128 epochApprovedAmountUsdc = depositAmountUsdc / epochs;\n        uint128 totalShares = 0;\n        uint128 totalPayment = 0;\n        uint128 totalPayout = 0;\n\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n\n        // Approve + issue shares for each epoch\n        for (uint256 i = 0; i < epochs; i++) {\n            shareClass.approveDeposits(\n                poolId, scId, USDC, _nowDeposit(USDC), epochApprovedAmountUsdc, _pricePoolPerAsset(USDC)\n            );\n\n            (uint128 issuedShares, uint128 issuedDepositAmountUsdc,) =\n                shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), poolPerShare);\n            totalShares += issuedShares;\n\n            assertEq(issuedDepositAmountUsdc, epochApprovedAmountUsdc, \"Mismatch: issued deposit amount\");\n        }\n\n        assertEq(shareClass.maxDepositClaims(scId, investor, USDC), epochs);\n\n        for (uint256 i = 0; i < epochs; i++) {\n            (uint128 payout, uint128 payment, uint128 cancelled, bool canClaimAgain) =\n                shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n            totalPayout += payout;\n            totalPayment += payment;\n            assertEq(cancelled, 0, \"Mismatch: cancelled\");\n            assertEq(payment, epochApprovedAmountUsdc, \"Mismatch: payment\");\n            assertEq(canClaimAgain, i < epochs - 1, \"Mismatch: canClaimAgain - all claimed\");\n        }\n\n        assertEq(totalPayment, depositAmountUsdc, \"Mismatch: Total payment\");\n        assertEq(totalPayout, totalShares, \"Mismatch: Total payout\");\n\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, epochs + 1));\n    }\n\n    function testQueuedDepositWithoutCancellation(uint128 depositAmountUsdc) public {\n        depositAmountUsdc = uint128(bound(depositAmountUsdc, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC / 3));\n        uint32 epochId = 1;\n        D18 poolPerShare = d18(1, 1);\n        uint128 claimedShares = _calcSharesIssued(USDC, depositAmountUsdc, poolPerShare);\n        uint128 queuedAmount = 0;\n\n        // Initial deposit request\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, queuedAmount));\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        _assertDepositRequestEq(USDC, investor, UserOrder(depositAmountUsdc, epochId));\n        assertEq(shareClass.pendingDeposit(scId, USDC), depositAmountUsdc);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), depositAmountUsdc, _pricePoolPerAsset(USDC));\n        epochId = 2;\n\n        // Expect queued increment due to approval\n        queuedAmount += depositAmountUsdc;\n        vm.expectEmit();\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, epochId, investor, depositAmountUsdc, 0, queuedAmount, false\n        );\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        _assertDepositRequestEq(USDC, investor, UserOrder(queuedAmount, epochId - 1));\n        assertEq(shareClass.pendingDeposit(scId, USDC), 0);\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, queuedAmount));\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n\n        // Expect queued increment due to approval\n        queuedAmount += depositAmountUsdc;\n        vm.expectEmit();\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, epochId, investor, depositAmountUsdc, 0, queuedAmount, false\n        );\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, queuedAmount));\n\n        // Issue shares + claim -> expect queued to move to pending\n        shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), poolPerShare);\n        vm.expectEmit();\n        emit IShareClassManager.ClaimDeposit(\n            poolId, scId, 1, investor, USDC, depositAmountUsdc, 0, claimedShares, block.timestamp.toUint64()\n        );\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, epochId, investor, queuedAmount, queuedAmount, 0, false\n        );\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n\n        _assertDepositRequestEq(USDC, investor, UserOrder(queuedAmount, epochId));\n        assertEq(shareClass.pendingDeposit(scId, USDC), queuedAmount);\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, 0));\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n    }\n\n    function testQueuedDepositWithNonEmptyQueuedCancellation(uint128 depositAmountUsdc) public {\n        vm.assume(depositAmountUsdc % 2 == 0);\n        depositAmountUsdc = uint128(bound(depositAmountUsdc, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        D18 poolPerShare = d18(1, 1);\n        uint128 approvedAssetAmount = depositAmountUsdc / 4;\n        uint128 pendingAssetAmount = depositAmountUsdc - approvedAssetAmount;\n        uint128 issuedShares = _calcSharesIssued(USDC, approvedAssetAmount, poolPerShare);\n        uint128 queuedAmount = 0;\n        uint32 epochId = 1;\n\n        // Initial deposit request\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), approvedAssetAmount, _pricePoolPerAsset(USDC));\n\n        // Expect queued increment due to approval\n        epochId = 2;\n        queuedAmount += depositAmountUsdc;\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        vm.expectEmit();\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, epochId, investor, depositAmountUsdc, pendingAssetAmount, queuedAmount, true\n        );\n        (uint128 cancelledPending) = shareClass.cancelDepositRequest(poolId, scId, investor, USDC);\n        assertEq(cancelledPending, 0, \"Cancellation queued\");\n\n        // Expect revert due to queued cancellation\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.CancellationQueued.selector));\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.CancellationQueued.selector));\n        shareClass.cancelDepositRequest(poolId, scId, investor, USDC);\n\n        // Issue shares + claim -> expect cancel fulfillment\n        shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), poolPerShare);\n        vm.expectEmit();\n        emit IShareClassManager.ClaimDeposit(\n            poolId,\n            scId,\n            1,\n            investor,\n            USDC,\n            approvedAssetAmount,\n            pendingAssetAmount,\n            issuedShares,\n            block.timestamp.toUint64()\n        );\n        emit IShareClassManager.UpdateDepositRequest(poolId, scId, USDC, epochId, investor, 0, 0, 0, false);\n        (uint128 claimedShareAmount, uint128 claimedAssetAmount, uint128 cancelledTotal, bool canClaimAgain) =\n            shareClass.claimDeposit(poolId, scId, investor, USDC);\n        assertEq(claimedShareAmount, issuedShares, \"Claimed share amount mismatch\");\n        assertEq(claimedAssetAmount, approvedAssetAmount, \"Claimed asset amount mismatch\");\n        assertEq(cancelledTotal, pendingAssetAmount + queuedAmount, \"Cancelled amount mismatch\");\n        assertEq(canClaimAgain, false, \"Can claim again mismatch\");\n\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, epochId));\n        assertEq(shareClass.pendingDeposit(scId, USDC), 0, \"Pending deposit mismatch\");\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, 0));\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n    }\n\n    function testQueuedDepositWithEmptyQueuedCancellation(uint128 depositAmountUsdc) public {\n        vm.assume(depositAmountUsdc % 2 == 0);\n        depositAmountUsdc = uint128(bound(depositAmountUsdc, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        D18 poolPerShare = d18(1, 1);\n        uint128 approvedAssetAmount = depositAmountUsdc / 4;\n        uint128 pendingAssetAmount = depositAmountUsdc - approvedAssetAmount;\n        uint128 issuedShares = _calcSharesIssued(USDC, approvedAssetAmount, poolPerShare);\n        uint32 epochId = 1;\n\n        // Initial deposit request\n        shareClass.requestDeposit(poolId, scId, depositAmountUsdc, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, _nowDeposit(USDC), approvedAssetAmount, _pricePoolPerAsset(USDC));\n        epochId = 2;\n\n        // Expect queued increment due to approval\n        vm.expectEmit();\n        emit IShareClassManager.UpdateDepositRequest(\n            poolId, scId, USDC, epochId, investor, depositAmountUsdc, pendingAssetAmount, 0, true\n        );\n        (uint128 cancelledPending) = shareClass.cancelDepositRequest(poolId, scId, investor, USDC);\n        assertEq(cancelledPending, 0, \"Cancellation queued\");\n\n        // Issue shares + claim -> expect cancel fulfillment\n        shareClass.issueShares(poolId, scId, USDC, _nowIssue(USDC), poolPerShare);\n        vm.expectEmit();\n        emit IShareClassManager.ClaimDeposit(\n            poolId,\n            scId,\n            1,\n            investor,\n            USDC,\n            approvedAssetAmount,\n            pendingAssetAmount,\n            issuedShares,\n            block.timestamp.toUint64()\n        );\n        emit IShareClassManager.UpdateDepositRequest(poolId, scId, USDC, epochId, investor, 0, 0, 0, false);\n        (uint128 claimedShareAmount, uint128 claimedAssetAmount, uint128 cancelledTotal, bool canClaimAgain) =\n            shareClass.claimDeposit(poolId, scId, investor, USDC);\n        assertEq(claimedShareAmount, issuedShares, \"Claimed share amount mismatch\");\n        assertEq(claimedAssetAmount, approvedAssetAmount, \"Claimed asset amount mismatch\");\n        assertEq(cancelledTotal, pendingAssetAmount, \"Cancelled amount mismatch\");\n        assertEq(canClaimAgain, false, \"Can claim again mismatch\");\n\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, epochId));\n        assertEq(shareClass.pendingDeposit(scId, USDC), 0, \"Pending deposit mismatch\");\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, 0));\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n    }\n}\n\n///@dev Contains all redeem related tests which are expected to succeed and don't make use of transient storage\ncontract ShareClassManagerRedeemsNonTransientTest is ShareClassManagerBaseTest {\n    using MathLib for *;\n\n    function _redeem(uint128 redeemShares_, uint128 approvedShares_, uint128 navPerShare)\n        internal\n        returns (uint128 redeemShares, uint128 approvedShares, uint128 approvedPool, D18 poolPerShare)\n    {\n        redeemShares = uint128(bound(redeemShares_, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES));\n        approvedShares = uint128(bound(approvedShares_, MIN_REQUEST_AMOUNT_SHARES, redeemShares));\n        poolPerShare = d18(uint128(bound(navPerShare, 1e15, type(uint128).max / 1e18)));\n        approvedPool = poolPerShare.mulUint128(approvedShares, MathLib.Rounding.Down);\n\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), approvedShares, _pricePoolPerAsset(USDC));\n    }\n\n    function testRequestRedeem(uint128 amount) public {\n        amount = uint128(bound(amount, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n\n        assertEq(shareClass.pendingRedeem(scId, USDC), 0);\n        _assertRedeemRequestEq(USDC, investor, UserOrder(0, 0));\n\n        vm.expectEmit();\n        emit IShareClassManager.UpdateRedeemRequest(poolId, scId, USDC, 1, investor, amount, amount, 0, false);\n        shareClass.requestRedeem(poolId, scId, amount, investor, USDC);\n\n        assertEq(shareClass.pendingRedeem(scId, USDC), amount);\n        _assertRedeemRequestEq(USDC, investor, UserOrder(amount, 1));\n    }\n\n    function testCancelRedeemRequest(uint128 amount) public {\n        amount = uint128(bound(amount, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        shareClass.requestRedeem(poolId, scId, amount, investor, USDC);\n\n        vm.expectEmit();\n        emit IShareClassManager.UpdateRedeemRequest(poolId, scId, USDC, 1, investor, 0, 0, 0, false);\n        (uint128 cancelledShares) = shareClass.cancelRedeemRequest(poolId, scId, investor, USDC);\n\n        assertEq(cancelledShares, amount);\n        assertEq(shareClass.pendingRedeem(scId, USDC), 0);\n        _assertRedeemRequestEq(USDC, investor, UserOrder(0, 1));\n    }\n\n    function testApproveRedeemsSingleAssetManyInvestors(\n        uint8 numInvestors,\n        uint128 redeemShares,\n        uint128 approvedShares\n    ) public {\n        numInvestors = uint8(bound(numInvestors, 1, 100));\n        redeemShares = uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES));\n        approvedShares = uint128(bound(approvedShares, MIN_REQUEST_AMOUNT_SHARES, redeemShares));\n\n        uint128 totalRedeem = 0;\n        for (uint16 i = 0; i < numInvestors; i++) {\n            bytes32 investor = bytes32(uint256(keccak256(abi.encodePacked(\"investor_\", i))));\n            uint128 investorRedeem = redeemShares + i;\n            totalRedeem += investorRedeem;\n            shareClass.requestRedeem(poolId, scId, investorRedeem, investor, USDC);\n\n            assertEq(shareClass.pendingRedeem(scId, USDC), totalRedeem);\n        }\n        assertEq(_nowRedeem(USDC), 1);\n\n        uint128 pendingRedeem = totalRedeem - approvedShares;\n\n        vm.expectEmit();\n        emit IShareClassManager.ApproveRedeems(poolId, scId, USDC, 1, approvedShares, pendingRedeem);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), approvedShares, _pricePoolPerAsset(USDC));\n\n        assertEq(shareClass.pendingRedeem(scId, USDC), pendingRedeem);\n\n        // Only one epoch should have passed\n        assertEq(_nowRedeem(USDC), 2);\n\n        _assertEpochRedeemAmountsEq(\n            USDC, 1, EpochRedeemAmounts(totalRedeem, approvedShares, 0, _pricePoolPerAsset(USDC), d18(0), 0)\n        );\n    }\n\n    function testApproveRedeemsTwoAssetsSameEpoch(uint128 redeemShares, uint128 approvedShares) public {\n        uint128 redeemSharesUsdc = uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES));\n        uint128 redeemSharesOther =\n            uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES - 1, MAX_REQUEST_AMOUNT_SHARES - 1));\n        uint128 approvedSharesUsdc = uint128(bound(approvedShares, MIN_REQUEST_AMOUNT_SHARES, redeemSharesUsdc));\n        uint128 approvedSharesOther = uint128(bound(approvedShares, DENO_OTHER_STABLE, redeemSharesOther));\n        bytes32 investorUsdc = bytes32(\"investorUsdc\");\n        bytes32 investorOther = bytes32(\"investorOther\");\n        uint128 pendingUsdc = redeemSharesUsdc - approvedSharesUsdc;\n        uint128 pendingOther = redeemSharesOther - approvedSharesOther;\n\n        shareClass.requestRedeem(poolId, scId, redeemSharesUsdc, investorUsdc, USDC);\n        shareClass.requestRedeem(poolId, scId, redeemSharesOther, investorOther, OTHER_STABLE);\n\n        assertEq(_nowRedeem(USDC), 1);\n        assertEq(_nowRedeem(OTHER_STABLE), 1);\n\n        uint128 pendingUsdc_ = shareClass.approveRedeems(\n            poolId, scId, USDC, _nowRedeem(USDC), approvedSharesUsdc, _pricePoolPerAsset(USDC)\n        );\n        uint128 pendingOther_ = shareClass.approveRedeems(\n            poolId, scId, OTHER_STABLE, _nowRedeem(OTHER_STABLE), approvedSharesOther, _pricePoolPerAsset(OTHER_STABLE)\n        );\n\n        assertEq(_nowRedeem(USDC), 2);\n        assertEq(_nowRedeem(OTHER_STABLE), 2);\n\n        assertEq(pendingUsdc_, pendingUsdc, \"pending shares USDC mismatch\");\n        assertEq(pendingOther_, pendingOther, \"pending shares OtherCurrency mismatch\");\n\n        _assertEpochRedeemAmountsEq(\n            USDC, 1, EpochRedeemAmounts(redeemSharesUsdc, approvedSharesUsdc, 0, _pricePoolPerAsset(USDC), d18(0), 0)\n        );\n        _assertEpochRedeemAmountsEq(\n            OTHER_STABLE,\n            1,\n            EpochRedeemAmounts(redeemSharesOther, approvedSharesOther, 0, _pricePoolPerAsset(OTHER_STABLE), d18(0), 0)\n        );\n    }\n\n    function testRevokeSharesSingleEpoch(uint128 navPerShare, uint128 redeemShares, uint128 approvedShares) public {\n        redeemShares = uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES));\n        approvedShares = uint128(bound(approvedShares, MIN_REQUEST_AMOUNT_SHARES, redeemShares));\n        D18 poolPerShare = d18(uint128(bound(navPerShare, 1e15, type(uint128).max / 1e18)));\n        uint128 poolAmount = poolPerShare.mulUint128(approvedShares, MathLib.Rounding.Down);\n        uint128 assetAmount = _intoAssetAmount(USDC, poolAmount);\n\n        // Mock total issuance to equal redeemShares\n        _mockTotalIssuance(redeemShares);\n\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), approvedShares, _pricePoolPerAsset(USDC));\n\n        assertEq(_totalIssuance(), redeemShares);\n        assertEq(_nowRevoke(USDC), 1);\n\n        (uint128 revokedShares, uint128 revokedAssets, uint128 revokedPool) =\n            shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), poolPerShare);\n        assertEq(approvedShares, revokedShares, \"revoked share amount mismatch\");\n        assertEq(assetAmount, revokedAssets, \"revoked asset amount mismatch\");\n        assertEq(poolAmount, revokedPool, \"revoked pool amount mismatch\");\n\n        assertEq(_totalIssuance(), redeemShares - approvedShares);\n        assertEq(_nowRevoke(USDC), 2);\n    }\n\n    function testRevokeShareExceedsIssuance() public {\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), 1, _pricePoolPerAsset(USDC));\n\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.RevokeMoreThanIssued.selector));\n        shareClass.revokeShares(poolId, scId, USDC, 1, d18(1));\n    }\n\n    function testClaimRedeemZeroApproved() public {\n        _mockTotalIssuance(11);\n\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n        shareClass.requestRedeem(poolId, scId, 10, bytes32(\"investorOther\"), USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), 1, _pricePoolPerAsset(USDC));\n        shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), d18(1));\n\n        vm.expectEmit();\n        emit IShareClassManager.ClaimRedeem(poolId, scId, 1, investor, USDC, 0, 1, 0, block.timestamp.toUint64());\n        shareClass.claimRedeem(poolId, scId, investor, USDC);\n    }\n\n    function testClaimRedeemSingleEpoch(uint128 redeemShares_, uint128 approvedShares_, uint128 navPoolPerShare_)\n        public\n    {\n        (uint128 redeemShares, uint128 approvedShares,, D18 poolPerShare) =\n            _redeem(redeemShares_, approvedShares_, navPoolPerShare_);\n        uint128 pendingShares = redeemShares - approvedShares;\n\n        // Mock total issuance to equal redeemShares\n        _mockTotalIssuance(redeemShares);\n\n        (, uint128 revokedAssets,) = shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), poolPerShare);\n        assertEq(_totalIssuance(), pendingShares);\n        _assertRedeemRequestEq(USDC, investor, UserOrder(redeemShares, 1));\n\n        vm.expectEmit();\n        emit IShareClassManager.ClaimRedeem(\n            poolId, scId, 1, investor, USDC, approvedShares, pendingShares, revokedAssets, block.timestamp.toUint64()\n        );\n        (uint128 claimedAssets, uint128 redeemedShares, uint128 cancelledShares, bool canClaimAgain) =\n            shareClass.claimRedeem(poolId, scId, investor, USDC);\n\n        assertEq(claimedAssets, revokedAssets, \"payout asset amount mismatch\");\n        assertEq(redeemedShares, revokedAssets > 0 ? approvedShares : 0, \"payment shares mismatch\");\n        pendingShares = revokedAssets > 0 ? redeemShares - approvedShares : redeemShares;\n        _assertRedeemRequestEq(USDC, investor, UserOrder(pendingShares, 2));\n        assertEq(cancelledShares, 0, \"no queued cancellation\");\n        assertEq(canClaimAgain, false, \"already claimed up to latest revoked epoch\");\n    }\n\n    function testClaimRedeemSkippedEpochsNoPayout(uint8 skippedEpochs) public {\n        vm.assume(skippedEpochs > 0);\n\n        D18 navPoolPerShare = d18(1e18);\n        uint128 approvedShares = 1;\n        uint32 lastUpdate = _nowRedeem(USDC);\n\n        // Other investor should eat up the single approved asset amount\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n        shareClass.requestRedeem(poolId, scId, MAX_REQUEST_AMOUNT_SHARES, bytes32(\"bigPockets\"), USDC);\n        _mockTotalIssuance(MAX_REQUEST_AMOUNT_SHARES + 1);\n\n        // Approve a few epochs without payout\n        for (uint256 i = 0; i < skippedEpochs; i++) {\n            shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), approvedShares, _pricePoolPerAsset(USDC));\n            shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), navPoolPerShare);\n        }\n\n        // Claim all epochs without expected payout due to low redeem amount\n        for (uint256 i = 0; i < skippedEpochs; i++) {\n            vm.expectEmit();\n            emit IShareClassManager.ClaimRedeem(\n                poolId, scId, lastUpdate, investor, USDC, 0, 1, 0, block.timestamp.toUint64()\n            );\n            (uint128 payout, uint128 payment, uint128 cancelled, bool canClaimAgain) =\n                shareClass.claimRedeem(poolId, scId, investor, USDC);\n\n            assertEq(payout, 0, \"Mismatch: payout\");\n            assertEq(payment, 0, \"Mismatch: payment\");\n            assertEq(cancelled, 0, \"Mismatch: cancelled\");\n            assertEq(canClaimAgain, i < skippedEpochs - 1, \"Mismatch: canClaimAgain\");\n            lastUpdate += 1;\n            _assertRedeemRequestEq(USDC, investor, UserOrder(1, lastUpdate));\n        }\n    }\n\n    function testClaimRedeemSkippedEpochsNothingRemaining(uint128 amount, uint8 skippedEpochs) public {\n        vm.assume(skippedEpochs > 0);\n\n        D18 nonZeroPrice = d18(1e18);\n        uint128 redeemShares = uint128(bound(amount, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES));\n        _mockTotalIssuance(redeemShares + MAX_REQUEST_AMOUNT_USDC);\n\n        // Other investor should eat up the single approved asset amount\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), redeemShares, nonZeroPrice);\n        shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), nonZeroPrice);\n\n        // Request redeem with another investors to enable approvals after first epoch\n        shareClass.requestRedeem(poolId, scId, MAX_REQUEST_AMOUNT_USDC, bytes32(\"bigPockets\"), USDC);\n\n        // Approve more epochs which should all be skipped when investor claims first epoch\n        for (uint256 i = 0; i < skippedEpochs; i++) {\n            shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), 1, nonZeroPrice);\n            shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), nonZeroPrice);\n        }\n\n        // Expect only single claim to be required\n        (uint128 payout, uint128 payment, uint128 cancelled, bool canClaimAgain) =\n            shareClass.claimRedeem(poolId, scId, investor, USDC);\n\n        assertNotEq(payout, 0, \"Mismatch: payout\");\n        assertEq(payment, redeemShares, \"Mismatch: payment\");\n        assertEq(cancelled, 0, \"Mismatch: cancelled\");\n        assertEq(canClaimAgain, false, \"Mismatch: canClaimAgain\");\n        _assertRedeemRequestEq(USDC, investor, UserOrder(0, 2 + uint32(skippedEpochs)));\n    }\n\n    function testClaimRedeemManyEpochs(uint128 navPoolPerShare_, uint128 totalRedeemShares_, uint8 epochs) public {\n        D18 poolPerShare = d18(uint128(bound(navPoolPerShare_, 1e15, type(uint128).max / 1e18)));\n        epochs = uint8(bound(epochs, 3, 50));\n        uint128 totalRedeemShares =\n            uint128(bound(totalRedeemShares_, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES));\n        vm.assume(totalRedeemShares % epochs == 0);\n\n        uint128 epochApprovedShares = totalRedeemShares / epochs;\n        uint128 totalAssets = 0;\n        uint128 totalPayment = 0;\n        uint128 totalPayout = 0;\n\n        _mockTotalIssuance(totalRedeemShares);\n\n        shareClass.requestRedeem(poolId, scId, totalRedeemShares, investor, USDC);\n\n        // Approve + revoke shares for each epoch\n        for (uint256 i = 0; i < epochs; i++) {\n            shareClass.approveRedeems(\n                poolId, scId, USDC, _nowRedeem(USDC), epochApprovedShares, _pricePoolPerAsset(USDC)\n            );\n\n            (uint128 revokedShares, uint128 revokedAssetAmount,) =\n                shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), poolPerShare);\n            totalAssets += revokedAssetAmount;\n            assertEq(revokedShares, epochApprovedShares, \"Mismatch: revoked shares\");\n        }\n\n        assertEq(shareClass.maxRedeemClaims(scId, investor, USDC), epochs);\n\n        for (uint256 i = 0; i < epochs; i++) {\n            (uint128 payout, uint128 payment, uint128 cancelled, bool canClaimAgain) =\n                shareClass.claimRedeem(poolId, scId, investor, USDC);\n\n            totalPayout += payout;\n            totalPayment += payment;\n            assertEq(cancelled, 0, \"Mismatch: cancelled\");\n            assertEq(payment, epochApprovedShares, \"Mismatch: payment\");\n            assertEq(canClaimAgain, i < epochs - 1, \"Mismatch: canClaimAgain - all claimed\");\n        }\n\n        assertEq(totalPayment, totalRedeemShares, \"Mismatch: Total payment\");\n        assertEq(totalPayout, totalAssets, \"Mismatch: Total payout\");\n\n        _assertRedeemRequestEq(USDC, investor, UserOrder(0, epochs + 1));\n    }\n\n    function testQueuedRedeemWithoutCancellation(uint128 redeemShares) public {\n        redeemShares = uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES / 3));\n        D18 poolPerShare = d18(1, 1);\n        uint128 poolAmount = poolPerShare.mulUint128(redeemShares, MathLib.Rounding.Down);\n        uint128 claimedAssetAmount = _intoAssetAmount(USDC, poolAmount);\n        uint128 approvedShares = redeemShares;\n        uint128 pendingShareAmount = 0;\n        uint128 queuedAmount = 0;\n        uint32 epochId = 1;\n\n        // Mock total issuance to equal total approved redeem redeemShares\n        _mockTotalIssuance(redeemShares);\n\n        // Initial deposit request\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, queuedAmount));\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        _assertRedeemRequestEq(USDC, investor, UserOrder(redeemShares, epochId));\n        assertEq(shareClass.pendingRedeem(scId, USDC), redeemShares);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), redeemShares, _pricePoolPerAsset(USDC));\n        assertEq(shareClass.pendingRedeem(scId, USDC), 0);\n        epochId = 2;\n\n        // Expect queued increment due to approval\n        queuedAmount += redeemShares;\n        vm.expectEmit();\n        emit IShareClassManager.UpdateRedeemRequest(\n            poolId, scId, USDC, epochId, investor, approvedShares, pendingShareAmount, queuedAmount, false\n        );\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        _assertRedeemRequestEq(USDC, investor, UserOrder(queuedAmount, epochId - 1));\n        assertEq(shareClass.pendingRedeem(scId, USDC), 0);\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, queuedAmount));\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, 0));\n\n        // Expect queued increment due to approval\n        queuedAmount += redeemShares;\n        vm.expectEmit();\n        emit IShareClassManager.UpdateRedeemRequest(\n            poolId, scId, USDC, epochId, investor, redeemShares, 0, queuedAmount, false\n        );\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, queuedAmount));\n\n        // Issue shares + claim -> expect queued to move to pending\n        shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), poolPerShare);\n        pendingShareAmount = queuedAmount;\n        vm.expectEmit();\n        emit IShareClassManager.ClaimRedeem(\n            poolId, scId, 1, investor, USDC, redeemShares, 0, claimedAssetAmount, block.timestamp.toUint64()\n        );\n        emit IShareClassManager.UpdateRedeemRequest(\n            poolId, scId, USDC, epochId, investor, pendingShareAmount, pendingShareAmount, 0, false\n        );\n        shareClass.claimRedeem(poolId, scId, investor, USDC);\n\n        _assertRedeemRequestEq(USDC, investor, UserOrder(pendingShareAmount, epochId));\n        assertEq(shareClass.pendingRedeem(scId, USDC), pendingShareAmount, \"pending redeem mismatch\");\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n        _assertQueuedDepositRequestEq(USDC, investor, QueuedOrder(false, 0));\n    }\n\n    function testQueuedRedeemWithNonEmptyQueuedCancellation(uint128 redeemShares) public {\n        vm.assume(redeemShares % 2 == 0);\n        redeemShares = uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES / 2));\n        D18 poolPerShare = d18(1, 1);\n        uint128 approvedShares = redeemShares / 4;\n        uint128 pendingShareAmount = redeemShares - approvedShares;\n        uint128 poolAmount = poolPerShare.mulUint128(approvedShares, MathLib.Rounding.Down);\n        uint128 revokedAssetAmount = _intoAssetAmount(USDC, poolAmount);\n        uint128 queuedAmount = 0;\n        uint32 epochId = 1;\n\n        // Mock total issuance to equal total approved redeem redeemShares\n        _mockTotalIssuance(approvedShares);\n\n        // Initial deposit request\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), approvedShares, _pricePoolPerAsset(USDC));\n        epochId = 2;\n\n        // Expect queued increment due to approval\n        queuedAmount += redeemShares;\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        vm.expectEmit();\n        emit IShareClassManager.UpdateRedeemRequest(\n            poolId, scId, USDC, epochId, investor, redeemShares, pendingShareAmount, queuedAmount, true\n        );\n        (uint128 cancelledPending) = shareClass.cancelRedeemRequest(poolId, scId, investor, USDC);\n        assertEq(cancelledPending, 0, \"Cancellation queued\");\n\n        // Expect revert due to queued cancellation\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.CancellationQueued.selector));\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.CancellationQueued.selector));\n        shareClass.cancelRedeemRequest(poolId, scId, investor, USDC);\n\n        // Issue shares + claim -> expect cancel fulfillment\n        shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), poolPerShare);\n        vm.expectEmit();\n        emit IShareClassManager.ClaimRedeem(\n            poolId,\n            scId,\n            1,\n            investor,\n            USDC,\n            approvedShares,\n            pendingShareAmount,\n            revokedAssetAmount,\n            block.timestamp.toUint64()\n        );\n        emit IShareClassManager.UpdateRedeemRequest(poolId, scId, USDC, epochId, investor, 0, 0, 0, false);\n        (uint128 claimedAssetAmount, uint128 claimedShareAmount, uint128 cancelledTotal, bool canClaimAgain) =\n            shareClass.claimRedeem(poolId, scId, investor, USDC);\n        assertEq(claimedAssetAmount, revokedAssetAmount, \"Claimed asset amount mismatch\");\n        assertEq(claimedShareAmount, approvedShares, \"Claimed share amount mismatch\");\n        assertEq(cancelledTotal, pendingShareAmount + queuedAmount, \"Cancelled amount mismatch\");\n        assertEq(canClaimAgain, false, \"Can claim again mismatch\");\n\n        _assertRedeemRequestEq(USDC, investor, UserOrder(0, epochId));\n        assertEq(shareClass.pendingRedeem(scId, USDC), 0, \"Pending deposit mismatch\");\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n    }\n\n    function testQueuedRedeemWithEmptyQueuedCancellation(uint128 redeemShares) public {\n        vm.assume(redeemShares % 2 == 0);\n        redeemShares = uint128(bound(redeemShares, MIN_REQUEST_AMOUNT_SHARES, MAX_REQUEST_AMOUNT_SHARES / 2));\n        D18 poolPerShare = d18(1, 1);\n        uint128 approvedShares = redeemShares / 4;\n        uint128 pendingShareAmount = redeemShares - approvedShares;\n        uint128 poolAmount = poolPerShare.mulUint128(approvedShares, MathLib.Rounding.Down);\n        uint128 revokedAssetAmount = _intoAssetAmount(USDC, poolAmount);\n        uint32 epochId = 1;\n\n        // Mock total issuance to equal total approved redeem redeemShares\n        _mockTotalIssuance(approvedShares);\n\n        // Initial redeem request\n        shareClass.requestRedeem(poolId, scId, redeemShares, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, _nowRedeem(USDC), approvedShares, _pricePoolPerAsset(USDC));\n        epochId = 2;\n\n        // Expect queued increment due to approval\n        vm.expectEmit();\n        emit IShareClassManager.UpdateRedeemRequest(\n            poolId, scId, USDC, epochId, investor, redeemShares, pendingShareAmount, 0, true\n        );\n        (uint128 cancelledPending) = shareClass.cancelRedeemRequest(poolId, scId, investor, USDC);\n        assertEq(cancelledPending, 0, \"Cancellation queued\");\n\n        // Issue shares + claim -> expect cancel fulfillment\n        shareClass.revokeShares(poolId, scId, USDC, _nowRevoke(USDC), poolPerShare);\n        vm.expectEmit();\n        emit IShareClassManager.ClaimRedeem(\n            poolId,\n            scId,\n            1,\n            investor,\n            USDC,\n            approvedShares,\n            pendingShareAmount,\n            revokedAssetAmount,\n            block.timestamp.toUint64()\n        );\n        emit IShareClassManager.UpdateRedeemRequest(poolId, scId, USDC, epochId, investor, 0, 0, 0, false);\n        (uint128 claimedAssetAmount, uint128 claimedShareAmount, uint128 cancelledTotal, bool canClaimAgain) =\n            shareClass.claimRedeem(poolId, scId, investor, USDC);\n        assertEq(claimedAssetAmount, revokedAssetAmount, \"Claimed share amount mismatch\");\n        assertEq(claimedShareAmount, approvedShares, \"Claimed asset amount mismatch\");\n        assertEq(cancelledTotal, pendingShareAmount, \"Cancelled amount mismatch\");\n        assertEq(canClaimAgain, false, \"Can claim again mismatch\");\n\n        _assertRedeemRequestEq(USDC, investor, UserOrder(0, epochId));\n        assertEq(shareClass.pendingRedeem(scId, USDC), 0, \"Pending redeem mismatch\");\n        _assertQueuedRedeemRequestEq(USDC, investor, QueuedOrder(false, 0));\n    }\n}\n\n///@dev Contains all tests which require transient storage to reset between calls\ncontract ShareClassManagerDepositRedeem is ShareClassManagerBaseTest {\n    using MathLib for *;\n\n    function testDepositsWithRedeemsFullFlow(\n        uint128 navPerShare_,\n        uint128 depositRequestUsdc,\n        uint128 redeemRequestShares,\n        uint128 depositApprovedUsdc,\n        uint128 redeemApprovedShares\n    ) public {\n        D18 navPerShareDeposit = d18(uint128(bound(navPerShare_, 1e10, type(uint128).max / 1e18)));\n        D18 navPerShareRedeem = d18(uint128(bound(navPerShare_, 1e10, navPerShareDeposit.inner())));\n        uint128 shares = navPerShareDeposit.reciprocalMulUint128(\n            _intoPoolAmount(USDC, MAX_REQUEST_AMOUNT_USDC), MathLib.Rounding.Down\n        );\n        depositRequestUsdc = uint128(bound(depositRequestUsdc, MIN_REQUEST_AMOUNT_USDC, MAX_REQUEST_AMOUNT_USDC));\n        redeemRequestShares = uint128(bound(redeemRequestShares, MIN_REQUEST_AMOUNT_SHARES, shares));\n        depositApprovedUsdc = uint128(bound(depositRequestUsdc, MIN_REQUEST_AMOUNT_USDC, depositRequestUsdc));\n        redeemApprovedShares = uint128(bound(redeemRequestShares, MIN_REQUEST_AMOUNT_SHARES, redeemRequestShares));\n\n        // Step 1: Do initial deposit flow with 100% deposit approval rate to add sufficient shares for later redemption\n        uint32 epochId = 1;\n        shareClass.requestDeposit(poolId, scId, MAX_REQUEST_AMOUNT_USDC, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, epochId, MAX_REQUEST_AMOUNT_USDC, _pricePoolPerAsset(USDC));\n        shareClass.issueShares(poolId, scId, USDC, epochId, navPerShareDeposit);\n        _assertEpochInvestAmountsEq(\n            USDC,\n            epochId,\n            EpochInvestAmounts(\n                MAX_REQUEST_AMOUNT_USDC,\n                MAX_REQUEST_AMOUNT_USDC,\n                _intoPoolAmount(USDC, MAX_REQUEST_AMOUNT_USDC),\n                _pricePoolPerAsset(USDC),\n                navPerShareDeposit,\n                block.timestamp.toUint64()\n            )\n        );\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n        assertEq(_totalIssuance(), shares, \"1Mismatch in issuance\");\n\n        epochId += 1;\n        _assertDepositRequestEq(USDC, investor, UserOrder(0, epochId));\n\n        // Step 2a: Deposit + redeem at same\n        shareClass.requestDeposit(poolId, scId, depositRequestUsdc, investor, USDC);\n        shareClass.requestRedeem(poolId, scId, redeemRequestShares, investor, USDC);\n        _assertDepositRequestEq(USDC, investor, UserOrder(depositRequestUsdc, epochId));\n        _assertRedeemRequestEq(USDC, investor, UserOrder(redeemRequestShares, epochId - 1));\n\n        // Step 2b: Approve deposits\n        shareClass.approveDeposits(poolId, scId, USDC, epochId, depositApprovedUsdc, _pricePoolPerAsset(USDC));\n\n        // Step 2c: Approve redeems\n        shareClass.approveRedeems(poolId, scId, USDC, epochId - 1, redeemApprovedShares, _pricePoolPerAsset(USDC));\n        _assertDepositRequestEq(USDC, investor, UserOrder(depositRequestUsdc, epochId));\n        _assertRedeemRequestEq(USDC, investor, UserOrder(redeemRequestShares, epochId - 1));\n\n        // Step 2d: Issue shares\n        shareClass.issueShares(poolId, scId, USDC, epochId, navPerShareDeposit);\n        uint128 depositIssuedShares =\n            navPerShareDeposit.reciprocalMulUint128(_intoPoolAmount(USDC, depositRequestUsdc), MathLib.Rounding.Down);\n        shares += depositIssuedShares;\n        assertEq(_totalIssuance(), shares, \"2Mismatch in issuance\");\n\n        // Step 2e: Revoke shares\n        shareClass.revokeShares(poolId, scId, USDC, epochId - 1, navPerShareRedeem);\n        shares -= redeemApprovedShares;\n        (uint128 issuance, D18 navPerShare) = shareClass.metrics(scId);\n        assertEq(issuance, shares, \"Mismatch in metrics issuance\");\n        assertEq(navPerShare.inner(), 0, \"Metrics nav should only be set in updateShareClass\");\n\n        // Step 2f: Claim deposit and redeem\n        epochId += 1;\n        (uint128 depositPayout, uint128 depositPayment,,) = shareClass.claimDeposit(poolId, scId, investor, USDC);\n        (, uint128 redeemPayment,,) = shareClass.claimRedeem(poolId, scId, investor, USDC);\n\n        uint128 pendingDeposit = depositRequestUsdc - depositApprovedUsdc;\n        assertEq(depositPayment, depositApprovedUsdc, \"Mismatch in deposit payment\");\n        assertEq(depositPayout, depositIssuedShares, \"Mismatch in deposit payout\");\n        _assertDepositRequestEq(USDC, investor, UserOrder(pendingDeposit, epochId));\n\n        uint128 pendingRedeem = redeemRequestShares - redeemApprovedShares;\n        assertEq(redeemPayment, redeemApprovedShares, \"Mismatch in redeem payment\");\n        _assertRedeemRequestEq(USDC, investor, UserOrder(pendingRedeem, epochId - 1));\n    }\n}\n\n///@dev Contains all deposit tests which deal with rounding edge cases\ncontract ShareClassManagerRoundingEdgeCasesDeposit is ShareClassManagerBaseTest {\n    using MathLib for uint128;\n\n    uint128 constant MIN_REQUEST_AMOUNT_OTHER_STABLE = DENO_OTHER_STABLE;\n    uint128 constant MAX_REQUEST_AMOUNT_OTHER_STABLE = 1e24;\n    bytes32 constant INVESTOR_A = bytes32(\"investorA\");\n    bytes32 constant INVESTOR_B = bytes32(\"investorB\");\n    bytes32 constant INVESTOR_C = bytes32(\"investorC\");\n\n    function _approveAllDepositsAndIssue(uint128 approvedAssetAmount, uint128 expectedShareIssuance, D18 navPerShare)\n        private\n    {\n        shareClass.approveDeposits(\n            poolId, scId, OTHER_STABLE, _nowDeposit(OTHER_STABLE), approvedAssetAmount, _pricePoolPerAsset(OTHER_STABLE)\n        );\n        shareClass.issueShares(poolId, scId, OTHER_STABLE, _nowIssue(OTHER_STABLE), navPerShare);\n        assertEq(_totalIssuance(), expectedShareIssuance, \"Mismatch in expected shares\");\n    }\n\n    /// @dev Investors cannot claim the single issued share atom (one of smallest denomination of share) but still pay\n    function testClaimDepositSingleShareAtom() public {\n        uint128 approvedAssetAmount = DENO_OTHER_STABLE;\n        uint128 issuedShares = 1;\n        uint128 depositAmountA = 1;\n        uint128 depositAmountB = approvedAssetAmount - depositAmountA;\n        D18 navPerShare = d18(_intoPoolAmount(OTHER_STABLE, approvedAssetAmount), issuedShares);\n\n        shareClass.requestDeposit(poolId, scId, depositAmountA, INVESTOR_A, OTHER_STABLE);\n        shareClass.requestDeposit(poolId, scId, depositAmountB, INVESTOR_B, OTHER_STABLE);\n        _approveAllDepositsAndIssue(approvedAssetAmount, issuedShares, navPerShare);\n\n        (uint128 claimedA, uint128 paymentA, uint128 cancelledA,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_A, OTHER_STABLE);\n        (uint128 claimedB, uint128 paymentB, uint128 cancelledB,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_B, OTHER_STABLE);\n\n        assertEq(claimedA, claimedB, \"Claimed shares should be equal\");\n        assertEq(claimedA + claimedB + 1, issuedShares, \"System should have 1 share class token atom surplus\");\n        assertEq(paymentA, depositAmountA, \"Payment A should never be zero\");\n        assertEq(paymentB, depositAmountB, \"Payment B should never be zero\");\n        assertEq(cancelledA + cancelledB, 0, \"No queued cancellation\");\n        assertEq(shareClass.pendingDeposit(scId, OTHER_STABLE), 0, \"Pending deposit should be zero\");\n\n        _assertDepositRequestEq(OTHER_STABLE, INVESTOR_A, UserOrder(0, 2));\n        _assertDepositRequestEq(OTHER_STABLE, INVESTOR_B, UserOrder(0, 2));\n    }\n\n    /// @dev Investors can claim 50% rounded down of an uneven number of shares => 1 share atom surplus in system\n    function testClaimDepositEvenInvestorsUnevenClaimable() public {\n        uint128 approvedAssetAmount = 100 * DENO_OTHER_STABLE;\n        uint128 issuedShares = 11;\n        uint128 depositAmountA = 49 * approvedAssetAmount / 100;\n        uint128 depositAmountB = 51 * approvedAssetAmount / 100;\n        D18 navPerShare = d18(_intoPoolAmount(OTHER_STABLE, approvedAssetAmount), issuedShares);\n\n        shareClass.requestDeposit(poolId, scId, depositAmountA, INVESTOR_A, OTHER_STABLE);\n        shareClass.requestDeposit(poolId, scId, depositAmountB, INVESTOR_B, OTHER_STABLE);\n        _approveAllDepositsAndIssue(approvedAssetAmount, issuedShares, navPerShare);\n\n        (uint128 claimedA, uint128 paymentA, uint128 cancelledA,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_A, OTHER_STABLE);\n        (uint128 claimedB, uint128 paymentB, uint128 cancelledB,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_B, OTHER_STABLE);\n\n        assertEq(claimedA, claimedB, \"Claimed shares should be equal\");\n        assertEq(claimedA + claimedB + 1, issuedShares, \"System should have 1 share class token atom surplus\");\n        assertEq(paymentA, depositAmountA, \"Payment A should never be zero\");\n        assertEq(paymentB, depositAmountB, \"Payment B should never be zero\");\n        assertEq(cancelledA + cancelledB, 0, \"No queued cancellation\");\n    }\n\n    /// @dev Investors can claim 1/3 of an even number of shares => 1 share atom surplus in system\n    function testClaimDepositUnevenInvestorsEvenClaimable() public {\n        uint128 approvedAssetAmount = 100 * DENO_OTHER_STABLE;\n        uint128 issuedShares = 10;\n        uint128 depositAmountA = 30 * approvedAssetAmount / 100;\n        uint128 depositAmountB = 31 * approvedAssetAmount / 100;\n        uint128 depositAmountC = 39 * approvedAssetAmount / 100;\n        D18 navPerShare = d18(_intoPoolAmount(OTHER_STABLE, approvedAssetAmount), issuedShares);\n\n        shareClass.requestDeposit(poolId, scId, depositAmountA, INVESTOR_A, OTHER_STABLE);\n        shareClass.requestDeposit(poolId, scId, depositAmountB, INVESTOR_B, OTHER_STABLE);\n        shareClass.requestDeposit(poolId, scId, depositAmountC, INVESTOR_C, OTHER_STABLE);\n        _approveAllDepositsAndIssue(approvedAssetAmount, issuedShares, navPerShare);\n\n        (uint128 claimedA, uint128 paymentA, uint128 cancelledA,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_A, OTHER_STABLE);\n        (uint128 claimedB, uint128 paymentB, uint128 cancelledB,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_B, OTHER_STABLE);\n        (uint128 claimedC, uint128 paymentC, uint128 cancelledC,) =\n            shareClass.claimDeposit(poolId, scId, INVESTOR_C, OTHER_STABLE);\n\n        assertEq(claimedA, claimedB, \"Claimed shares should be equal\");\n        assertEq(claimedB, claimedC, \"Claimed shares should be equal\");\n        assertEq(\n            claimedA + claimedB + claimedC + 1, issuedShares, \"System should have 1 share class token atom surplus\"\n        );\n        assertEq(paymentA, depositAmountA, \"Payment A should never be zero\");\n        assertEq(paymentB, depositAmountB, \"Payment B should never be zero\");\n        assertEq(paymentC, depositAmountC, \"Payment C should never be zero\");\n        assertEq(cancelledA + cancelledB + cancelledC, 0, \"No queued cancellation\");\n    }\n}\n\n///@dev Contains all deposit tests which deal with rounding edge cases\ncontract ShareClassManagerRoundingEdgeCasesRedeem is ShareClassManagerBaseTest {\n    using MathLib for uint128;\n    using MathLib for uint256;\n\n    bytes32 constant INVESTOR_A = bytes32(\"investorA\");\n    bytes32 constant INVESTOR_B = bytes32(\"investorB\");\n    bytes32 constant INVESTOR_C = bytes32(\"investorC\");\n\n    uint128 constant TOTAL_ISSUANCE = 1000 * DENO_POOL;\n\n    // 100 OTHER_STABLE = 1 POOL leads to max OTHER_STABLE precision of 100\n    // NOTE: If 1 OTHER_STABLE equalled 100 POOL, max OTHER_STABLE precision would be 1\n    // This originates from the price conversion which does base * exponentQuote / exponentBase\n    uint128 constant MAX_OTHER_STABLE_PRECISION = OTHER_STABLE_PER_POOL;\n\n    function setUp() public override {\n        ShareClassManagerBaseTest.setUp();\n\n        _mockTotalIssuance(TOTAL_ISSUANCE);\n    }\n\n    function _approveAllRedeemsAndRevoke(uint128 approvedShares, uint128 expectedAssetPayout, D18 navPerShare)\n        private\n    {\n        shareClass.approveRedeems(\n            poolId, scId, OTHER_STABLE, _nowRedeem(OTHER_STABLE), approvedShares, _pricePoolPerAsset(OTHER_STABLE)\n        );\n        (, uint128 assetPayout,) =\n            shareClass.revokeShares(poolId, scId, OTHER_STABLE, _nowRevoke(OTHER_STABLE), navPerShare);\n        assertEq(_totalIssuance(), TOTAL_ISSUANCE - approvedShares, \"Mismatch in expected shares\");\n        assertEq(shareClass.pendingRedeem(scId, OTHER_STABLE), 0, \"Pending redeem should have decreased\");\n        assertEq(assetPayout, expectedAssetPayout, \"Mismatch in expected asset payout\");\n    }\n\n    /// @dev Investors cannot claim anything despite non-zero pending amounts\n    function testClaimRedeemSingleAssetAtom() public {\n        uint128 approvedShares = DENO_POOL / DENO_OTHER_STABLE; // 1e6\n        uint128 assetPayout = MAX_OTHER_STABLE_PRECISION; // 100\n        uint128 redeemAmountA = 1;\n        uint128 redeemAmountB = approvedShares - redeemAmountA;\n        uint128 poolPayout = _intoPoolAmount(OTHER_STABLE, assetPayout); // 1\n        D18 navPerShare = d18(poolPayout, approvedShares); // = 1e18\n\n        shareClass.requestRedeem(poolId, scId, redeemAmountA, INVESTOR_A, OTHER_STABLE);\n        shareClass.requestRedeem(poolId, scId, redeemAmountB, INVESTOR_B, OTHER_STABLE);\n        _approveAllRedeemsAndRevoke(approvedShares, assetPayout, navPerShare);\n\n        (uint128 claimedA, uint128 paymentA,,) = shareClass.claimRedeem(poolId, scId, INVESTOR_A, OTHER_STABLE);\n        (uint128 claimedB, uint128 paymentB,,) = shareClass.claimRedeem(poolId, scId, INVESTOR_B, OTHER_STABLE);\n\n        assertEq(claimedA, claimedB, \"Both investors should have claimed same amount\");\n        assertEq(claimedA + claimedB, 0, \"Claimed amount should be zero for both investors\");\n        assertEq(paymentA, redeemAmountA, \"Payment A should never be zero\");\n        assertEq(paymentB, redeemAmountB, \"Payment B should never be zero\");\n        assertEq(shareClass.pendingRedeem(scId, OTHER_STABLE), 0, \"Pending redeem should be zero\");\n\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_A, UserOrder(0, 2));\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_B, UserOrder(0, 2));\n    }\n\n    /// @dev Investors can claim 50% rounded down of an uneven number of asset amount => asset amount surplus in\n    /// system\n    function testClaimRedeemEvenInvestorsUnevenClaimable() public {\n        uint128 approvedShares = DENO_POOL / DENO_OTHER_STABLE;\n        uint128 assetPayout = 11 * MAX_OTHER_STABLE_PRECISION; // 1100\n        uint128 redeemAmountA = 49 * approvedShares / 100;\n        uint128 redeemAmountB = 51 * approvedShares / 100;\n        uint128 poolPayout = _intoPoolAmount(OTHER_STABLE, assetPayout); // 11\n        D18 navPerShare = d18(poolPayout, approvedShares);\n\n        shareClass.requestRedeem(poolId, scId, redeemAmountA, INVESTOR_A, OTHER_STABLE);\n        shareClass.requestRedeem(poolId, scId, redeemAmountB, INVESTOR_B, OTHER_STABLE);\n        _approveAllRedeemsAndRevoke(approvedShares, assetPayout, navPerShare);\n\n        (uint128 claimedA, uint128 paymentA, uint128 cancelledA,) =\n            shareClass.claimRedeem(poolId, scId, INVESTOR_A, OTHER_STABLE);\n        (uint128 claimedB, uint128 paymentB, uint128 cancelledB,) =\n            shareClass.claimRedeem(poolId, scId, INVESTOR_B, OTHER_STABLE);\n\n        assertEq(claimedA, claimedB, \"Claimed asset amount should be equal\");\n        assertEq(\n            claimedA + claimedB + 1 * MAX_OTHER_STABLE_PRECISION,\n            assetPayout,\n            \"System should have 1 max asset precision amount surplus\"\n        );\n        assertEq(paymentA, redeemAmountA, \"Payment A should never be zero\");\n        assertEq(paymentB, redeemAmountB, \"Payment B should never be zero\");\n        assertEq(shareClass.pendingRedeem(scId, OTHER_STABLE), 0, \"Pending redeem should not have reset\");\n        assertEq(cancelledA + cancelledB, 0, \"No queued cancellation\");\n\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_A, UserOrder(0, 2));\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_B, UserOrder(0, 2));\n    }\n\n    /// @dev Investors can claim 50% rounded down of an uneven number of asset amount =>  asset amount surplus in\n    /// system\n    function testClaimRedeemUnevenInvestorsEvenClaimable() public {\n        uint128 approvedShares = DENO_POOL / DENO_OTHER_STABLE;\n        uint128 assetPayout = 10 * MAX_OTHER_STABLE_PRECISION; // 1000\n        uint128 redeemAmountA = 30 * approvedShares / 100;\n        uint128 redeemAmountB = 31 * approvedShares / 100;\n        uint128 redeemAmountC = 39 * approvedShares / 100;\n        uint128 poolPayout = _intoPoolAmount(OTHER_STABLE, assetPayout); // 10\n        D18 navPerShare = d18(poolPayout, approvedShares);\n\n        shareClass.requestRedeem(poolId, scId, redeemAmountA, INVESTOR_A, OTHER_STABLE);\n        shareClass.requestRedeem(poolId, scId, redeemAmountB, INVESTOR_B, OTHER_STABLE);\n        shareClass.requestRedeem(poolId, scId, redeemAmountC, INVESTOR_C, OTHER_STABLE);\n        _approveAllRedeemsAndRevoke(approvedShares, assetPayout, navPerShare);\n\n        (uint128 claimedA, uint128 paymentA,,) = shareClass.claimRedeem(poolId, scId, INVESTOR_A, OTHER_STABLE);\n        (uint128 claimedB, uint128 paymentB,,) = shareClass.claimRedeem(poolId, scId, INVESTOR_B, OTHER_STABLE);\n        (uint128 claimedC, uint128 paymentC,,) = shareClass.claimRedeem(poolId, scId, INVESTOR_C, OTHER_STABLE);\n\n        assertEq(claimedA, claimedB, \"Claimed asset amount should be equal\");\n        assertEq(claimedB, claimedC, \"Claimed asset amount should be equal\");\n        assertEq(\n            claimedA + claimedB + claimedC + 1 * MAX_OTHER_STABLE_PRECISION,\n            assetPayout,\n            \"System should have 1 max asset precision amount surplus\"\n        );\n        assertEq(paymentA, redeemAmountA, \"Payment A should never be zero\");\n        assertEq(paymentB, redeemAmountB, \"Payment B should never be zero\");\n        assertEq(paymentC, redeemAmountC, \"Payment C should never be zero\");\n        assertEq(shareClass.pendingRedeem(scId, OTHER_STABLE), 0, \"Pending redeem should not have reset\");\n\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_A, UserOrder(0, 2));\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_B, UserOrder(0, 2));\n        _assertRedeemRequestEq(OTHER_STABLE, INVESTOR_C, UserOrder(0, 2));\n    }\n}\n\n///@dev Contains all tests which are expected to revert\ncontract ShareClassManagerRevertsTest is ShareClassManagerBaseTest {\n    using MathLib for uint128;\n\n    ShareClassId wrongShareClassId = ShareClassId.wrap(bytes16((uint128(POOL_ID) << 64) + 42));\n    address unauthorized = makeAddr(\"unauthorizedAddress\");\n    uint32 epochId = 1;\n\n    function testRequestDepositWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.requestDeposit(poolId, wrongShareClassId, 1, investor, USDC);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.requestDeposit(poolId, wrongShareClassId, 1, investor, USDC);\n    }\n\n    function testCancelRequestDepositWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.cancelDepositRequest(poolId, wrongShareClassId, investor, USDC);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.cancelDepositRequest(poolId, wrongShareClassId, investor, USDC);\n    }\n\n    function testRequestRedeemWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.requestRedeem(poolId, wrongShareClassId, 1, investor, USDC);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.requestRedeem(poolId, wrongShareClassId, 1, investor, USDC);\n    }\n\n    function testCancelRedeemRequestWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.cancelRedeemRequest(poolId, wrongShareClassId, investor, USDC);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.cancelRedeemRequest(poolId, wrongShareClassId, investor, USDC);\n    }\n\n    function testApproveDepositsWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.approveDeposits(poolId, wrongShareClassId, USDC, epochId, 1, d18(1, 1));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.approveDeposits(poolId, wrongShareClassId, USDC, epochId, 1, d18(1, 1));\n    }\n\n    function testApproveRedeemsWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.approveRedeems(poolId, wrongShareClassId, USDC, epochId, 1, _pricePoolPerAsset(USDC));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.approveRedeems(poolId, wrongShareClassId, USDC, epochId, 1, _pricePoolPerAsset(USDC));\n    }\n\n    function testIssueSharesWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.issueShares(poolId, wrongShareClassId, USDC, epochId, d18(1));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.issueShares(poolId, wrongShareClassId, USDC, epochId, d18(1));\n    }\n\n    function testRevokeSharesWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.revokeShares(poolId, wrongShareClassId, USDC, epochId, d18(1));\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(unauthorized);\n        shareClass.revokeShares(poolId, wrongShareClassId, USDC, epochId, d18(1));\n    }\n\n    function testClaimDepositWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.claimDeposit(poolId, wrongShareClassId, investor, USDC);\n    }\n\n    function testClaimRedeemWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.claimRedeem(poolId, wrongShareClassId, investor, USDC);\n    }\n\n    function testUpdatePricePerShareWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.updatePricePerShare(poolId, wrongShareClassId, d18(1));\n    }\n\n    function testUpdateMetadataWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.updateMetadata(poolId, wrongShareClassId, \"\", \"\");\n    }\n\n    function testIncreaseIssuanceWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.increaseShareClassIssuance(poolId, wrongShareClassId, 0);\n    }\n\n    function testDecreaseIssuanceWrongShareClassId() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.ShareClassNotFound.selector));\n        shareClass.decreaseShareClassIssuance(poolId, wrongShareClassId, 0);\n    }\n\n    function testDecreaseOverFlow() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.DecreaseMoreThanIssued.selector));\n        shareClass.decreaseShareClassIssuance(poolId, scId, 1);\n    }\n\n    function testIssueSharesBeforeApproval() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.EpochNotFound.selector));\n        shareClass.issueShares(poolId, scId, USDC, epochId + 1, d18(1));\n    }\n\n    function testRevokeSharesBeforeApproval() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.EpochNotFound.selector));\n        shareClass.revokeShares(poolId, scId, USDC, epochId + 1, d18(1));\n    }\n\n    function testRequestDepositRequiresClaim() public {\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, epochId, 1, d18(1, 1));\n        shareClass.cancelDepositRequest(poolId, scId, investor, USDC);\n\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.CancellationQueued.selector));\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n    }\n\n    function testRequestRedeemCancellationQueued() public {\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, epochId, 1, _pricePoolPerAsset(USDC));\n        shareClass.cancelRedeemRequest(poolId, scId, investor, USDC);\n\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.CancellationQueued.selector));\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n    }\n\n    function testApproveDepositsZeroPending() public {\n        vm.expectRevert(IShareClassManager.InsufficientPending.selector);\n        shareClass.approveDeposits(poolId, scId, USDC, epochId, 1, d18(1, 1));\n    }\n\n    function testApproveDepositsZeroApproval() public {\n        shareClass.requestDeposit(poolId, scId, 1, investor, USDC);\n\n        vm.expectRevert(IShareClassManager.ZeroApprovalAmount.selector);\n        shareClass.approveDeposits(poolId, scId, USDC, epochId, 0, d18(0));\n    }\n\n    function testApproveRedeemsZeroApproval() public {\n        shareClass.requestRedeem(poolId, scId, 1, investor, USDC);\n\n        vm.expectRevert(IShareClassManager.ZeroApprovalAmount.selector);\n        shareClass.approveRedeems(poolId, scId, USDC, epochId, 0, _pricePoolPerAsset(USDC));\n    }\n\n    function testApproveRedeemsZeroPending() public {\n        vm.expectRevert(IShareClassManager.InsufficientPending.selector);\n        shareClass.approveRedeems(poolId, scId, USDC, epochId, 1, _pricePoolPerAsset(USDC));\n    }\n\n    function testAddShareClassInvalidNameEmpty() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataName.selector);\n        shareClass.addShareClass(PoolId.wrap(POOL_ID + 1), \"\", SC_SYMBOL, SC_SALT);\n    }\n\n    function testAddShareClassInvalidNameExcess() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataName.selector);\n        shareClass.addShareClass(PoolId.wrap(POOL_ID + 1), string(new bytes(129)), SC_SYMBOL, SC_SALT);\n    }\n\n    function testAddShareClassInvalidSymbolEmpty() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataSymbol.selector);\n        shareClass.addShareClass(PoolId.wrap(POOL_ID + 1), SC_NAME, \"\", SC_SALT);\n    }\n\n    function testAddShareClassInvalidSymbolExcess() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataSymbol.selector);\n        shareClass.addShareClass(PoolId.wrap(POOL_ID + 1), SC_NAME, string(new bytes(33)), SC_SALT);\n    }\n\n    function testAddShareClassEmptySalt() public {\n        vm.expectRevert(IShareClassManager.InvalidSalt.selector);\n        shareClass.addShareClass(PoolId.wrap(POOL_ID + 1), SC_NAME, SC_SYMBOL, bytes32(0));\n    }\n\n    function testAddShareClassSaltAlreadyUsed() public {\n        vm.expectRevert(IShareClassManager.AlreadyUsedSalt.selector);\n        shareClass.addShareClass(poolId, SC_NAME, SC_SYMBOL, SC_SALT);\n    }\n\n    function testUpdateMetadataClassInvalidNameEmpty() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataName.selector);\n        shareClass.updateMetadata(poolId, scId, \"\", SC_SYMBOL);\n    }\n\n    function testUpdateMetadataClassInvalidNameExcess() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataName.selector);\n        shareClass.updateMetadata(poolId, scId, string(new bytes(129)), SC_SYMBOL);\n    }\n\n    function testUpdateMetadataClassInvalidSymbolEmpty() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataSymbol.selector);\n        shareClass.updateMetadata(poolId, scId, SC_NAME, \"\");\n    }\n\n    function testUpdateMetadataClassInvalidSymbolExcess() public {\n        vm.expectRevert(IShareClassManager.InvalidMetadataSymbol.selector);\n        shareClass.updateMetadata(poolId, scId, SC_NAME, string(new bytes(33)));\n    }\n\n    function testApproveDepositEpochNotInSequence() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.EpochNotInSequence.selector, 3, 1));\n        shareClass.approveDeposits(poolId, scId, USDC, 3, 0, d18(0));\n    }\n\n    function testApproveRedeemEpochNotInSequence() public {\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.EpochNotInSequence.selector, 3, 1));\n        shareClass.approveRedeems(poolId, scId, USDC, 3, 0, d18(0));\n    }\n\n    function testIssueSharesEpochNotInSequence() public {\n        shareClass.requestDeposit(poolId, scId, 1000, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, 1, 500, d18(1e18));\n        shareClass.approveDeposits(poolId, scId, USDC, 2, 500, d18(1e18));\n\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.EpochNotInSequence.selector, 2, 1));\n        shareClass.issueShares(poolId, scId, USDC, 2, d18(0));\n    }\n\n    function testRevokeSharesEpochNotInSequence() public {\n        _mockTotalIssuance(1000);\n        shareClass.requestRedeem(poolId, scId, 1000, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, 1, 500, d18(1e18));\n        shareClass.approveRedeems(poolId, scId, USDC, 2, 500, d18(1e18));\n\n        vm.expectRevert(abi.encodeWithSelector(IShareClassManager.EpochNotInSequence.selector, 2, 1));\n        shareClass.revokeShares(poolId, scId, USDC, 2, d18(0));\n    }\n\n    function testClaimDepositEpochNotFound() public {\n        vm.expectRevert(IShareClassManager.NoOrderFound.selector);\n        shareClass.claimDeposit(poolId, scId, investor, USDC);\n    }\n\n    function testClaimRedeemEpochNotFound() public {\n        vm.expectRevert(IShareClassManager.NoOrderFound.selector);\n        shareClass.claimRedeem(poolId, scId, investor, USDC);\n    }\n\n    function testClaimDepositIssuanceRequired() public {\n        _mockTotalIssuance(1000);\n        shareClass.requestDeposit(poolId, scId, 1000, investor, USDC);\n        shareClass.approveDeposits(poolId, scId, USDC, 1, 500, d18(1e18));\n        shareClass.issueShares(poolId, scId, USDC, 1, d18(1e18));\n\n        bytes32 investor2 = bytes32(\"investor2\");\n        shareClass.requestDeposit(poolId, scId, 1000, investor2, USDC);\n\n        vm.expectRevert(IShareClassManager.IssuanceRequired.selector);\n        shareClass.claimDeposit(poolId, scId, investor2, USDC);\n    }\n\n    function testClaimRedeemRevocationRequired() public {\n        _mockTotalIssuance(1000);\n        shareClass.requestRedeem(poolId, scId, 1000, investor, USDC);\n        shareClass.approveRedeems(poolId, scId, USDC, 1, 500, d18(1e18));\n        shareClass.revokeShares(poolId, scId, USDC, 1, d18(1e18));\n\n        bytes32 investor2 = bytes32(\"investor2\");\n        shareClass.requestRedeem(poolId, scId, 1000, investor2, USDC);\n\n        vm.expectRevert(IShareClassManager.RevocationRequired.selector);\n        shareClass.claimRedeem(poolId, scId, investor2, USDC);\n    }\n}\n"
    },
    "test/integration/EndToEnd.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IdentityValuation} from \"src/misc/IdentityValuation.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {IRecoverable} from \"src/misc/interfaces/IRecoverable.sol\";\n\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId, newAssetId} from \"src/common/types/AssetId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\nimport {ISafe} from \"src/common/interfaces/IGuardian.sol\";\nimport {Guardian} from \"src/common/Guardian.sol\";\nimport {Root} from \"src/common/Root.sol\";\nimport {Gateway} from \"src/common/Gateway.sol\";\nimport {MessageLib, VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\n\nimport {Hub} from \"src/hub/Hub.sol\";\nimport {HubRegistry} from \"src/hub/HubRegistry.sol\";\nimport {Accounting} from \"src/hub/Accounting.sol\";\nimport {Holdings} from \"src/hub/Holdings.sol\";\nimport {ShareClassManager} from \"src/hub/ShareClassManager.sol\";\nimport {IShareClassManager} from \"src/hub/interfaces/IShareClassManager.sol\";\n\nimport {VaultRouter} from \"src/vaults/VaultRouter.sol\";\nimport {PoolManager} from \"src/vaults/PoolManager.sol\";\nimport {BalanceSheet} from \"src/vaults/BalanceSheet.sol\";\nimport {AsyncRequestManager} from \"src/vaults/AsyncRequestManager.sol\";\nimport {SyncRequestManager} from \"src/vaults/SyncRequestManager.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {SyncDepositVault} from \"src/vaults/SyncDepositVault.sol\";\nimport {AsyncVaultFactory} from \"src/vaults/factories/AsyncVaultFactory.sol\";\nimport {SyncDepositVaultFactory} from \"src/vaults/factories/SyncDepositVaultFactory.sol\";\n\nimport {FullDeployer, HubDeployer, VaultsDeployer} from \"script/FullDeployer.s.sol\";\nimport {CommonDeployer, MESSAGE_COST_ENV} from \"script/CommonDeployer.s.sol\";\n\nimport {LocalAdapter} from \"test/integration/adapters/LocalAdapter.sol\";\n\n/// README\n/// This EndToEnd tests emulates two chains fully deployed and connected through an adapter\n/// Each test case can receive a fuzzed boolean parameter to be tested in both cases:\n/// - If sameChain: HUB is in CENTRIFUGE_ID_A and CV is in CENTRIFUGE_ID_A\n/// - If !sameChain: HUB is in CENTRIFUGE_ID_A and CV is in CENTRIFUGE_ID_B\n///\n/// NOTE: All contracts used needs to be placed in the below structs to avoid external calls each time a contract is\n/// chosen from a deployment. If not, it has two side effects:\n///   1.\n///   vm.prank(FM)\n///   deployA.hub().notifyPool() // Will fail, given prank is used to retriver the hub.\n///\n///   2. It increases significatily the amount of calls shown by the debugger.\n///\n/// By using these structs we avoid both \"issues\".\n\nstruct CHub {\n    uint16 centrifugeId;\n    // Common\n    Root root;\n    Guardian guardian;\n    Gateway gateway;\n    // Hub\n    HubRegistry hubRegistry;\n    Accounting accounting;\n    Holdings holdings;\n    ShareClassManager shareClassManager;\n    Hub hub;\n    IdentityValuation identityValuation;\n}\n\nstruct CVaults {\n    uint16 centrifugeId;\n    // Common\n    Root root;\n    Guardian guardian;\n    Gateway gateway;\n    // Vaults\n    BalanceSheet balanceSheet;\n    PoolManager poolManager;\n    VaultRouter router;\n    AsyncVaultFactory asyncVaultFactory;\n    SyncDepositVaultFactory syncDepositVaultFactory;\n    // Hooks\n    address fullRestrictionsHook;\n    address redemptionRestrictionsHook;\n}\n\n/// End to end testing assuming two full deployments in two different chains\ncontract TestEndToEnd is Test {\n    using CastLib for *;\n    using MessageLib for *;\n\n    ISafe immutable safeAdminA = ISafe(makeAddr(\"SafeAdminA\"));\n    ISafe immutable safeAdminB = ISafe(makeAddr(\"SafeAdminB\"));\n\n    uint16 constant CENTRIFUGE_ID_A = 5;\n    uint16 constant CENTRIFUGE_ID_B = 6;\n    uint64 constant GAS = 10 wei;\n    uint256 constant DEFAULT_SUBSIDY = 100 ether;\n\n    address immutable FM = makeAddr(\"FM\");\n    address immutable INVESTOR_A = makeAddr(\"INVESTOR_A\");\n    address immutable ANY = makeAddr(\"ANY\");\n\n    uint128 constant INVESTOR_A_AMOUNT = 1_000_000e6;\n\n    AccountId constant ASSET_ACCOUNT = AccountId.wrap(0x01);\n    AccountId constant EQUITY_ACCOUNT = AccountId.wrap(0x02);\n    AccountId constant LOSS_ACCOUNT = AccountId.wrap(0x03);\n    AccountId constant GAIN_ACCOUNT = AccountId.wrap(0x04);\n\n    FullDeployer deployA = new FullDeployer();\n    FullDeployer deployB = new FullDeployer();\n\n    AssetId USD = deployA.USD();\n    CHub h;\n    CVaults cv;\n\n    D18 immutable IDENTITY_PRICE = d18(1, 1);\n\n    function setUp() public {\n        vm.setEnv(MESSAGE_COST_ENV, vm.toString(GAS));\n\n        LocalAdapter adapterA = _deployChain(deployA, CENTRIFUGE_ID_A, CENTRIFUGE_ID_B, safeAdminA);\n        LocalAdapter adapterB = _deployChain(deployB, CENTRIFUGE_ID_B, CENTRIFUGE_ID_A, safeAdminB);\n\n        // We connect both deploys through the adapters\n        adapterA.setEndpoint(adapterB);\n        adapterB.setEndpoint(adapterA);\n\n        // Initialize accounts\n        vm.deal(FM, 1 ether);\n        vm.deal(INVESTOR_A, 1 ether);\n        vm.deal(ANY, 1 ether);\n\n        // We not use the VM chain\n        vm.chainId(0xDEAD);\n\n        h = CHub({\n            centrifugeId: CENTRIFUGE_ID_A,\n            root: deployA.root(),\n            guardian: deployA.guardian(),\n            gateway: deployA.gateway(),\n            hubRegistry: deployA.hubRegistry(),\n            accounting: deployA.accounting(),\n            holdings: deployA.holdings(),\n            shareClassManager: deployA.shareClassManager(),\n            hub: deployA.hub(),\n            identityValuation: deployA.identityValuation()\n        });\n    }\n\n    function _deployChain(FullDeployer deploy, uint16 localCentrifugeId, uint16 remoteCentrifugeId, ISafe safeAdmin)\n        internal\n        returns (LocalAdapter adapter)\n    {\n        deploy.deployFull(localCentrifugeId, safeAdmin, address(deploy), true);\n\n        adapter = new LocalAdapter(localCentrifugeId, deploy.gateway(), address(deploy));\n        deploy.wire(remoteCentrifugeId, adapter, address(deploy));\n\n        deploy.removeFullDeployerAccess(address(deploy));\n    }\n\n    function _setCV(bool sameChain) internal {\n        FullDeployer deploy = (sameChain) ? deployA : deployB;\n        uint16 centrifugeId = (sameChain) ? CENTRIFUGE_ID_A : CENTRIFUGE_ID_B;\n        cv = CVaults({\n            centrifugeId: centrifugeId,\n            root: deploy.root(),\n            guardian: deploy.guardian(),\n            gateway: deploy.gateway(),\n            balanceSheet: deploy.balanceSheet(),\n            poolManager: deploy.poolManager(),\n            router: deploy.vaultRouter(),\n            fullRestrictionsHook: deploy.fullRestrictionsHook(),\n            redemptionRestrictionsHook: deploy.redemptionRestrictionsHook(),\n            asyncVaultFactory: deploy.asyncVaultFactory(),\n            syncDepositVaultFactory: deploy.syncDepositVaultFactory()\n        });\n    }\n\n    function _configurePool(address vaultFactory)\n        internal\n        returns (PoolId poolId, ShareClassId scId, AssetId assetId)\n    {\n        // Register AssetId\n\n        ERC20 asset = new ERC20(6);\n        asset.file(\"name\", \"USD Coin\");\n        asset.file(\"symbol\", \"USDC\");\n        asset.mint(INVESTOR_A, INVESTOR_A_AMOUNT);\n\n        cv.poolManager.registerAsset{value: GAS}(h.centrifugeId, address(asset), 0);\n        assetId = newAssetId(cv.centrifugeId, 1);\n\n        // Configure Pool\n        poolId = h.hubRegistry.poolId(h.centrifugeId, 1);\n\n        vm.startPrank(address(h.guardian.safe()));\n        h.guardian.createPool(poolId, FM, USD);\n\n        scId = h.shareClassManager.previewNextShareClassId(poolId);\n\n        vm.startPrank(FM);\n        h.hub.setPoolMetadata(poolId, bytes(\"Testing pool\"));\n        h.hub.addShareClass(poolId, \"Tokenized MMF\", \"MMF\", bytes32(\"salt\"));\n        h.hub.notifyPool{value: GAS}(poolId, cv.centrifugeId);\n        h.hub.notifyShareClass{value: GAS}(poolId, scId, cv.centrifugeId, cv.redemptionRestrictionsHook.toBytes32());\n\n        h.hub.createAccount(poolId, ASSET_ACCOUNT, true);\n        h.hub.createAccount(poolId, EQUITY_ACCOUNT, false);\n        h.hub.createAccount(poolId, LOSS_ACCOUNT, false);\n        h.hub.createAccount(poolId, GAIN_ACCOUNT, false);\n        h.hub.createHolding(\n            poolId, scId, assetId, h.identityValuation, ASSET_ACCOUNT, EQUITY_ACCOUNT, GAIN_ACCOUNT, LOSS_ACCOUNT\n        );\n\n        h.hub.updatePricePerShare(poolId, scId, IDENTITY_PRICE);\n        h.hub.notifySharePrice{value: GAS}(poolId, scId, cv.centrifugeId);\n        h.hub.notifyAssetPrice{value: GAS}(poolId, scId, assetId);\n\n        h.hub.updateContract{value: GAS}(\n            poolId,\n            scId,\n            cv.centrifugeId,\n            address(cv.poolManager).toBytes32(),\n            MessageLib.UpdateContractVaultUpdate({\n                vaultOrFactory: vaultFactory.toBytes32(),\n                assetId: assetId.raw(),\n                kind: uint8(VaultUpdateKind.DeployAndLink)\n            }).serialize()\n        );\n\n        vm.stopPrank();\n        vm.deal(address(this), DEFAULT_SUBSIDY);\n        cv.gateway.subsidizePool{value: DEFAULT_SUBSIDY}(poolId);\n    }\n\n    /// forge-config: default.isolate = true\n    function testAsyncDeposit(bool sameChain) public {\n        _setCV(sameChain);\n        (PoolId poolId, ShareClassId scId, AssetId assetId) = _configurePool(address(cv.asyncVaultFactory));\n\n        IShareToken shareToken = IShareToken(cv.poolManager.shareToken(poolId, scId));\n        (address asset,) = cv.poolManager.idToAsset(assetId);\n        IAsyncVault vault = IAsyncVault(shareToken.vault(address(asset)));\n\n        vm.startPrank(INVESTOR_A);\n        ERC20(asset).approve(address(vault), INVESTOR_A_AMOUNT);\n        vault.requestDeposit(INVESTOR_A_AMOUNT, INVESTOR_A, INVESTOR_A);\n\n        vm.startPrank(FM);\n        uint32 depositEpochId = h.hub.shareClassManager().nowDepositEpoch(scId, assetId);\n        h.hub.approveDeposits{value: GAS}(poolId, scId, assetId, depositEpochId, INVESTOR_A_AMOUNT);\n        h.hub.issueShares{value: GAS}(poolId, scId, assetId, depositEpochId, IDENTITY_PRICE);\n\n        vm.startPrank(ANY);\n        uint32 maxClaims = h.shareClassManager.maxDepositClaims(scId, INVESTOR_A.toBytes32(), assetId);\n        h.hub.notifyDeposit{value: GAS}(poolId, scId, assetId, INVESTOR_A.toBytes32(), maxClaims);\n\n        vm.startPrank(INVESTOR_A);\n        vault.mint(INVESTOR_A_AMOUNT, INVESTOR_A);\n\n        assertEq(shareToken.balanceOf(INVESTOR_A), INVESTOR_A_AMOUNT);\n    }\n\n    /// forge-config: default.isolate = true\n    function testSyncDeposit(bool sameChain) public {\n        _setCV(sameChain);\n        (PoolId poolId, ShareClassId scId, AssetId assetId) = _configurePool(address(cv.syncDepositVaultFactory));\n\n        IShareToken shareToken = IShareToken(cv.poolManager.shareToken(poolId, scId));\n        (address asset,) = cv.poolManager.idToAsset(assetId);\n        SyncDepositVault vault = SyncDepositVault(shareToken.vault(address(asset)));\n\n        vm.startPrank(INVESTOR_A);\n        ERC20(asset).approve(address(vault), INVESTOR_A_AMOUNT);\n        vault.deposit(INVESTOR_A_AMOUNT, INVESTOR_A);\n\n        // TODO: Continue investing process\n        //cv.balanceSheet.approveDeposits(poolId, scId, assetId, INVESTOR_A_AMOUNT);\n        //cv.balanceSheet.issue(poolId, scId, assetId, INVESTOR_A_AMOUNT);\n\n        //vault.mint(INVESTOR_A_AMOUNT, INVESTOR_A);\n    }\n}\n"
    },
    "test/integration/adapters/LocalAdapter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {Auth} from \"src/misc/Auth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IMessageHandler} from \"src/common/interfaces/IMessageHandler.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\n\n/// An adapter that sends the message to the another MessageHandler and acts as MessageHandler too.\ncontract LocalAdapter is Test, Auth, IAdapter, IMessageHandler {\n    uint16 localCentrifugeId;\n    IMessageHandler public gateway;\n    IMessageHandler public endpoint;\n\n    constructor(uint16 localCentrifugeId_, IMessageHandler gateway_, address deployer) Auth(deployer) {\n        gateway = gateway_;\n        localCentrifugeId = localCentrifugeId_;\n    }\n\n    function setEndpoint(IMessageHandler endpoint_) public {\n        endpoint = endpoint_;\n    }\n\n    /// @inheritdoc IMessageHandler\n    function handle(uint16 remoteCentrifugeId, bytes calldata message) external {\n        // Local messages must be bypassed\n        assertNotEq(localCentrifugeId, remoteCentrifugeId, \"Local messages must be bypassed\");\n\n        gateway.handle(remoteCentrifugeId, message);\n    }\n\n    /// @inheritdoc IAdapter\n    function send(uint16 remoteCentrifugeId, bytes calldata payload, uint256, address)\n        external\n        payable\n        returns (bytes32 adapterData)\n    {\n        // Local messages must be bypassed\n        assertNotEq(remoteCentrifugeId, localCentrifugeId, \"Local messages must be bypassed\");\n\n        // The other handler will receive the message as comming from this\n        endpoint.handle(localCentrifugeId, payload);\n\n        adapterData = bytes32(\"\");\n    }\n\n    /// @inheritdoc IAdapter\n    function estimate(uint16, bytes calldata, uint256 gasLimit) public pure returns (uint256 nativePriceQuote) {\n        return gasLimit;\n    }\n}\n"
    },
    "test/misc/mocks/MockERC6909.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC6909MetadataExt, IERC6909Fungible, IERC6909} from \"src/misc/interfaces/IERC6909.sol\";\n\ncontract MockERC6909 is IERC6909MetadataExt, IERC6909Fungible {\n    mapping(address owner => mapping(uint256 tokenId => uint256)) public balanceOf;\n    mapping(address owner => mapping(address spender => mapping(uint256 tokenId => uint256))) public allowance;\n    mapping(address owner => mapping(address spender => bool)) public operator;\n\n    function decimals(uint256 tokenId) external pure returns (uint8) {\n        return uint8(tokenId);\n    }\n\n    function name(uint256 /*tokenId*/ ) external pure returns (string memory) {\n        return \"mocked name\";\n    }\n\n    function symbol(uint256 /*tokenId*/ ) external pure returns (string memory) {\n        return \"mocked symbol\";\n    }\n\n    function approve(address spender, uint256 tokenId, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender][tokenId] = amount;\n        return true;\n    }\n\n    function mint(address owner, uint256 tokenId, uint256 amount) external {\n        balanceOf[owner][tokenId] += amount;\n    }\n\n    function burn(address owner, uint256 tokenId, uint256 amount) external {\n        require(balanceOf[owner][tokenId] >= amount, InsufficientBalance(owner, tokenId));\n        balanceOf[owner][tokenId] -= amount;\n    }\n\n    function transfer(address receiver, uint256 tokenId, uint256 amount) external returns (bool) {\n        require(balanceOf[msg.sender][tokenId] >= amount, InsufficientBalance(msg.sender, tokenId));\n        balanceOf[receiver][tokenId] += amount;\n        balanceOf[msg.sender][tokenId] -= amount;\n        return true;\n    }\n\n    function transferFrom(address sender, address receiver, uint256 tokenId, uint256 amount) external returns (bool) {\n        if (msg.sender != sender) {\n            if (operator[sender][msg.sender]) {\n                require(allowance[sender][msg.sender][tokenId] >= amount, InsufficientAllowance(sender, tokenId));\n            }\n        }\n        return this.authTransferFrom(sender, receiver, tokenId, amount);\n    }\n\n    function authTransferFrom(address sender, address receiver, uint256 tokenId, uint256 amount)\n        external\n        returns (bool)\n    {\n        require(balanceOf[sender][tokenId] >= amount, InsufficientBalance(sender, tokenId));\n        balanceOf[receiver][tokenId] += amount;\n        balanceOf[sender][tokenId] -= amount;\n        return true;\n    }\n\n    function isOperator(address owner, address operator_) external view returns (bool) {\n        return operator[owner][operator_];\n    }\n\n    function setOperator(address operator_, bool approved) external returns (bool) {\n        operator[msg.sender][operator_] = approved;\n        return true;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return type(IERC6909MetadataExt).interfaceId == interfaceId || type(IERC6909Fungible).interfaceId == interfaceId\n            || type(IERC6909).interfaceId == interfaceId;\n    }\n}\n"
    },
    "test/misc/mocks/MockValuation.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\nimport {ReentrancyProtection} from \"src/misc/ReentrancyProtection.sol\";\nimport {IERC7726} from \"src/misc/interfaces/IERC7726.sol\";\nimport {IERC6909Decimals} from \"src/misc/interfaces/IERC6909.sol\";\n\nimport {BaseValuation} from \"src/misc/BaseValuation.sol\";\n\ncontract MockValuation is BaseValuation, ReentrancyProtection {\n    constructor(IERC6909Decimals erc6909) BaseValuation(erc6909, msg.sender) {}\n\n    mapping(address base => mapping(address quote => D18)) public price;\n\n    function setPrice(address base, address quote, D18 price_) external protected {\n        price[base][quote] = price_;\n        price[quote][base] = price_.reciprocal();\n    }\n\n    /// @inheritdoc IERC7726\n    function getQuote(uint256 baseAmount, address base, address quote) external view returns (uint256 quoteAmount) {\n        D18 price_ = price[base][quote];\n        require(D18.unwrap(price_) != 0, \"Price not set\");\n\n        return PricingLib.convertWithPrice(baseAmount, _getDecimals(base), _getDecimals(quote), price_);\n    }\n}\n"
    },
    "test/misc/unit/BaseValuation.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IBaseValuation} from \"src/misc/interfaces/IBaseValuation.sol\";\nimport {IERC6909Decimals} from \"src/misc/interfaces/IERC6909.sol\";\nimport {BaseValuation} from \"src/misc/BaseValuation.sol\";\n\ncontract BaseValuationImpl is BaseValuation {\n    constructor(IERC6909Decimals assetRegistry, address deployer) BaseValuation(assetRegistry, deployer) {}\n\n    function getQuote(uint256 baseAmount, address base, address quote) external view returns (uint256 quoteAmount) {}\n}\n\ncontract TestFile is Test {\n    BaseValuationImpl valuation = new BaseValuationImpl(IERC6909Decimals(address(42)), address(this));\n\n    function testSuccess() public {\n        vm.expectEmit();\n        emit IBaseValuation.File(\"erc6909\", address(23));\n        valuation.file(\"erc6909\", address(23));\n\n        assertEq(address(valuation.erc6909()), address(23));\n    }\n\n    function testErrNotAuthorized() public {\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        valuation.file(\"erc6909\", address(23));\n    }\n\n    function testErrFileUnrecognizedParam() public {\n        vm.expectRevert(abi.encodeWithSelector(IBaseValuation.FileUnrecognizedParam.selector));\n        valuation.file(\"unrecongnizedWhat\", address(23));\n    }\n}\n"
    },
    "test/misc/unit/EIP712Lib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport \"src/misc/libraries/EIP712Lib.sol\";\n\ncontract EIP712LibTest is Test {\n    function testCalculateDomainSeparator() public view {\n        bytes32 nameHash = keccak256(bytes(\"TestContract\"));\n        bytes32 versionHash = keccak256(bytes(\"1\"));\n\n        bytes32 expectedDomainSeparator =\n            keccak256(abi.encode(EIP712Lib.EIP712_DOMAIN_TYPEHASH, nameHash, versionHash, block.chainid, address(this)));\n\n        bytes32 calculatedDomainSeparator = EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\n        assertEq(calculatedDomainSeparator, expectedDomainSeparator);\n    }\n\n    function testConstantDomainSeperator() public pure {\n        bytes32 expectedTypehash = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n        assertEq(EIP712Lib.EIP712_DOMAIN_TYPEHASH, expectedTypehash);\n    }\n\n    function testDifferentInputs() public view {\n        bytes32 nameHash1 = keccak256(bytes(\"Contract1\"));\n        bytes32 versionHash1 = keccak256(bytes(\"1.0\"));\n\n        bytes32 nameHash2 = keccak256(bytes(\"Contract2\"));\n        bytes32 versionHash2 = keccak256(bytes(\"2.0\"));\n\n        bytes32 domainSeparator1 = EIP712Lib.calculateDomainSeparator(nameHash1, versionHash1);\n        bytes32 domainSeparator2 = EIP712Lib.calculateDomainSeparator(nameHash2, versionHash2);\n\n        assertTrue(domainSeparator1 != domainSeparator2);\n    }\n}\n"
    },
    "test/misc/unit/ERC20.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IERC20, IERC20Permit} from \"src/misc/interfaces/IERC20.sol\";\nimport {IERC1271} from \"src/misc/libraries/SignatureLib.sol\";\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\n\nimport \"forge-std/Test.sol\";\n\ncontract MockMultisig is IERC1271 {\n    address public immutable signer1;\n    address public immutable signer2;\n\n    constructor(address signer1_, address signer2_) {\n        signer1 = signer1_;\n        signer2 = signer2_;\n    }\n\n    function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4 sig) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        if (signer1 == ecrecover(digest, v, r, s)) {\n            assembly {\n                r := mload(add(signature, 0x80))\n                s := mload(add(signature, 0xA0))\n                v := byte(0, mload(add(signature, 0xC0)))\n            }\n            if (signer2 == ecrecover(digest, v, r, s)) {\n                sig = IERC1271.isValidSignature.selector;\n            }\n        }\n    }\n\n    // Added to be ignored in coverage report\n    function test() public {}\n}\n\n/// @author Modified from https://github.com/makerdao/xdomain-dss/blob/master/src/test/Dai.t.sol\ncontract ERC20Test is Test {\n    ERC20 token;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    bytes32 constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    function setUp() public {\n        token = new ERC20(18);\n    }\n\n    function testPermissions(address anotherWard) public {\n        vm.assume(anotherWard != address(this));\n\n        token.rely(anotherWard);\n        assertEq(token.wards(anotherWard), 1);\n        token.deny(anotherWard);\n        assertEq(token.wards(anotherWard), 0);\n    }\n\n    function testFile(string memory newName, string memory newSymbol, address invalidOrigin) public {\n        vm.assume(invalidOrigin != address(this));\n\n        vm.prank(invalidOrigin);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        token.file(\"name\", newName);\n\n        vm.expectRevert(ERC20.FileUnrecognizedParam.selector);\n        token.file(\"notName\", newName);\n\n        token.file(\"name\", newName);\n        assertEq(token.name(), newName);\n\n        token.file(\"symbol\", newSymbol);\n        assertEq(token.symbol(), newSymbol);\n    }\n\n    function testMint() public {\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0), address(0xBEEF), 1e18);\n        token.mint(address(0xBEEF), 1e18);\n\n        assertEq(token.totalSupply(), 1e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testMintBadAddress() public {\n        vm.expectRevert(IERC20.InvalidAddress.selector);\n        token.mint(address(0), 1e18);\n        vm.expectRevert(IERC20.InvalidAddress.selector);\n        token.mint(address(token), 1e18);\n    }\n\n    function testBurn() public {\n        token.mint(address(0xBEEF), 1e18);\n        token.rely(address(0xBEEF));\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0xBEEF), address(0), 0.9e18);\n        vm.prank(address(0xBEEF));\n        token.burn(address(0xBEEF), 0.9e18);\n\n        assertEq(token.totalSupply(), 1e18 - 0.9e18);\n        assertEq(token.balanceOf(address(0xBEEF)), 0.1e18);\n    }\n\n    function testBurnWithAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(address(0xBEEF), 1e18);\n        token.rely(address(from));\n\n        vm.prank(address(from));\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        token.burn(address(0xBEEF), 0.9e18);\n\n        vm.prank(address(0xBEEF));\n        token.approve(address(from), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(0xBEEF), address(0), 0.9e18);\n        vm.prank(address(from));\n        token.burn(address(0xBEEF), 0.9e18);\n    }\n\n    function testApprove() public {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(address(this), address(0xBEEF), 1e18);\n        assertTrue(token.approve(address(0xBEEF), 1e18));\n\n        assertEq(token.allowance(address(this), address(0xBEEF)), 1e18);\n    }\n\n    function testTransfer() public {\n        token.mint(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), address(0xBEEF), 1e18);\n        assertTrue(token.transfer(address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferBadAddress() public {\n        token.mint(address(this), 1e18);\n\n        vm.expectRevert(IERC20.InvalidAddress.selector);\n        token.transfer(address(0), 1e18);\n        vm.expectRevert(IERC20.InvalidAddress.selector);\n        token.transfer(address(token), 1e18);\n    }\n\n    function testTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0xBEEF), 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), 0);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testTransferFromBadAddress() public {\n        token.mint(address(this), 1e18);\n\n        vm.expectRevert(IERC20.InvalidAddress.selector);\n        token.transferFrom(address(this), address(0), 1e18);\n        vm.expectRevert(IERC20.InvalidAddress.selector);\n        token.transferFrom(address(this), address(token), 1e18);\n    }\n\n    function testInfiniteApproveTransferFrom() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        vm.expectEmit(true, true, true, true);\n        emit Approval(from, address(this), type(uint256).max);\n        token.approve(address(this), type(uint256).max);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0xBEEF), 1e18);\n        assertTrue(token.transferFrom(from, address(0xBEEF), 1e18));\n        assertEq(token.totalSupply(), 1e18);\n\n        assertEq(token.allowance(from, address(this)), type(uint256).max);\n\n        assertEq(token.balanceOf(from), 0);\n        assertEq(token.balanceOf(address(0xBEEF)), 1e18);\n    }\n\n    function testPermit() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit Approval(owner, address(0xCAFE), 1e18);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n\n        assertEq(token.allowance(owner, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testPermitContract() public {\n        uint256 privateKey1 = 0xBEEF;\n        address signer1 = vm.addr(privateKey1);\n        uint256 privateKey2 = 0xBEEE;\n        address signer2 = vm.addr(privateKey2);\n\n        address mockMultisig = address(new MockMultisig(signer1, signer2));\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            uint256(privateKey1),\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, mockMultisig, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        (uint8 v2, bytes32 r2, bytes32 s2) = vm.sign(\n            uint256(privateKey2),\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, mockMultisig, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        bytes memory signature = abi.encode(r, s, bytes32(uint256(v) << 248), r2, s2, bytes32(uint256(v2) << 248));\n        vm.expectEmit(true, true, true, true);\n        emit Approval(mockMultisig, address(0xCAFE), 1e18);\n        token.permit(mockMultisig, address(0xCAFE), 1e18, block.timestamp, signature);\n\n        assertEq(token.allowance(mockMultisig, address(0xCAFE)), 1e18);\n        assertEq(token.nonces(mockMultisig), 1);\n    }\n\n    function testPermitContractInvalidSignature() public {\n        uint256 privateKey1 = 0xBEEF;\n        address signer1 = vm.addr(privateKey1);\n        uint256 privateKey2 = 0xBEEE;\n        address signer2 = vm.addr(privateKey2);\n\n        address mockMultisig = address(new MockMultisig(signer1, signer2));\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            uint256(privateKey1),\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, mockMultisig, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        (uint8 v2, bytes32 r2, bytes32 s2) = vm.sign(\n            uint256(0xCEEE),\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, mockMultisig, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        bytes memory signature = abi.encode(r, s, bytes32(uint256(v) << 248), r2, s2, bytes32(uint256(v2) << 248));\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(mockMultisig, address(0xCAFE), 1e18, block.timestamp, signature);\n    }\n\n    function testTransferInsufficientBalance() public {\n        token.mint(address(this), 0.9e18);\n        vm.expectRevert(IERC20.InsufficientBalance.selector);\n        token.transfer(address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromInsufficientAllowance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 1e18);\n\n        vm.prank(from);\n        token.approve(address(this), 0.9e18);\n\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testTransferFromInsufficientBalance() public {\n        address from = address(0xABCD);\n\n        token.mint(from, 0.9e18);\n\n        vm.prank(from);\n        token.approve(address(this), 1e18);\n\n        vm.expectRevert(IERC20.InsufficientBalance.selector);\n        token.transferFrom(from, address(0xBEEF), 1e18);\n    }\n\n    function testPermitBadNonce() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 1, block.timestamp))\n                )\n            )\n        );\n\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testPermitBadDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp + 1, v, r, s);\n    }\n\n    function testPermitPastDeadline() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = vm.addr(privateKey);\n        uint256 deadline = block.timestamp == 0 ? 0 : block.timestamp - 1;\n\n        bytes32 domain_separator = token.DOMAIN_SEPARATOR();\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    domain_separator,\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, deadline))\n                )\n            )\n        );\n\n        vm.warp(deadline + 1);\n\n        vm.expectRevert(IERC20Permit.PermitExpired.selector);\n        token.permit(owner, address(0xCAFE), 1e18, deadline, v, r, s);\n    }\n\n    function testPermitReplay() public {\n        uint256 privateKey = 0xBEEF;\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(0xCAFE), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(owner, address(0xCAFE), 1e18, block.timestamp, v, r, s);\n    }\n\n    function testMint(address to, uint256 amount) public {\n        if (to != address(0) && to != address(token)) {\n            vm.expectEmit(true, true, true, true);\n            emit Transfer(address(0), to, amount);\n        } else {\n            vm.expectRevert(IERC20.InvalidAddress.selector);\n        }\n        token.mint(to, amount);\n\n        if (to != address(0) && to != address(token)) {\n            assertEq(token.totalSupply(), amount);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testBurn(address from, uint256 mintAmount, uint256 burnAmount) public {\n        if (from == address(0) || from == address(token)) return;\n\n        burnAmount = bound(burnAmount, 0, mintAmount);\n\n        token.mint(from, mintAmount);\n        token.rely(from);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, address(0), burnAmount);\n        vm.prank(from);\n        token.burn(from, burnAmount);\n\n        assertEq(token.totalSupply(), mintAmount - burnAmount);\n        assertEq(token.balanceOf(from), mintAmount - burnAmount);\n    }\n\n    function testApprove(address to, uint256 amount) public {\n        vm.expectEmit(true, true, true, true);\n        emit Approval(address(this), to, amount);\n        assertTrue(token.approve(to, amount));\n\n        assertEq(token.allowance(address(this), to), amount);\n    }\n\n    function testTransfer(address to, uint256 amount) public {\n        if (to == address(0) || to == address(token)) return;\n\n        token.mint(address(this), amount);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(address(this), to, amount);\n        assertTrue(token.transfer(to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        if (address(this) == to) {\n            assertEq(token.balanceOf(address(this)), amount);\n        } else {\n            assertEq(token.balanceOf(address(this)), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testTransferFrom(address to, uint256 approval, uint256 amount) public {\n        if (to == address(0) || to == address(token)) return;\n\n        amount = bound(amount, 0, approval);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        vm.prank(from);\n        token.approve(address(this), approval);\n\n        vm.expectEmit(true, true, true, true);\n        emit Transfer(from, to, amount);\n        assertTrue(token.transferFrom(from, to, amount));\n        assertEq(token.totalSupply(), amount);\n\n        uint256 app = from == address(this) || approval == type(uint256).max ? approval : approval - amount;\n        assertEq(token.allowance(from, address(this)), app);\n\n        if (from == to) {\n            assertEq(token.balanceOf(from), amount);\n        } else {\n            assertEq(token.balanceOf(from), 0);\n            assertEq(token.balanceOf(to), amount);\n        }\n    }\n\n    function testPermit(uint248 privKey, address to, uint256 amount, uint256 deadline) public {\n        uint256 privateKey = privKey;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit Approval(owner, to, amount);\n        token.permit(owner, to, amount, deadline, v, r, s);\n\n        assertEq(token.allowance(owner, to), amount);\n        assertEq(token.nonces(owner), 1);\n    }\n\n    function testBurnInsufficientBalance(address to, uint256 mintAmount, uint256 burnAmount) public {\n        if (to == address(0) || to == address(token)) return;\n\n        if (mintAmount == type(uint256).max) mintAmount -= 1;\n        burnAmount = bound(burnAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(to, mintAmount);\n        vm.expectRevert(IERC20.InsufficientBalance.selector);\n        token.burn(to, burnAmount);\n    }\n\n    function testTransferInsufficientBalance(address to, uint256 mintAmount, uint256 sendAmount) public {\n        if (to == address(0) || to == address(token)) return;\n\n        if (mintAmount == type(uint256).max) mintAmount -= 1;\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        token.mint(address(this), mintAmount);\n        vm.expectRevert(IERC20.InsufficientBalance.selector);\n        token.transfer(to, sendAmount);\n    }\n\n    function testTransferFromInsufficientAllowance(address to, uint256 approval, uint256 amount) public {\n        if (to == address(0) || to == address(token)) return;\n\n        if (approval == type(uint256).max) approval -= 1;\n        amount = bound(amount, approval + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, amount);\n\n        vm.prank(from);\n        token.approve(address(this), approval);\n\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        token.transferFrom(from, to, amount);\n    }\n\n    function testTransferFromInsufficientBalance(address to, uint256 mintAmount, uint256 sendAmount) public {\n        if (to == address(0) || to == address(token)) return;\n\n        if (mintAmount == type(uint256).max) mintAmount -= 1;\n        sendAmount = bound(sendAmount, mintAmount + 1, type(uint256).max);\n\n        address from = address(0xABCD);\n\n        token.mint(from, mintAmount);\n\n        vm.prank(from);\n        token.approve(address(this), sendAmount);\n\n        vm.expectRevert(IERC20.InsufficientBalance.selector);\n        token.transferFrom(from, to, sendAmount);\n    }\n\n    function testPermitBadNonce(uint128 privateKey, address to, uint256 amount, uint256 deadline, uint256 nonce)\n        public\n    {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n        if (nonce == 0) nonce = 1;\n\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, nonce, deadline))\n                )\n            )\n        );\n\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testPermitBadDeadline(uint128 privateKey, address to, uint256 amount, uint256 deadline) public {\n        if (deadline == type(uint256).max) deadline -= 1;\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(owner, to, amount, deadline + 1, v, r, s);\n    }\n\n    function testPermitPastDeadline(uint128 privateKey, address to, uint256 amount, uint256 deadline) public {\n        if (deadline == type(uint256).max) deadline -= 1;\n        vm.warp(deadline);\n\n        // private key cannot be 0 for secp256k1 pubkey generation\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = vm.addr(privateKey);\n\n        bytes32 domain_separator = token.DOMAIN_SEPARATOR();\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\", domain_separator, keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        vm.warp(deadline + 1);\n\n        vm.expectRevert(IERC20Permit.PermitExpired.selector);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n\n    function testPermitReplay(uint128 privateKey, address to, uint256 amount, uint256 deadline) public {\n        if (deadline < block.timestamp) deadline = block.timestamp;\n        if (privateKey == 0) privateKey = 1;\n\n        address owner = vm.addr(privateKey);\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    token.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, to, amount, 0, deadline))\n                )\n            )\n        );\n\n        token.permit(owner, to, amount, deadline, v, r, s);\n        vm.expectRevert(IERC20Permit.InvalidPermit.selector);\n        token.permit(owner, to, amount, deadline, v, r, s);\n    }\n}\n"
    },
    "test/misc/unit/IdentityValuation.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {IdentityValuation} from \"src/misc/IdentityValuation.sol\";\n\nimport {MockERC6909} from \"test/misc/mocks/MockERC6909.sol\";\n\naddress constant C6 = address(6);\naddress constant C18 = address(18);\n\ncontract TestIdentityValuation is Test {\n    IdentityValuation valuation = new IdentityValuation(new MockERC6909(), address(0));\n\n    function testSameDecimals() public view {\n        assertEq(valuation.getQuote(100 * 1e6, C6, C6), 100 * 1e6);\n    }\n\n    function testFromMoreDecimalsToLess() public view {\n        assertEq(valuation.getQuote(100 * 1e18, C18, C6), 100 * 1e6);\n    }\n\n    function testFromLessDecimalsToMore() public view {\n        assertEq(valuation.getQuote(100 * 1e6, C6, C18), 100 * 1e18);\n    }\n}\n"
    },
    "test/misc/unit/Multicall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {IMulticall} from \"src/misc/interfaces/IMulticall.sol\";\nimport {Multicall} from \"src/misc/Multicall.sol\";\nimport {ReentrancyProtection} from \"src/misc/ReentrancyProtection.sol\";\n\ncontract ExternalContract {\n    MulticallImpl public multicall;\n\n    constructor(MulticallImpl multicall_) {\n        multicall = multicall_;\n    }\n\n    function add(uint256 value_) public {\n        multicall.add(value_);\n    }\n}\n\ncontract MulticallImpl is Multicall {\n    uint256 public value;\n    ExternalContract public ext;\n\n    function setExternalContract(ExternalContract ext_) public {\n        ext = ext_;\n    }\n\n    function add(uint256 value_) external protected {\n        value += value_;\n    }\n\n    function err() external protected {\n        revert(\"error\");\n    }\n\n    function errEmpty() external protected {\n        revert();\n    }\n\n    function addWithReentrancy(uint256 value_) external protected {\n        ext.add(value_);\n    }\n}\n\ncontract MulticallTest is Test {\n    MulticallImpl multicall = new MulticallImpl();\n    ExternalContract ext = new ExternalContract(multicall);\n\n    function setUp() public {\n        multicall.setExternalContract(ext);\n    }\n\n    function testSuccess() public {\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(multicall.add.selector, 2);\n        calls[1] = abi.encodeWithSelector(multicall.add.selector, 3);\n\n        multicall.multicall(calls);\n\n        assertEq(multicall.value(), 5);\n    }\n\n    function testSeveralMulticallsInSingleTransaction() public {\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(multicall.add.selector, 2);\n        calls[1] = abi.encodeWithSelector(multicall.add.selector, 3);\n\n        multicall.multicall(calls);\n        // Initiator should be 0 at this point\n\n        multicall.multicall(calls);\n\n        assertEq(multicall.value(), 10);\n    }\n\n    function testRevertAtError() public {\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(multicall.add.selector, 2);\n        calls[1] = abi.encodeWithSelector(multicall.err.selector);\n\n        vm.expectRevert(\"error\");\n        multicall.multicall(calls);\n\n        // It reverts the whole transaction when the first error appears\n        assertEq(multicall.value(), 0);\n    }\n\n    function testErrCallFailedWithEmptyRevert() public {\n        bytes[] memory calls = new bytes[](1);\n        calls[0] = abi.encodeWithSelector(multicall.errEmpty.selector);\n\n        vm.expectRevert(IMulticall.CallFailedWithEmptyRevert.selector);\n        multicall.multicall(calls);\n    }\n\n    function testErrUnauthorizedSender() public {\n        bytes[] memory calls = new bytes[](1);\n        calls[0] = abi.encodeWithSelector(multicall.addWithReentrancy.selector, 2);\n\n        vm.expectRevert(ReentrancyProtection.UnauthorizedSender.selector);\n        multicall.multicall(calls);\n    }\n}\n"
    },
    "test/misc/unit/Recoverable.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Auth, IAuth} from \"src/misc/Auth.sol\";\nimport {Recoverable} from \"src/misc/Recoverable.sol\";\nimport {ERC20} from \"src/misc/ERC20.sol\";\n\nimport \"forge-std/Test.sol\";\nimport {MockERC6909} from \"test/misc/mocks/MockERC6909.sol\";\n\ncontract RecoverableImpl is Recoverable {\n    constructor(address deployer) Auth(deployer) {}\n}\n\ncontract TestRecoverable is Test {\n    uint256 constant AMOUNT = 100;\n    uint256 constant TOKEN_ID = 23;\n    address immutable RECEIVER = makeAddr(\"receiver\");\n\n    Recoverable recoverable = new RecoverableImpl(address(this));\n\n    function testErrNotAuthorized() public {\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        recoverable.recoverTokens(address(0), address(0), 0);\n\n        vm.prank(makeAddr(\"unauthorizedAddress\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        recoverable.recoverTokens(address(0), 0, address(0), 0);\n    }\n\n    function testRecoverTokensETH() public {\n        address ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n        vm.deal(address(recoverable), AMOUNT);\n\n        recoverable.recoverTokens(ETH, 0, RECEIVER, AMOUNT);\n\n        assertEq(address(recoverable).balance, 0);\n        assertEq(RECEIVER.balance, AMOUNT);\n    }\n\n    function testRecoverTokensERC20() public {\n        ERC20 token = new ERC20(18);\n        token.mint(address(recoverable), AMOUNT);\n\n        recoverable.recoverTokens(address(token), 0, RECEIVER, AMOUNT);\n\n        assertEq(token.balanceOf(address(recoverable)), 0);\n        assertEq(token.balanceOf(RECEIVER), AMOUNT);\n    }\n\n    function testRecoverTokensERC6909() public {\n        MockERC6909 token = new MockERC6909();\n        token.mint(address(recoverable), TOKEN_ID, AMOUNT);\n\n        recoverable.recoverTokens(address(token), TOKEN_ID, RECEIVER, AMOUNT);\n\n        assertEq(token.balanceOf(address(recoverable), TOKEN_ID), 0);\n        assertEq(token.balanceOf(RECEIVER, TOKEN_ID), AMOUNT);\n    }\n}\n"
    },
    "test/misc/unit/SignatureLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport \"src/misc/libraries/SignatureLib.sol\";\nimport \"src/misc/libraries/EIP712Lib.sol\";\n\ncontract MockValidSigner {\n    function isValidSignature(bytes32, bytes memory) public pure returns (bytes4) {\n        return IERC1271.isValidSignature.selector;\n    }\n}\n\ncontract MockInvalidSigner {\n    function isValidSignature(bytes32, bytes memory) public pure returns (bytes4) {\n        return 0xdeadbeef; // Invalid return value\n    }\n}\n\ncontract MockFailingSigner {\n    function isValidSignature(bytes32, bytes memory) public pure {\n        revert(\"Signature validation failed\");\n    }\n}\n\ncontract SignatureLibTest is Test {\n    bytes32 private constant DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\n    bytes32 private constant DIGEST = 0x1111111111111111111111111111111111111111111111111111111111111111;\n    bytes private constant DUMMY_SIGNATURE = hex\"1234567890\";\n\n    bytes32 private nameHash;\n    bytes32 private versionHash;\n    bytes32 private domainSeparator;\n    address private owner;\n    uint256 private ownerPk;\n    address private wrongOwner;\n    uint256 private wrongOwnerPk;\n\n    function setUp() public {\n        nameHash = keccak256(bytes(\"Centrifuge\"));\n        versionHash = keccak256(bytes(\"1\"));\n        domainSeparator = EIP712Lib.calculateDomainSeparator(nameHash, versionHash);\n        (owner, ownerPk) = makeAddrAndKey(\"owner\");\n        (wrongOwner, wrongOwnerPk) = makeAddrAndKey(\"wrongOwner\");\n    }\n\n    function testValidEOASignature() public view {\n        bytes32 digest = _calculateTestDigest();\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n\n        assertTrue(SignatureLib.isValidSignature(owner, digest, signature));\n    }\n\n    function testInvalidEOASignature() public view {\n        bytes32 digest = _calculateTestDigest();\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(wrongOwnerPk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n\n        assertFalse(SignatureLib.isValidSignature(owner, digest, signature));\n    }\n\n    function testWrongDigestEOASignature() public view {\n        bytes32 digest = _calculateTestDigest();\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPk, digest);\n        bytes memory signature = abi.encodePacked(r, s, v);\n\n        assertFalse(SignatureLib.isValidSignature(owner, keccak256(\"Wrong digest\"), signature));\n    }\n\n    function testValidContractSignature() public {\n        MockValidSigner signer = new MockValidSigner();\n        bool isValid = SignatureLib.isValidSignature(address(signer), DIGEST, DUMMY_SIGNATURE);\n        assertTrue(isValid);\n    }\n\n    function testInvalidContractSignature() public {\n        MockInvalidSigner signer = new MockInvalidSigner();\n        bool isValid = SignatureLib.isValidSignature(address(signer), DIGEST, DUMMY_SIGNATURE);\n        assertFalse(isValid);\n    }\n\n    function testErrContractSignature() public {\n        MockFailingSigner signer = new MockFailingSigner();\n        vm.expectRevert(SignatureLib.InvalidSigner.selector);\n        SignatureLib.isValidSignature(address(signer), DIGEST, DUMMY_SIGNATURE);\n    }\n\n    function testSignatureReplay() public view {\n        bytes32 digest1 = _calculateTestDigest();\n        bytes32 digest2 = keccak256(\"Different message\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPk, digest1);\n        bytes memory signature = abi.encodePacked(r, s, v);\n\n        assertTrue(SignatureLib.isValidSignature(owner, digest1, signature));\n        assertFalse(SignatureLib.isValidSignature(owner, digest2, signature));\n    }\n\n    function _calculateTestDigest() private view returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, keccak256(abi.encode(keccak256(\"Test()\")))));\n    }\n}\n"
    },
    "test/misc/unit/libraries/ArrayLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {ArrayLib} from \"src/misc/libraries/ArrayLib.sol\";\n\ncontract ArrayLibTest is Test {\n    // Used for testDecreaseFirstNValues (which requires storage pointers)\n    uint16[8] initialArray;\n    uint16[8] decreasedArray;\n\n    function testCountNonZeroValues(uint8 numNonZeroes) public view {\n        numNonZeroes = uint8(bound(numNonZeroes, 0, 8));\n        uint16[8] memory arr = _randomArray(numNonZeroes);\n\n        assertEq(ArrayLib.countNonZeroValues(arr), numNonZeroes);\n    }\n\n    function testDecreaseFirstNValues(uint8 numValuesToDecrease) public {\n        numValuesToDecrease = uint8(bound(numValuesToDecrease, 0, 8));\n\n        initialArray = _randomArray(8);\n        decreasedArray = initialArray;\n        uint8 numNonZeroes = ArrayLib.countNonZeroValues(initialArray);\n\n        // Decreasing by 1 should reduce by min(numNonZeroes, numValuesToDecrease) since zero values cannot be decreased\n        ArrayLib.decreaseFirstNValues(decreasedArray, numValuesToDecrease);\n        assertEq(_count(initialArray) - _count(decreasedArray), _min(numNonZeroes, numValuesToDecrease));\n    }\n\n    function testIsEmpty(uint8 numNonZeroes) public view {\n        numNonZeroes = uint8(bound(numNonZeroes, 0, 8));\n        uint16[8] memory arr = _randomArray(numNonZeroes);\n\n        // Array is only empty if there are no zeros\n        assertEq(ArrayLib.isEmpty(arr), numNonZeroes == 0);\n    }\n\n    function _randomArray(uint8 numNonZeroes) internal view returns (uint16[8] memory arr) {\n        for (uint256 i; i < numNonZeroes; i++) {\n            arr[i] = _randomUint16(1, type(uint16).max);\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? b : a;\n    }\n\n    function _count(uint16[8] memory arr) internal pure returns (uint256 count) {\n        for (uint256 i; i < arr.length; i++) {\n            count += uint8(arr[i]);\n        }\n    }\n\n    function _randomUint16(uint16 minValue, uint16 maxValue) internal view returns (uint16) {\n        uint256 nonce = 1;\n\n        if (maxValue == 1) {\n            return 1;\n        }\n\n        uint16 value =\n            uint16(uint256(keccak256(abi.encodePacked(block.timestamp, address(this), nonce))) % (maxValue - minValue));\n        return value + minValue;\n    }\n}\n"
    },
    "test/misc/unit/libraries/BytesLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\n\ncontract BytesLibTest is Test {\n    function testSlice(bytes memory data, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(data)), randomEnd);\n        assertEq(BytesLib.slice(value, randomStart.length, data.length), data);\n    }\n\n    function testToAddress(address addr, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(addr)), randomEnd);\n        assertEq(BytesLib.toAddress(value, randomStart.length), addr);\n    }\n\n    function testToUint8(uint8 number, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(number)), randomEnd);\n        assertEq(BytesLib.toUint8(value, randomStart.length), number);\n    }\n\n    function testToUint16(uint16 number, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(number)), randomEnd);\n        assertEq(BytesLib.toUint16(value, randomStart.length), number);\n    }\n\n    function testToUint32(uint32 number, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(number)), randomEnd);\n        assertEq(BytesLib.toUint32(value, randomStart.length), number);\n    }\n\n    function testToUint64(uint64 number, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(number)), randomEnd);\n        assertEq(BytesLib.toUint64(value, randomStart.length), number);\n    }\n\n    function testToUint128(uint128 number, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(number)), randomEnd);\n        assertEq(BytesLib.toUint128(value, randomStart.length), number);\n    }\n\n    function testToBytes32(bytes32 data, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(data)), randomEnd);\n        assertEq(BytesLib.toBytes32(value, randomStart.length), data);\n    }\n\n    function testToBytes16(bytes16 data, bytes memory randomStart, bytes memory randomEnd) public pure {\n        bytes memory value = bytes.concat(bytes.concat(randomStart, abi.encodePacked(data)), randomEnd);\n        assertEq(BytesLib.toBytes16(value, randomStart.length), data);\n    }\n}\n"
    },
    "test/misc/unit/libraries/CastLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\n\ncontract CastLibTest is Test {\n    function testToAddress(address addr) public pure {\n        assertEq(CastLib.toAddress(bytes32(bytes20(addr))), addr);\n    }\n\n    function testToAddressInvalid(address addr, bytes12 nonZero) public {\n        vm.assume(uint96(nonZero) > 0);\n\n        bytes32 input = bytes32(bytes.concat(bytes20(addr), nonZero));\n\n        vm.expectRevert(bytes(\"Input should be 20 bytes\"));\n        this.toAddress(input);\n    }\n\n    function toAddress(bytes32 input) external pure returns (address) {\n        return CastLib.toAddress(input);\n    }\n}\n"
    },
    "test/misc/unit/libraries/D18.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport \"src/misc/types/D18.sol\";\nimport \"src/misc/libraries/MathLib.sol\";\n\ncontract D18Test is Test {\n    function testFuzzAdd(uint128 a, uint128 b) public pure {\n        vm.assume(a <= type(uint128).max / 2);\n        vm.assume(b <= type(uint128).max / 2);\n\n        D18 c = d18(a) + d18(b);\n        assertEqDecimal(c.inner(), a + b, 18);\n    }\n\n    function testFuzzSub(uint128 a, uint128 b) public pure {\n        vm.assume(a >= b);\n\n        D18 c = d18(a) - d18(b);\n        assertEqDecimal(c.inner(), a - b, 18);\n    }\n\n    function testMulUint128() public pure {\n        D18 factor = d18(1_500_000_000_000_000_000); // 1.5\n        uint128 value = 4_000_000_000_000_000;\n\n        assertEq(factor.mulUint128(value, MathLib.Rounding.Down), 6_000_000_000_000_000);\n        assertEq(factor.mulUint128(value, MathLib.Rounding.Up), 6_000_000_000_000_000);\n    }\n\n    function testFuzzMulUInt128(uint128 a, uint128 b) public pure {\n        a = uint128(bound(a, 1, type(uint128).max));\n        b = uint128(bound(b, 0, type(uint128).max / a));\n\n        uint128 cDown = d18(a).mulUint128(b, MathLib.Rounding.Down);\n        uint128 cUp = d18(a).mulUint128(b, MathLib.Rounding.Down);\n        assertEq(cDown, MathLib.mulDiv(a, b, 1e18));\n        assertEq(cUp, MathLib.mulDiv(a, b, 1e18));\n    }\n\n    function testRoundingUint128(uint128 a) public pure {\n        a = uint128(bound(a, 0, type(uint128).max / 1e18));\n        D18 oneHundredPercent = d18(1e18);\n\n        assertEq(oneHundredPercent.mulUint128(a, MathLib.Rounding.Down), a);\n        assertEq(oneHundredPercent.mulUint128(a, MathLib.Rounding.Up), a);\n    }\n\n    function testMulUint256() public pure {\n        D18 factor = d18(1_500_000_000_000_000_000); // 1.5\n        uint256 value = 4_000_000_000_000_000_000_000_000;\n\n        assertEq(factor.mulUint256(value, MathLib.Rounding.Down), 6_000_000_000_000_000_000_000_000);\n        assertEq(factor.mulUint256(value, MathLib.Rounding.Up), 6_000_000_000_000_000_000_000_000);\n    }\n\n    function testFuzzMulUInt256(uint128 a, uint256 b) public pure {\n        a = uint128(bound(a, 1, type(uint128).max));\n        b = uint256(bound(b, 0, type(uint256).max / a));\n\n        uint256 cDown = d18(a).mulUint256(b, MathLib.Rounding.Down);\n        uint256 cUp = d18(a).mulUint256(b, MathLib.Rounding.Down);\n        assertEq(cDown, MathLib.mulDiv(a, b, 1e18));\n        assertEq(cUp, MathLib.mulDiv(a, b, 1e18));\n    }\n\n    function testRoundingUint256(uint256 a) public pure {\n        a = bound(a, 0, type(uint256).max / 1e18);\n        D18 oneHundredPercent = d18(1e18);\n\n        assertEq(oneHundredPercent.mulUint256(a, MathLib.Rounding.Down), a);\n        assertEq(oneHundredPercent.mulUint256(a, MathLib.Rounding.Up), a);\n    }\n\n    function testReciprocalMulInt128() public pure {\n        D18 divisor = d18(2e18);\n        uint128 multiplier = 1e20;\n\n        assertEq(divisor.reciprocalMulUint128(multiplier, MathLib.Rounding.Down), 5e19);\n        assertEq(divisor.reciprocalMulUint128(multiplier, MathLib.Rounding.Up), 5e19);\n    }\n\n    function testFuzzReciprocalMulInt128(uint128 divisor_, uint128 multiplier) public pure {\n        D18 divisor = d18(uint128(bound(divisor_, 1e4, 1e20)));\n        multiplier = uint128(bound(multiplier, 0, type(uint128).max / 1e18));\n\n        uint128 expectedDown = multiplier * 1e18 / divisor.inner();\n        uint128 expectedUp = (multiplier * 1e18 % divisor.raw()) == 0 ? expectedDown : expectedDown + 1;\n\n        assertEq(divisor.reciprocalMulUint128(multiplier, MathLib.Rounding.Down), expectedDown);\n        assertEq(divisor.reciprocalMulUint128(multiplier, MathLib.Rounding.Up), expectedUp);\n    }\n\n    function testReciprocalMulInt256() public pure {\n        D18 divisor = d18(2e18);\n        uint256 multiplier = 1e20;\n\n        assertEq(divisor.reciprocalMulUint256(multiplier, MathLib.Rounding.Down), 5e19);\n        assertEq(divisor.reciprocalMulUint256(multiplier, MathLib.Rounding.Up), 5e19);\n    }\n\n    function testFuzzReciprocalMulInt256(uint128 divisor_, uint256 multiplier) public pure {\n        D18 divisor = d18(uint128(bound(divisor_, 1e4, 1e20)));\n        multiplier = bound(multiplier, 0, type(uint256).max / 1e18);\n\n        uint256 expectedDown = multiplier * 1e18 / divisor.inner();\n        uint256 expectedUp = (multiplier * 1e18 % divisor.raw()) == 0 ? expectedDown : expectedDown + 1;\n\n        assertEq(divisor.reciprocalMulUint256(multiplier, MathLib.Rounding.Down), expectedDown);\n        assertEq(divisor.reciprocalMulUint256(multiplier, MathLib.Rounding.Up), expectedUp);\n    }\n\n    function testMulD18() public pure {\n        D18 left = d18(50e18);\n        D18 right = d18(2e19);\n\n        assertEq(mulD18(left, right).inner(), 100e19);\n    }\n\n    function testFuzzMulD18(uint128 left_, uint128 right_) public pure {\n        D18 left = d18(uint128(bound(left_, 1, type(uint128).max)));\n        D18 right = d18(uint128(bound(right_, 0, type(uint128).max / left.inner())));\n\n        assertEq(mulD18(left, right).inner(), left.inner() * right.inner() / 1e18);\n    }\n\n    function testDivD18() public pure {\n        D18 numerator = d18(50e18);\n        D18 denominator = d18(2e19);\n\n        assertEq(divD18(numerator, denominator).inner(), 25e17);\n    }\n\n    function testFuzzDivD18(uint128 numerator_, uint128 denominator_) public pure {\n        D18 numerator = d18(uint128(bound(numerator_, 1, 1e20)));\n        D18 denominator = d18(uint128(bound(denominator_, 1, 1e20)));\n\n        assertEq(divD18(numerator, denominator).inner(), numerator.inner() * 1e18 / denominator.inner());\n    }\n\n    function testEqD18() public pure {\n        D18 a = d18(5234);\n\n        assert(eq(a, a));\n        assert(!eq(a, d18(5235)));\n    }\n\n    function testRawD18() public pure {\n        uint128 a_ = 3245252;\n        D18 a = d18(a_);\n\n        assertEq(raw(a), a_);\n    }\n}\n\ncontract D18ReciprocalTest is Test {\n    /// @dev Fuzz test reciprocal function ensuring accurate calculation and round-trip multiplication.\n    function testFuzzReciprocal(uint128 val) public pure {\n        // Avoid division-by-zero, keep input reasonable\n        val = uint128(bound(val, 1, type(uint128).max / 1e18));\n        D18 input = D18.wrap(val);\n        D18 result = input.reciprocal();\n\n        uint128 expected = 1e36 / val;\n        assertApproxEqAbs(result.inner(), expected, 1, \"Reciprocal calculation mismatch\");\n\n        D18 roundTrip = input * result;\n        uint128 tolerance = 1e3; // very small relative error (~1e-15)\n        assertApproxEqAbs(roundTrip.inner(), 1e18, tolerance, \"Round-trip multiplication failed\");\n    }\n\n    /// @dev Explicitly test edge case for reciprocal(1e18) == 1e18\n    function testReciprocalOne() public pure {\n        D18 one = D18.wrap(1e18);\n        D18 result = one.reciprocal();\n        assertEq(result.inner(), 1e18, \"Reciprocal of 1e18 should be 1e18\");\n    }\n\n    /// @dev Explicitly test rounding edge cases close to 1\n    function testReciprocalRoundingEdges() public pure {\n        D18 almostOneUp = D18.wrap(1e18 + 1);\n        D18 almostOneDown = D18.wrap(1e18 - 1);\n\n        D18 resultUp = almostOneUp.reciprocal();\n        D18 resultDown = almostOneDown.reciprocal();\n\n        assertApproxEqAbs(resultUp.inner(), 1e18 - 1, 1, \"Rounding error (upward case)\");\n        assertApproxEqAbs(resultDown.inner(), 1e18 + 1, 1, \"Rounding error (downward case)\");\n    }\n}\n"
    },
    "test/misc/unit/libraries/MathLib.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport \"src/misc/libraries/MathLib.sol\";\n\ncontract MathLibTest is Test {\n    using MathLib for uint256;\n\n    function testRpow() public pure {\n        uint256 base = 10 ** 27;\n        uint256 x = 2 * 10 ** 27;\n        uint256 n = 3;\n\n        uint256 result = MathLib.rpow(x, n, base);\n        uint256 expected = 8 * 10 ** 27; // 2^3 = 8, scaled by base\n\n        assertEq(result, expected, \"Incorrect rpow calculation\");\n    }\n\n    function testMulDivDown(uint256 x, uint256 y, uint256 denominator) public pure {\n        // Ignore cases where x * y overflows or denominator is 0.\n        unchecked {\n            if (denominator == 0 || (x != 0 && (x * y) / x != y)) return;\n        }\n\n        assertEq(MathLib.mulDiv(x, y, denominator, MathLib.Rounding.Down), (x * y) / denominator);\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testMulDivDownZeroDenominator(uint256 x, uint256 y) public {\n        vm.expectRevert();\n        MathLib.mulDiv(x, y, 0, MathLib.Rounding.Down);\n    }\n\n    function testMulDivUp(uint256 x, uint256 y, uint256 denominator) public pure {\n        denominator = bound(denominator, 1, type(uint256).max - 1);\n        y = bound(y, 1, type(uint256).max);\n        x = bound(x, 0, (type(uint256).max - denominator - 1) / y);\n\n        assertEq(MathLib.mulDiv(x, y, denominator, MathLib.Rounding.Up), x * y == 0 ? 0 : (x * y - 1) / denominator + 1);\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testMulDivUpUnderverflow(uint256 x, uint256 y) public {\n        vm.assume(x > 0 && y > 0);\n\n        vm.expectRevert();\n        MathLib.mulDiv(x, y, 0, MathLib.Rounding.Up);\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testMulDivUpZeroDenominator(uint256 x, uint256 y) public {\n        vm.expectRevert();\n        MathLib.mulDiv(x, y, 0, MathLib.Rounding.Up);\n    }\n\n    function testToUint128(uint256 x) public pure {\n        x = bound(x, 0, type(uint128).max);\n\n        assertEq(x, uint256(MathLib.toUint128(x)));\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testToUint128Overflow(uint128 x) public {\n        vm.assume(x > 0);\n        vm.expectRevert(MathLib.Uint128_Overflow.selector);\n        MathLib.toUint128(uint256(type(uint128).max) + x);\n    }\n\n    function testToUint8(uint256 x) public pure {\n        x = bound(x, 0, type(uint8).max);\n\n        assertEq(x, uint256(MathLib.toUint8(x)));\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testToUint8Overflow(uint256 x) public {\n        vm.assume(x > type(uint8).max);\n        vm.expectRevert(MathLib.Uint8_Overflow.selector);\n        MathLib.toUint8(x);\n    }\n\n    function testToUint32(uint256 x) public pure {\n        x = bound(x, 0, type(uint32).max);\n\n        assertEq(x, uint256(MathLib.toUint32(x)));\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testToUint32Overflow(uint256 x) public {\n        vm.assume(x > type(uint32).max);\n        vm.expectRevert(MathLib.Uint32_Overflow.selector);\n        MathLib.toUint32(x);\n    }\n\n    function testToUint64(uint256 x) public pure {\n        x = bound(x, 0, type(uint64).max);\n\n        assertEq(x, uint256(MathLib.toUint64(x)));\n    }\n\n    /// forge-config: default.allow_internal_expect_revert = true\n    function testToUint64Overflow(uint256 x) public {\n        vm.assume(x > type(uint64).max);\n        vm.expectRevert(MathLib.Uint64_Overflow.selector);\n        MathLib.toUint64(x);\n    }\n\n    function testMin(uint256 x, uint256 y) public pure {\n        vm.assume(x > 0);\n        y = uint256(bound(y, 0, x - 1));\n        assertEq(MathLib.min(x, y), y);\n    }\n\n    function testMax(uint256 x, uint256 y) public pure {\n        vm.assume(x > 0);\n        y = uint256(bound(y, 0, x - 1));\n        assertEq(MathLib.max(x, y), x);\n    }\n}\n"
    },
    "test/misc/unit/libraries/PricingLib.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\ncontract PurePricingLibTest is Test {\n    using PricingLib for *;\n    using MathLib for uint256;\n\n    uint8 constant MIN_ASSET_DECIMALS = 2;\n    uint8 constant MAX_ASSET_DECIMALS = 18;\n    uint8 constant POOL_DECIMALS = 18;\n    uint8 constant SHARE_DECIMALS = POOL_DECIMALS;\n    uint128 constant MIN_PRICE = 1e14;\n    uint128 constant MAX_PRICE_POOL_PER_ASSET = 1e20;\n    uint128 constant MAX_PRICE_POOL_PER_SHARE = 1e20;\n    uint128 constant MAX_AMOUNT = type(uint128).max / MAX_PRICE_POOL_PER_SHARE;\n    MathLib.Rounding constant ROUNDING_DOWN = MathLib.Rounding.Down;\n\n    function testConvertWithPriceSameDecimals(uint128 baseAmount, uint128 priceRaw) public pure {\n        baseAmount = uint128(bound(baseAmount, 0, MAX_AMOUNT));\n        D18 price = d18(uint128(bound(priceRaw, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n\n        uint256 expected = price.mulUint256(baseAmount, ROUNDING_DOWN);\n        uint256 result = PricingLib.convertWithPrice(baseAmount, 18, 18, price);\n        assertEq(result, expected);\n    }\n\n    function testConvertWithPriceDifferentDecimals(\n        uint128 baseAmount,\n        uint8 baseDecimals,\n        uint8 quoteDecimals,\n        uint128 priceRaw\n    ) public pure {\n        baseAmount = uint128(bound(baseAmount, 0, MAX_AMOUNT));\n        baseDecimals = uint8(bound(baseDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        quoteDecimals = uint8(bound(quoteDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        D18 price = d18(uint128(bound(priceRaw, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n\n        uint256 scaledBase;\n        if (baseDecimals > quoteDecimals) {\n            scaledBase = baseAmount / (10 ** (baseDecimals - quoteDecimals));\n        } else {\n            scaledBase = baseAmount * (10 ** (quoteDecimals - baseDecimals));\n        }\n\n        uint256 expected = price.mulUint256(scaledBase, ROUNDING_DOWN);\n        uint256 result = PricingLib.convertWithPrice(baseAmount, baseDecimals, quoteDecimals, price);\n        assertEq(result, expected);\n    }\n\n    function testAssetToShareAmount(\n        uint128 assetAmount,\n        uint8 assetDecimals,\n        uint128 pricePoolPerAsset_,\n        uint128 pricePoolPerShare_\n    ) public pure {\n        assetDecimals = uint8(bound(assetDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        assetAmount = uint128(bound(assetAmount, 10 ** assetDecimals, MAX_AMOUNT));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n        D18 pricePoolPerShare = d18(uint128(bound(pricePoolPerShare_, MIN_PRICE, MAX_PRICE_POOL_PER_SHARE)));\n\n        uint256 expectedShareAmount = pricePoolPerShare.reciprocalMulUint256(\n            pricePoolPerAsset.mulUint256(\n                uint256(assetAmount).mulDiv(10 ** SHARE_DECIMALS, 10 ** assetDecimals), ROUNDING_DOWN\n            ),\n            ROUNDING_DOWN\n        );\n\n        uint256 result = PricingLib.assetToShareAmount(\n            assetAmount, assetDecimals, SHARE_DECIMALS, pricePoolPerAsset, pricePoolPerShare, ROUNDING_DOWN\n        );\n\n        assertEq(result, expectedShareAmount, \"assetToShareAmount failed\");\n    }\n\n    function testAssetToShareToAssetRoundTrip(\n        uint128 assetAmount,\n        uint8 assetDecimals,\n        uint64 pricePoolPerAsset_,\n        uint64 pricePoolPerShare_\n    ) public pure {\n        assetDecimals = uint8(bound(assetDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        assetAmount = uint128(bound(assetAmount, 10 ** assetDecimals, MAX_AMOUNT));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n        D18 pricePoolPerShare = d18(uint128(bound(pricePoolPerShare_, MIN_PRICE, MAX_PRICE_POOL_PER_SHARE)));\n\n        uint256 shareAmount = PricingLib.assetToShareAmount(\n            assetAmount, assetDecimals, POOL_DECIMALS, pricePoolPerAsset, pricePoolPerShare, ROUNDING_DOWN\n        );\n        uint256 assetRoundTrip = PricingLib.shareToAssetAmount(\n            shareAmount, POOL_DECIMALS, assetDecimals, pricePoolPerAsset, pricePoolPerShare, ROUNDING_DOWN\n        );\n\n        assertApproxEqAbs(\n            assetRoundTrip, assetAmount, MIN_PRICE * 10, \"Asset->Share->Asset roundtrip target precision excess\"\n        );\n    }\n\n    /// NOTE: Solely serves to represent the horrible precision for this round trip due to reciprocal multiplication\n    function testShareToAssetToShareRoundTrip(\n        uint128 shareAmount,\n        uint8 assetDecimals,\n        uint64 pricePoolPerAsset_,\n        uint64 pricePoolPerShare_\n    ) public pure {\n        assetDecimals = uint8(bound(assetDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n        D18 pricePoolPerShare = d18(uint128(bound(pricePoolPerShare_, MIN_PRICE, MAX_PRICE_POOL_PER_SHARE)));\n        shareAmount = uint128(bound(shareAmount, 10 ** assetDecimals, MAX_AMOUNT));\n\n        uint256 assetAmount = PricingLib.shareToAssetAmount(\n            shareAmount, POOL_DECIMALS, assetDecimals, pricePoolPerAsset, pricePoolPerShare, ROUNDING_DOWN\n        );\n        uint256 shareRoundTrip = PricingLib.assetToShareAmount(\n            assetAmount, assetDecimals, POOL_DECIMALS, pricePoolPerAsset, pricePoolPerShare, ROUNDING_DOWN\n        );\n        assertApproxEqAbs(\n            shareRoundTrip,\n            shareAmount,\n            MAX_PRICE_POOL_PER_SHARE,\n            \"Share->Asset->Share roundtrip target precision excess\"\n        );\n    }\n\n    function testShareToAssetAmount(\n        uint128 shareAmount,\n        uint8 assetDecimals,\n        uint64 pricePoolPerShare_,\n        uint64 pricePoolPerAsset_\n    ) public pure {\n        assetDecimals = uint8(bound(assetDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        shareAmount = uint128(bound(shareAmount, 1e18, MAX_AMOUNT));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n        D18 pricePoolPerShare = d18(uint128(bound(pricePoolPerShare_, MIN_PRICE, MAX_PRICE_POOL_PER_SHARE)));\n\n        uint256 expectedAssetAmount = pricePoolPerAsset.reciprocalMulUint256(\n            pricePoolPerShare.mulUint256(shareAmount, ROUNDING_DOWN).mulDiv(10 ** assetDecimals, 10 ** POOL_DECIMALS),\n            ROUNDING_DOWN\n        );\n\n        uint256 result = PricingLib.shareToAssetAmount(\n            shareAmount, POOL_DECIMALS, assetDecimals, pricePoolPerAsset, pricePoolPerShare, ROUNDING_DOWN\n        );\n\n        assertEq(result, expectedAssetAmount, \"shareToAssetAmount failed\");\n    }\n\n    function testPoolToAssetAmount(uint128 poolAmount, uint8 assetDecimals, uint64 pricePoolPerAsset_) public pure {\n        assetDecimals = uint8(bound(assetDecimals, MIN_ASSET_DECIMALS, MAX_ASSET_DECIMALS));\n        poolAmount = uint128(bound(poolAmount, 10 ** POOL_DECIMALS, MAX_AMOUNT));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, MIN_PRICE, MAX_PRICE_POOL_PER_ASSET)));\n\n        uint256 expectedAssetAmount = pricePoolPerAsset.reciprocalMulUint256(\n            uint256(poolAmount).mulDiv(10 ** assetDecimals, 10 ** POOL_DECIMALS), ROUNDING_DOWN\n        );\n        uint256 result =\n            PricingLib.poolToAssetAmount(poolAmount, POOL_DECIMALS, assetDecimals, pricePoolPerAsset, ROUNDING_DOWN);\n        assertEq(result, expectedAssetAmount, \"poolToAssetAmount failed\");\n    }\n\n    // Enhanced rounding edge-case check\n    function testRoundingEdgeCases() public pure {\n        uint256 baseAmount = 1;\n        uint8 baseDecimals = 8;\n        uint8 quoteDecimals = 18;\n\n        // Min base amount\n        D18 price = d18(1e18 - 1);\n        uint256 result = PricingLib.convertWithPrice(baseAmount, baseDecimals, quoteDecimals, price);\n        uint256 expected = price.mulUint256(1e10, ROUNDING_DOWN);\n        assertEq(result, expected, \"Rounding edge case 1 (min base amount) failed\");\n\n        // Very small price\n        price = d18(1e8);\n        result = PricingLib.convertWithPrice(baseAmount, baseDecimals, quoteDecimals, price);\n        expected = price.mulUint256(1e10, ROUNDING_DOWN);\n        assertEq(result, expected, \"Rounding edge case 2 (small price) failed\");\n\n        // Max baseAmount\n        baseAmount = type(uint128).max;\n        price = d18(type(uint64).max);\n        result = PricingLib.convertWithPrice(baseAmount, baseDecimals, quoteDecimals, price);\n        expected = price.mulUint256(baseAmount * (10 ** (quoteDecimals - baseDecimals)), ROUNDING_DOWN);\n        assertEq(result, expected, \"Rounding edge case 3 (max baseAmount) failed\");\n    }\n}\n"
    },
    "test/misc/unit/libraries/SafeTransferLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\n\n/// @dev Token not returning any boolean.\ncontract ERC20WithoutBoolean {\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address to, uint256 amount) public {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[to] += amount;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public {\n        // Skip allowance check.\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n    }\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n    }\n\n    function setBalance(address account, uint256 amount) public {\n        balanceOf[account] = amount;\n    }\n}\n\n/// @dev Token always returning false.\ncontract ERC20WithBooleanAlwaysFalse {\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public balanceOf;\n\n    function transfer(address to, uint256 amount) public returns (bool failure) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[to] += amount;\n        failure = false; // To silence warning.\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public returns (bool failure) {\n        // Skip allowance check.\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        failure = false; // To silence warning.\n    }\n\n    function approve(address spender, uint256 value) public returns (bool failure) {\n        allowance[msg.sender][spender] = value;\n        failure = false; // To silence warning\n    }\n\n    function setBalance(address account, uint256 amount) public {\n        balanceOf[account] = amount;\n    }\n}\n\n/// @author Modified from\n/// https://github.com/morpho-org/morpho-blue/blob/main/test/forge/libraries/SafeTransferLibTest.sol\ncontract SafeTransferLibTest is Test {\n    ERC20WithoutBoolean public tokenWithoutBoolean;\n    ERC20WithBooleanAlwaysFalse public tokenWithBooleanAlwaysFalse;\n\n    function setUp() public {\n        tokenWithoutBoolean = new ERC20WithoutBoolean();\n        tokenWithBooleanAlwaysFalse = new ERC20WithBooleanAlwaysFalse();\n    }\n\n    function testSafeTransfer(address to, uint256 amount) public {\n        tokenWithoutBoolean.setBalance(address(this), amount);\n\n        this.safeTransfer(address(tokenWithoutBoolean), to, amount);\n    }\n\n    function testSafeTransferFrom(address from, address to, uint256 amount) public {\n        tokenWithoutBoolean.setBalance(from, amount);\n\n        this.safeTransferFrom(address(tokenWithoutBoolean), from, to, amount);\n    }\n\n    function testApprove(address spender, uint256 amount) public {\n        this.safeApprove(address(tokenWithoutBoolean), spender, amount);\n    }\n\n    function testSafeTransferWithBoolFalse(address to, uint256 amount) public {\n        tokenWithBooleanAlwaysFalse.setBalance(address(this), amount);\n\n        vm.expectRevert(SafeTransferLib.SafeTransferFailed.selector);\n        this.safeTransfer(address(tokenWithBooleanAlwaysFalse), to, amount);\n    }\n\n    function testSafeTransferFromWithBoolFalse(address from, address to, uint256 amount) public {\n        tokenWithBooleanAlwaysFalse.setBalance(from, amount);\n\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        this.safeTransferFrom(address(tokenWithBooleanAlwaysFalse), from, to, amount);\n    }\n\n    function testSafeApproveWithBoolFalse(address spender, uint256 amount) public {\n        vm.expectRevert(SafeTransferLib.SafeApproveFailed.selector);\n        this.safeApprove(address(tokenWithBooleanAlwaysFalse), spender, amount);\n    }\n\n    function testSafeTransferWithNoCode(address to, uint256 amount) public {\n        vm.expectRevert(SafeTransferLib.NoCode.selector);\n        this.safeTransfer(makeAddr(\"non-existent\"), to, amount);\n    }\n\n    function testSafeTransferFromWithNoCode(address from, address to, uint256 amount) public {\n        vm.expectRevert(SafeTransferLib.NoCode.selector);\n        this.safeTransferFrom(makeAddr(\"non-existent\"), from, to, amount);\n    }\n\n    function testSafeApproveWithNoCode(address spender, uint256 amount) public {\n        vm.expectRevert(SafeTransferLib.NoCode.selector);\n        this.safeApprove(makeAddr(\"non-existent\"), spender, amount);\n    }\n\n    function safeTransfer(address token, address to, uint256 amount) external {\n        SafeTransferLib.safeTransfer(token, to, amount);\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 amount) external {\n        SafeTransferLib.safeTransferFrom(token, from, to, amount);\n    }\n\n    function safeApprove(address token, address spender, uint256 amount) external {\n        SafeTransferLib.safeApprove(token, spender, amount);\n    }\n}\n"
    },
    "test/misc/unit/libraries/StringLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport \"src/misc/libraries/StringLib.sol\";\n\ncontract StringLibTest is Test {\n    function testStringIsEmpty() public pure {\n        assertTrue(StringLib.isEmpty(\"\"));\n        assertFalse(StringLib.isEmpty(\"nonEmpty\"));\n    }\n}\n"
    },
    "test/misc/unit/libraries/TransientArrayLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {TransientArrayLib} from \"src/misc/libraries/TransientArrayLib.sol\";\n\ncontract TransientArrayLibTest is Test {\n    function testTransientArray(bytes32 invalidKey) public {\n        bytes32 key = keccak256(abi.encode(\"key\"));\n        vm.assume(key != invalidKey);\n\n        assertEq(TransientArrayLib.length(key), 0);\n\n        // Push 2 items\n        TransientArrayLib.push(key, bytes32(\"1\"));\n        TransientArrayLib.push(key, bytes32(\"2\"));\n\n        assertEq(TransientArrayLib.length(key), 2);\n\n        bytes32[] memory stored = TransientArrayLib.getBytes32(key);\n        assertEq(stored.length, 2);\n        assertEq(stored[0], bytes32(\"1\"));\n        assertEq(stored[1], bytes32(\"2\"));\n\n        // Push 1 more\n        TransientArrayLib.push(key, bytes32(\"3\"));\n\n        assertEq(TransientArrayLib.length(key), 3);\n\n        stored = TransientArrayLib.getBytes32(key);\n        assertEq(stored.length, 3);\n        assertEq(stored[0], bytes32(\"1\"));\n        assertEq(stored[1], bytes32(\"2\"));\n        assertEq(stored[2], bytes32(\"3\"));\n\n        // Clear\n        TransientArrayLib.clear(key);\n\n        assertEq(TransientArrayLib.length(key), 0);\n\n        stored = TransientArrayLib.getBytes32(key);\n        assertEq(stored.length, 0);\n\n        assertEq(TransientArrayLib.length(invalidKey), 0);\n    }\n}\n"
    },
    "test/misc/unit/libraries/TransientBytesLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {TransientBytesLib} from \"src/misc/libraries/TransientBytesLib.sol\";\n\ncontract TransientBytesLibTest is Test {\n    function testTransientBytes(bytes calldata data1, bytes calldata data2, bytes32 invalidKey) public {\n        bytes32 key = keccak256(abi.encode(\"key\"));\n        vm.assume(key != invalidKey);\n\n        TransientBytesLib.append(key, data1);\n        assertEq(TransientBytesLib.get(key), data1);\n\n        TransientBytesLib.append(key, data2);\n        assertEq(TransientBytesLib.get(key), bytes.concat(data1, data2));\n\n        assertEq(TransientBytesLib.get(invalidKey).length, 0);\n    }\n}\n"
    },
    "test/misc/unit/libraries/TransientStorageLib.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {TransientStorageLib} from \"src/misc/libraries/TransientStorageLib.sol\";\n\ncontract TransientStorageLibTest is Test {\n    function testAddress(bytes32 key, address value) public {\n        assertEq(TransientStorageLib.tloadAddress(key), address(0));\n        TransientStorageLib.tstore(key, value);\n        assertEq(TransientStorageLib.tloadAddress(key), value);\n    }\n\n    function testUint128(bytes32 key, uint128 value) public {\n        assertEq(TransientStorageLib.tloadUint128(key), uint128(0));\n        TransientStorageLib.tstore(key, value);\n        assertEq(TransientStorageLib.tloadUint128(key), value);\n    }\n\n    function testUint256(bytes32 key, uint256 value) public {\n        assertEq(TransientStorageLib.tloadUint256(key), uint256(0));\n        TransientStorageLib.tstore(key, value);\n        assertEq(TransientStorageLib.tloadUint256(key), value);\n    }\n\n    function testBytes32(bytes32 key, bytes32 value) public {\n        assertEq(TransientStorageLib.tloadBytes32(key), bytes32(\"\"));\n        TransientStorageLib.tstore(key, value);\n        assertEq(TransientStorageLib.tloadBytes32(key), value);\n    }\n\n    function testBool(bytes32 key, bool value) public {\n        assertEq(TransientStorageLib.tloadBool(key), false);\n        TransientStorageLib.tstore(key, value);\n        assertEq(TransientStorageLib.tloadBool(key), value);\n    }\n}\n"
    },
    "test/vaults/BaseTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\npragma abicoder v2;\n\nimport \"src/misc/interfaces/IERC20.sol\";\nimport {IERC6909Fungible} from \"src/misc/interfaces/IERC6909.sol\";\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {MockERC6909} from \"test/misc/mocks/MockERC6909.sol\";\n\nimport {MessageType, MessageLib, VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\nimport {ISafe} from \"src/common/interfaces/IGuardian.sol\";\nimport {Root} from \"src/common/Root.sol\";\nimport {Gateway} from \"src/common/Gateway.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {newAssetId} from \"src/common/types/AssetId.sol\";\nimport {PoolId, newPoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\n// core contracts\nimport {AsyncRequestManager} from \"src/vaults/AsyncRequestManager.sol\";\nimport {PoolManager} from \"src/vaults/PoolManager.sol\";\nimport {Escrow} from \"src/vaults/Escrow.sol\";\nimport {AsyncVaultFactory} from \"src/vaults/factories/AsyncVaultFactory.sol\";\nimport {TokenFactory} from \"src/vaults/factories/TokenFactory.sol\";\nimport {AsyncVault} from \"src/vaults/AsyncVault.sol\";\nimport {ShareToken} from \"src/vaults/token/ShareToken.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\nimport {FullRestrictions} from \"src/hooks/FullRestrictions.sol\";\nimport {IVaultFactory} from \"src/vaults/interfaces/factories/IVaultFactory.sol\";\nimport {VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\n// scripts\nimport {VaultsDeployer} from \"script/VaultsDeployer.s.sol\";\n\n// mocks\nimport {MockCentrifugeChain} from \"test/vaults/mocks/MockCentrifugeChain.sol\";\nimport {MockGasService} from \"test/common/mocks/MockGasService.sol\";\nimport {MockAdapter} from \"test/common/mocks/MockAdapter.sol\";\nimport {MockSafe} from \"test/vaults/mocks/MockSafe.sol\";\n\n// test env\nimport \"forge-std/Test.sol\";\n\ncontract BaseTest is VaultsDeployer, Test {\n    using MessageLib for *;\n\n    MockCentrifugeChain centrifugeChain;\n    MockGasService mockedGasService;\n    MockAdapter adapter1;\n    MockAdapter adapter2;\n    MockAdapter adapter3;\n    IAdapter[] testAdapters;\n    ERC20 public erc20;\n    IERC6909Fungible public erc6909;\n\n    address self = address(this);\n    address investor = makeAddr(\"investor\");\n    address nonMember = makeAddr(\"nonMember\");\n    address randomUser = makeAddr(\"randomUser\");\n\n    uint128 constant MAX_UINT128 = type(uint128).max;\n    uint64 constant MAX_UINT64 = type(uint64).max;\n\n    // default values\n    uint16 public constant OTHER_CHAIN_ID = 1;\n    uint16 public constant THIS_CHAIN_ID = OTHER_CHAIN_ID + 100;\n    uint32 public constant BLOCK_CHAIN_ID = 23;\n    PoolId public immutable POOL_A = newPoolId(OTHER_CHAIN_ID, 1);\n    uint256 public defaultGas;\n    uint256 public defaultSubsidy;\n    uint256 public erc20TokenId = 0;\n    uint256 public defaultErc6909TokenId = 16;\n    uint128 public defaultAssetId = newAssetId(THIS_CHAIN_ID, 1).raw();\n    uint128 public defaultPrice = 1 * 10 ** 18;\n    uint8 public defaultDecimals = 8;\n    bytes16 public defaultShareClassId = bytes16(bytes(\"1\"));\n\n    function setUp() public virtual {\n        // We should not use the block ChainID\n        vm.chainId(BLOCK_CHAIN_ID);\n\n        // make yourself owner of the adminSafe\n        address[] memory pausers = new address[](1);\n        pausers[0] = self;\n        ISafe adminSafe = new MockSafe(pausers, 1);\n\n        // deploy core contracts\n        deployVaults(THIS_CHAIN_ID, adminSafe, address(this), true);\n        guardian.file(\"safe\", address(adminSafe));\n\n        // deploy mock adapters\n        adapter1 = new MockAdapter(OTHER_CHAIN_ID, gateway);\n        adapter2 = new MockAdapter(OTHER_CHAIN_ID, gateway);\n        adapter3 = new MockAdapter(OTHER_CHAIN_ID, gateway);\n\n        adapter1.setReturn(\"estimate\", uint256(1 gwei));\n        adapter2.setReturn(\"estimate\", uint256(1.25 gwei));\n        adapter3.setReturn(\"estimate\", uint256(1.75 gwei));\n\n        testAdapters.push(adapter1);\n        testAdapters.push(adapter2);\n        testAdapters.push(adapter3);\n\n        // wire contracts\n        wire(OTHER_CHAIN_ID, adapter1, address(this));\n        // remove deployer access\n        // removeVaultsDeployerAccess(address(adapter)); // need auth permissions in tests\n\n        centrifugeChain = new MockCentrifugeChain(testAdapters, poolManager, syncRequestManager);\n        mockedGasService = new MockGasService();\n        erc20 = _newErc20(\"X's Dollar\", \"USDX\", 6);\n        erc6909 = new MockERC6909();\n\n        gateway.file(\"adapters\", OTHER_CHAIN_ID, testAdapters);\n        gateway.file(\"gasService\", address(mockedGasService));\n\n        mockedGasService.setReturn(\"estimate\", uint256(0.5 gwei));\n\n        defaultGas = gateway.estimate(OTHER_CHAIN_ID, MessageLib.NotifyPool(1).serialize());\n        defaultSubsidy = defaultGas * 100;\n\n        // Label contracts\n        vm.label(address(root), \"Root\");\n        vm.label(address(asyncRequestManager), \"AsyncRequestManager\");\n        vm.label(address(syncRequestManager), \"SyncRequestManager\");\n        vm.label(address(poolManager), \"PoolManager\");\n        vm.label(address(balanceSheet), \"BalanceSheet\");\n        vm.label(address(gateway), \"Gateway\");\n        vm.label(address(messageProcessor), \"MessageProcessor\");\n        vm.label(address(messageDispatcher), \"MessageDispatcher\");\n        vm.label(address(adapter1), \"MockAdapter1\");\n        vm.label(address(adapter2), \"MockAdapter2\");\n        vm.label(address(adapter3), \"MockAdapter3\");\n        vm.label(address(erc20), \"ERC20\");\n        vm.label(address(erc6909), \"ERC6909\");\n        vm.label(address(centrifugeChain), \"CentrifugeChain\");\n        vm.label(address(vaultRouter), \"VaultRouter\");\n        vm.label(address(gasService), \"GasService\");\n        vm.label(address(mockedGasService), \"MockGasService\");\n        vm.label(address(routerEscrow), \"RouterEscrow\");\n        vm.label(address(guardian), \"Guardian\");\n        vm.label(address(poolManager.tokenFactory()), \"TokenFactory\");\n        vm.label(address(asyncVaultFactory), \"AsyncVaultFactory\");\n        vm.label(address(syncDepositVaultFactory), \"SyncDepositVaultFactory\");\n        vm.label(address(poolEscrowFactory), \"PoolEscrowFactory\");\n\n        // Exclude predeployed contracts from invariant tests by default\n        excludeContract(address(root));\n        excludeContract(address(asyncRequestManager));\n        excludeContract(address(syncRequestManager));\n        excludeContract(address(balanceSheet));\n        excludeContract(address(poolManager));\n        excludeContract(address(gateway));\n        excludeContract(address(erc20));\n        excludeContract(address(erc6909));\n        excludeContract(address(centrifugeChain));\n        excludeContract(address(vaultRouter));\n        excludeContract(address(adapter1));\n        excludeContract(address(adapter2));\n        excludeContract(address(adapter3));\n        excludeContract(address(routerEscrow));\n        excludeContract(address(guardian));\n        excludeContract(address(poolManager.tokenFactory()));\n        excludeContract(address(asyncVaultFactory));\n        excludeContract(address(syncDepositVaultFactory));\n        excludeContract(address(poolEscrowFactory));\n    }\n\n    // helpers\n    function deployVault(\n        VaultKind vaultKind,\n        uint8 shareTokenDecimals,\n        address hook,\n        bytes16 scId,\n        address asset,\n        uint256 assetTokenId,\n        uint16 /* TODO: destinationChain */\n    ) public returns (uint64 poolId, address vaultAddress, uint128 assetId) {\n        try poolManager.shareToken(POOL_A, ShareClassId.wrap(scId)) {}\n        catch {\n            if (poolManager.pools(POOL_A) == 0) {\n                centrifugeChain.addPool(POOL_A.raw());\n            }\n            centrifugeChain.addShareClass(POOL_A.raw(), scId, \"name\", \"symbol\", shareTokenDecimals, hook);\n            centrifugeChain.updatePricePoolPerShare(POOL_A.raw(), scId, uint128(10 ** 18), uint64(block.timestamp));\n        }\n\n        try poolManager.assetToId(asset, assetTokenId) {\n            assetId = poolManager.assetToId(asset, assetTokenId).raw();\n        } catch {\n            assetId = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, asset, assetTokenId).raw();\n            centrifugeChain.updatePricePoolPerAsset(\n                POOL_A.raw(), scId, assetId, uint128(10 ** 18), uint64(block.timestamp)\n            );\n        }\n\n        bytes32 vaultFactory = _vaultKindToVaultFactory(vaultKind);\n\n        // Trigger new vault deployment via UpdateContract\n        poolManager.update(\n            POOL_A,\n            ShareClassId.wrap(scId),\n            MessageLib.UpdateContractVaultUpdate({\n                vaultOrFactory: vaultFactory,\n                assetId: assetId,\n                kind: uint8(VaultUpdateKind.DeployAndLink)\n            }).serialize()\n        );\n        vaultAddress = IShareToken(poolManager.shareToken(POOL_A, ShareClassId.wrap(scId))).vault(asset);\n        poolId = POOL_A.raw();\n\n        gateway.setRefundAddress(POOL_A, gateway);\n        gateway.subsidizePool{value: defaultSubsidy}(POOL_A);\n    }\n\n    function deployVault(VaultKind vaultKind, uint8 decimals, bytes16 scId)\n        public\n        returns (uint64 poolId, address vaultAddress, uint128 assetId)\n    {\n        return\n            deployVault(vaultKind, decimals, fullRestrictionsHook, scId, address(erc20), erc20TokenId, OTHER_CHAIN_ID);\n    }\n\n    function deploySimpleVault(VaultKind vaultKind)\n        public\n        returns (uint64 poolId, address vaultAddress, uint128 assetId)\n    {\n        return deployVault(\n            vaultKind, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(erc20), erc20TokenId, OTHER_CHAIN_ID\n        );\n    }\n\n    function deposit(address _vault, address _investor, uint256 amount) public {\n        deposit(_vault, _investor, amount, true);\n    }\n\n    function deposit(address _vault, address _investor, uint256 amount, bool claimDeposit) public {\n        AsyncVault vault = AsyncVault(_vault);\n        erc20.mint(_investor, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), _investor, type(uint64).max);\n        vm.startPrank(_investor);\n        erc20.approve(_vault, amount); // add allowance\n        vault.requestDeposit(amount, _investor, _investor);\n        // trigger executed collectInvest\n        uint128 assetId = poolManager.assetToId(address(erc20), erc20TokenId).raw();\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(),\n            vault.scId().raw(),\n            bytes32(bytes20(_investor)),\n            assetId,\n            uint128(amount),\n            uint128(amount)\n        );\n\n        if (claimDeposit) {\n            vault.deposit(amount, _investor);\n        }\n        vm.stopPrank();\n    }\n\n    // Helpers\n    function _newErc20(string memory name, string memory symbol, uint8 decimals) internal returns (ERC20) {\n        ERC20 asset = new ERC20(decimals);\n        asset.file(\"name\", name);\n        asset.file(\"symbol\", symbol);\n        return asset;\n    }\n\n    function random(uint256 maxValue, uint256 nonce) internal view returns (uint256) {\n        if (maxValue == 1) {\n            return maxValue;\n        }\n        uint256 randomnumber = uint256(keccak256(abi.encodePacked(block.timestamp, self, nonce))) % (maxValue - 1);\n        return randomnumber + 1;\n    }\n\n    function _vaultKindToVaultFactory(VaultKind vaultKind) internal view returns (bytes32 vaultFactoryBytes) {\n        IVaultFactory vaultFactory;\n\n        if (vaultKind == VaultKind.Async) {\n            vaultFactory = asyncVaultFactory;\n        } else if (vaultKind == VaultKind.SyncDepositAsyncRedeem) {\n            vaultFactory = syncDepositVaultFactory;\n        } else {\n            revert(\"BaseTest/unsupported-vault-kind\");\n        }\n\n        return bytes32(bytes20(address(vaultFactory)));\n    }\n\n    // assumptions\n    function amountAssumption(uint256 amount) public pure returns (bool) {\n        return (amount > 1 && amount < MAX_UINT128);\n    }\n}\n"
    },
    "test/vaults/integration/Admin.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {IRoot} from \"src/common/interfaces/IRoot.sol\";\nimport {IGuardian} from \"src/common/interfaces/IGuardian.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\n\nimport \"test/vaults/BaseTest.sol\";\n\ncontract AdminTest is BaseTest {\n    using MessageLib for *;\n    using CastLib for *;\n\n    function testDeployment() public view {\n        // values set correctly\n        assertEq(root.paused(), false);\n\n        // permissions set correctly\n        assertEq(root.wards(address(guardian)), 1);\n        assertEq(gateway.wards(address(guardian)), 1);\n    }\n\n    //------ pause tests ------//\n    function testUnauthorizedPauseFails() public {\n        MockSafe(address(adminSafe)).removeOwner(address(this));\n        vm.expectRevert(IGuardian.NotTheAuthorizedSafeOrItsOwner.selector);\n        guardian.pause();\n    }\n\n    function testPauseWorks() public {\n        guardian.pause();\n        assertEq(root.paused(), true);\n    }\n\n    function testUnpauseWorks() public {\n        vm.prank(address(adminSafe));\n        guardian.unpause();\n        assertEq(root.paused(), false);\n    }\n\n    function testUnauthorizedUnpauseFails() public {\n        vm.expectRevert(IGuardian.NotTheAuthorizedSafe.selector);\n        guardian.unpause();\n    }\n\n    function testOutgoingShareTokenTransferWhilePausedFails(\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals,\n        address receiver,\n        uint128 amount\n    ) public {\n        // TODO: Set-up correct tests once CC is removed from tests and we test new architecture\n    }\n\n    function testIncomingShareTokenTransferWhilePausedFails(\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals,\n        bytes32, /*sender*/\n        address receiver,\n        uint128 amount\n    ) public {\n        // TODO: Set-up correct tests once CC is removed from tests and we test new architecture\n    }\n\n    function testUnpausingResumesFunctionality(\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals,\n        bytes32, /*sender*/\n        address receiver,\n        uint128 amount\n    ) public {\n        // TODO: Set-up correct tests once CC is removed from tests and we test new architecture\n    }\n\n    //------ Guardian tests ------///\n    function testGuardianPause() public {\n        guardian.pause();\n        assertEq(root.paused(), true);\n    }\n\n    function testGuardianUnpause() public {\n        guardian.pause();\n        vm.prank(address(adminSafe));\n        guardian.unpause();\n        assertEq(root.paused(), false);\n    }\n\n    function testGuardianPauseAuth(address user) public {\n        vm.assume(user != address(this) && user != address(adminSafe));\n        vm.expectRevert(IGuardian.NotTheAuthorizedSafeOrItsOwner.selector);\n        vm.prank(user);\n        guardian.pause();\n    }\n\n    function testTimelockWorks() public {\n        address spell = vm.addr(1);\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(spell);\n        vm.warp(block.timestamp + DELAY + 1 hours);\n        root.executeScheduledRely(spell);\n        assertEq(root.wards(spell), 1);\n    }\n\n    function testTimelockFailsBefore48hours() public {\n        address spell = vm.addr(1);\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(spell);\n        vm.warp(block.timestamp + DELAY - 1 hours);\n        vm.expectRevert(IRoot.TargetNotReady.selector);\n        root.executeScheduledRely(spell);\n    }\n\n    //------ Root tests ------///\n    function testCancellingScheduleBeforeRelyFails() public {\n        address spell = vm.addr(1);\n        vm.expectRevert(IRoot.TargetNotScheduled.selector);\n        root.cancelRely(spell);\n    }\n\n    function testCancellingScheduleWorks() public {\n        address spell = vm.addr(1);\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(spell);\n        assertEq(root.schedule(spell), block.timestamp + DELAY);\n        vm.prank(address(adminSafe));\n        guardian.cancelRely(spell);\n        assertEq(root.schedule(spell), 0);\n        vm.warp(block.timestamp + DELAY + 1 hours);\n        vm.expectRevert(IRoot.TargetNotScheduled.selector);\n        root.executeScheduledRely(spell);\n    }\n\n    function testUnauthorizedCancelFails() public {\n        address spell = vm.addr(1);\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(spell);\n        address badActor = vm.addr(0xBAD);\n        vm.expectRevert(IGuardian.NotTheAuthorizedSafe.selector);\n        vm.prank(badActor);\n        guardian.cancelRely(spell);\n    }\n\n    function testAddedSafeOwnerCanPause() public {\n        address newOwner = vm.addr(0xABCDE);\n        MockSafe(address(adminSafe)).addOwner(newOwner);\n        vm.prank(newOwner);\n        guardian.pause();\n        assertEq(root.paused(), true);\n    }\n\n    function testRemovedOwnerCannotPause() public {\n        MockSafe(address(adminSafe)).removeOwner(address(this));\n        assertEq(MockSafe(address(adminSafe)).isOwner(address(this)), false);\n        vm.expectRevert(IGuardian.NotTheAuthorizedSafeOrItsOwner.selector);\n        vm.prank(address(this));\n        guardian.pause();\n    }\n\n    function testIncomingScheduleUpgradeMessage() public {\n        address spell = vm.addr(1);\n        centrifugeChain.incomingScheduleUpgrade(spell);\n        vm.warp(block.timestamp + DELAY + 1 hours);\n        root.executeScheduledRely(spell);\n        assertEq(root.wards(spell), 1);\n    }\n\n    function testIncomingCancelUpgradeMessage() public {\n        address spell = vm.addr(1);\n        centrifugeChain.incomingScheduleUpgrade(spell);\n        assertEq(root.schedule(spell), block.timestamp + DELAY);\n        centrifugeChain.incomingCancelUpgrade(spell);\n        assertEq(root.schedule(spell), 0);\n        vm.warp(block.timestamp + DELAY + 1 hours);\n        vm.expectRevert(IRoot.TargetNotScheduled.selector);\n        root.executeScheduledRely(spell);\n    }\n\n    //------ Updating DELAY tests ------///\n    function testUpdatingDelayWorks() public {\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(address(this));\n        vm.warp(block.timestamp + DELAY + 1 hours);\n        root.executeScheduledRely(address(this));\n    }\n\n    function testUpdatingDelayWithLargeValueFails() public {\n        vm.expectRevert(IRoot.DelayTooLong.selector);\n        root.file(\"delay\", 5 weeks);\n    }\n\n    function testUpdatingDelayAndExecutingBeforeNewDelayFails() public {\n        root.file(\"delay\", 2 hours);\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(address(this));\n        vm.warp(block.timestamp + 1 hours);\n        vm.expectRevert(IRoot.TargetNotReady.selector);\n        root.executeScheduledRely(address(this));\n    }\n\n    function testInvalidFile() public {\n        vm.expectRevert(IRoot.FileUnrecognizedParam.selector);\n        root.file(\"not-delay\", 1);\n    }\n\n    //------ rely/denyContract tests ------///\n    function testRelyDenyContract() public {\n        vm.prank(address(adminSafe));\n        guardian.scheduleRely(address(this));\n        vm.warp(block.timestamp + DELAY + 1 hours);\n        root.executeScheduledRely(address(this));\n\n        assertEq(asyncRequestManager.wards(address(this)), 1);\n        root.denyContract(address(asyncRequestManager), address(this));\n        assertEq(asyncRequestManager.wards(address(this)), 0);\n\n        root.relyContract(address(asyncRequestManager), address(this));\n        assertEq(asyncRequestManager.wards(address(this)), 1);\n    }\n\n    //Endorsements\n    function testEndorseVeto() public {\n        address endorser = makeAddr(\"endorser\");\n\n        // endorse\n        address router = makeAddr(\"router\");\n\n        root.rely(endorser);\n        vm.prank(endorser);\n        root.endorse(router);\n        assertEq(root.endorsements(router), 1);\n        assertEq(root.endorsed(router), true);\n\n        // veto\n        root.deny(endorser);\n        vm.expectRevert(IAuth.NotAuthorized.selector); // fail no auth permissions\n        vm.prank(endorser);\n        root.veto(router);\n\n        root.rely(endorser);\n        vm.prank(endorser);\n        root.veto(router);\n        assertEq(root.endorsements(router), 0);\n        assertEq(root.endorsed(router), false);\n    }\n\n    function testDisputeRecovery() public {\n        gateway.file(\"adapters\", OTHER_CHAIN_ID, testAdapters);\n\n        bytes memory message = MessageLib.NotifyPool(1).serialize();\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(message));\n\n        // Only send through 2 out of 3 adapters\n        _send(adapter1, message);\n        _send(adapter2, proof);\n\n        // Initiate recovery\n        _send(\n            adapter1,\n            MessageLib.InitiateRecovery(keccak256(proof), address(adapter3).toBytes32(), OTHER_CHAIN_ID).serialize()\n        );\n\n        vm.expectRevert(IGateway.RecoveryChallengePeriodNotEnded.selector);\n        gateway.executeRecovery(OTHER_CHAIN_ID, adapter3, proof);\n\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IGuardian.NotTheAuthorizedSafe.selector);\n        guardian.disputeRecovery(THIS_CHAIN_ID, OTHER_CHAIN_ID, adapter3, keccak256(proof));\n\n        // Dispute recovery\n        vm.prank(address(adminSafe));\n        guardian.disputeRecovery(THIS_CHAIN_ID, OTHER_CHAIN_ID, adapter3, keccak256(proof));\n\n        // Check that recovery is not possible anymore\n        vm.expectRevert(IGateway.RecoveryNotInitiated.selector);\n        gateway.executeRecovery(OTHER_CHAIN_ID, adapter3, proof);\n    }\n\n    function _send(MockAdapter adapter, bytes memory message) internal {\n        vm.prank(address(adapter));\n        gateway.handle(OTHER_CHAIN_ID, message);\n    }\n}\n"
    },
    "test/vaults/integration/AssetShareConversion.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\n\ncontract AssetShareConversionTest is BaseTest {\n    function testAssetShareConversion(bytes16 scId) public {\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n        uint8 SHARE_TOKEN_DECIMALS = 18; // Like DAI\n\n        ERC20 asset = _newErc20(\"Asset\", \"A\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n\n        assertEq(vault.priceLastUpdated(), block.timestamp);\n        assertEq(vault.pricePerShare(), 1e6);\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1e18, uint64(block.timestamp));\n        centrifugeChain.updatePricePoolPerAsset(poolId, scId, assetId, 1e18, uint64(block.timestamp));\n        assertEq(vault.priceLastUpdated(), uint64(block.timestamp));\n        assertEq(vault.pricePerShare(), 1e6);\n\n        // invest\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(poolId, scId, self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        assertEq(asset.balanceOf(address(globalEscrow)), investmentAmount);\n\n        // trigger executed collectInvest at a price of 1.0\n        uint128 shares = 100000000000000000000; // 100 * 10**18\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId, uint128(investmentAmount), shares\n        );\n        vault.mint(shares, self);\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1e18, uint64(block.timestamp));\n        // assert share/asset conversion\n        assertEq(shareToken.totalSupply(), 100000000000000000000);\n        assertEq(vault.totalAssets(), 100000000);\n        assertEq(vault.convertToShares(100000000), 100000000000000000000); // share class tokens have 12 more decimals\n            // than\n            // assets\n        assertEq(vault.convertToAssets(vault.convertToShares(100000000000000000000)), 100000000000000000000);\n        assertEq(vault.pricePerShare(), 1e6);\n\n        // assert share/asset conversion after price update\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1200000000000000000, uint64(block.timestamp));\n\n        assertEq(vault.totalAssets(), 120000000);\n        assertEq(vault.convertToShares(120000000), 100000000000000000000); // share class tokens have 12 more decimals\n            // than\n            // assets\n        assertEq(vault.convertToAssets(vault.convertToShares(120000000000000000000)), 120000000000000000000);\n        assertEq(vault.pricePerShare(), 1.2e6);\n\n        // Updating the asset price updates the conversions and price per share in asset\n        centrifugeChain.updatePricePoolPerAsset(poolId, scId, assetId, 0.5e18, uint64(block.timestamp));\n\n        // NOTE: For 1 unit of pool, you know get 2 units of assets. As the price of a share is 1.2 POOL/SHARE\n        //       we now have 2 * 1.2 = 2.4 units of assets per share\n        assertEq(vault.totalAssets(), 240000000);\n        assertEq(vault.convertToShares(240000000), 100000000000000000000); // share class tokens have 12 more decimals\n            // than\n        // assets\n        assertEq(vault.convertToAssets(vault.convertToShares(240000000000000000000)), 240000000000000000000);\n        assertEq(vault.pricePerShare(), 2.4e6);\n    }\n\n    function testAssetShareConversionWithInverseDecimals(bytes16 scId) public {\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 18; // 18, like DAI\n        uint8 SHARE_TOKEN_DECIMALS = 6; // Like USDC\n\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1000000, uint64(block.timestamp));\n\n        // invest\n        uint256 investmentAmount = 100000000000000000000; // 100 * 10**18\n        centrifugeChain.updateMember(poolId, scId, self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // trigger executed collectInvest at a price of 1.0\n        uint128 shares = 100000000; // 100 * 10**6\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId, uint128(investmentAmount), shares\n        );\n        vault.mint(shares, self);\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1000000000000000000, uint64(block.timestamp));\n\n        // assert share/asset conversion\n        assertEq(shareToken.totalSupply(), 100000000);\n        assertEq(vault.totalAssets(), 100000000000000000000);\n        // share class tokens have 12 less decimals than asset\n        assertEq(vault.convertToShares(100000000000000000000), 100000000);\n        assertEq(vault.convertToAssets(vault.convertToShares(100000000000000000000)), 100000000000000000000);\n        assertEq(vault.pricePerShare(), 1e18);\n\n        // assert share/asset conversion after price update\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1200000000000000000, uint64(block.timestamp));\n\n        assertEq(vault.totalAssets(), 120000000000000000000);\n        // share class tokens have 12 less decimals than assets\n        assertEq(vault.convertToShares(120000000000000000000), 100000000);\n        assertEq(vault.convertToAssets(vault.convertToShares(120000000000000000000)), 120000000000000000000);\n        assertEq(vault.pricePerShare(), 1.2e18);\n    }\n\n    function testPriceWorksAfterRemovingVault(bytes16 scId) public {\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n        uint8 SHARE_TOKEN_DECIMALS = 18; // Like DAI\n\n        ERC20 asset = _newErc20(\"Asset\", \"A\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken(address(vault.share()));\n\n        assertEq(vault.priceLastUpdated(), block.timestamp);\n        assertEq(vault.pricePerShare(), 1e6);\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1.2e18, uint64(block.timestamp));\n        assertEq(vault.priceLastUpdated(), uint64(block.timestamp));\n        assertEq(vault.pricePerShare(), 1.2e6);\n\n        poolManager.unlinkVault(PoolId.wrap(poolId), ShareClassId.wrap(scId), AssetId.wrap(assetId), vault);\n\n        assertEq(vault.priceLastUpdated(), uint64(block.timestamp));\n        assertEq(vault.pricePerShare(), 1.2e6);\n    }\n}\n"
    },
    "test/vaults/integration/AsyncRequestManager.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\npragma abicoder v2;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\n\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nimport {IEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\nimport {VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\nimport \"test/vaults/BaseTest.sol\";\n\ninterface VaultLike {\n    function priceComputedAt() external view returns (uint64);\n}\n\ncontract AsyncRequestManagerHarness is AsyncRequestManager {\n    constructor(IEscrow globalEscrow, address root, address deployer)\n        AsyncRequestManager(globalEscrow, root, deployer)\n    {}\n\n    function calculatePriceAssetPerShare(IBaseVault vault, uint128 assets, uint128 shares)\n        external\n        view\n        returns (uint256 price)\n    {\n        if (address(vault) == address(0)) {\n            return\n                PricingLib.calculatePriceAssetPerShare(address(0), shares, address(0), 0, assets, MathLib.Rounding.Down);\n        }\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        address shareToken = vault.share();\n        return PricingLib.calculatePriceAssetPerShare(\n            shareToken, shares, vaultDetails.asset, vaultDetails.tokenId, assets, MathLib.Rounding.Down\n        );\n    }\n}\n\ncontract AsyncRequestManagerTest is BaseTest {\n    // Deployment\n    function testDeployment(address nonWard) public {\n        vm.assume(\n            nonWard != address(root) && nonWard != address(gateway) && nonWard != address(poolManager)\n                && nonWard != address(messageDispatcher) && nonWard != address(messageProcessor)\n                && nonWard != address(syncRequestManager) && nonWard != address(this)\n        );\n\n        // redeploying within test to increase coverage\n        new AsyncRequestManager(globalEscrow, address(root), address(this));\n\n        // values set correctly\n        assertEq(address(asyncRequestManager.sender()), address(messageDispatcher));\n        assertEq(address(asyncRequestManager.poolManager()), address(poolManager));\n        assertEq(address(asyncRequestManager.balanceSheet()), address(balanceSheet));\n        assertEq(address(asyncRequestManager.poolEscrowProvider()), address(poolEscrowFactory));\n\n        // permissions set correctly\n        assertEq(asyncRequestManager.wards(address(root)), 1);\n        assertEq(asyncRequestManager.wards(address(gateway)), 1);\n        assertEq(asyncRequestManager.wards(address(poolManager)), 1);\n        assertEq(asyncRequestManager.wards(address(messageProcessor)), 1);\n        assertEq(asyncRequestManager.wards(address(messageDispatcher)), 1);\n        assertEq(asyncRequestManager.wards(nonWard), 0);\n\n        assertEq(balanceSheet.wards(address(asyncRequestManager)), 1);\n        assertEq(messageDispatcher.wards(address(asyncRequestManager)), 1);\n    }\n\n    // --- Administration ---\n    function testFile() public {\n        // fail: unrecognized param\n        vm.expectRevert(IBaseRequestManager.FileUnrecognizedParam.selector);\n        asyncRequestManager.file(\"random\", self);\n\n        assertEq(address(asyncRequestManager.poolManager()), address(poolManager));\n        // success\n        asyncRequestManager.file(\"sender\", randomUser);\n        assertEq(address(asyncRequestManager.sender()), randomUser);\n        asyncRequestManager.file(\"poolManager\", randomUser);\n        assertEq(address(asyncRequestManager.poolManager()), randomUser);\n        asyncRequestManager.file(\"balanceSheet\", randomUser);\n        assertEq(address(asyncRequestManager.balanceSheet()), randomUser);\n        asyncRequestManager.file(\"poolEscrowProvider\", randomUser);\n        assertEq(address(asyncRequestManager.poolEscrowProvider()), randomUser);\n\n        // remove self from wards\n        asyncRequestManager.deny(self);\n        // auth fail\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        asyncRequestManager.file(\"poolManager\", randomUser);\n    }\n\n    // --- Simple Errors ---\n    function testRequestDepositUnlinkedVault() public {\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        IAsyncVault vault = IAsyncVault(vault_);\n\n        poolManager.unlinkVault(vault.poolId(), vault.scId(), AssetId.wrap(assetId), vault);\n\n        vm.expectRevert(IBaseRequestManager.AssetNotAllowed.selector);\n        asyncRequestManager.requestDeposit(vault, 1, address(0), address(0), address(0));\n    }\n\n    // --- Price calculations ---\n    function testPrice() public {\n        AsyncRequestManagerHarness harness = new AsyncRequestManagerHarness(globalEscrow, address(root), address(this));\n        assertEq(harness.calculatePriceAssetPerShare(IBaseVault(address(0)), 1, 0), 0);\n        assertEq(harness.calculatePriceAssetPerShare(IBaseVault(address(0)), 0, 1), 0);\n    }\n}\n"
    },
    "test/vaults/integration/BalanceSheet.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\nimport {AccountId} from \"src/common/types/AccountId.sol\";\n\nimport {IBalanceSheet} from \"src/vaults/interfaces/IBalanceSheet.sol\";\nimport {BalanceSheet} from \"src/vaults/BalanceSheet.sol\";\nimport {IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\n\ncontract BalanceSheetTest is BaseTest {\n    using MessageLib for *;\n    using CastLib for *;\n\n    uint128 defaultAmount;\n    D18 defaultPricePoolPerShare;\n    D18 defaultPricePoolPerAsset;\n    AssetId assetId;\n    ShareClassId defaultTypedShareClassId;\n\n    function setUp() public override {\n        super.setUp();\n        defaultAmount = 100;\n        defaultPricePoolPerShare = d18(1, 1);\n        defaultPricePoolPerAsset = d18(1, 1);\n        defaultTypedShareClassId = ShareClassId.wrap(defaultShareClassId);\n\n        assetId = poolManager.registerAsset{value: 0.1 ether}(OTHER_CHAIN_ID, address(erc20), erc20TokenId);\n        poolManager.addPool(POOL_A);\n        poolManager.addShareClass(\n            POOL_A,\n            defaultTypedShareClassId,\n            \"testShareClass\",\n            \"tsc\",\n            defaultDecimals,\n            bytes32(\"\"),\n            fullRestrictionsHook\n        );\n        poolManager.updatePricePoolPerShare(\n            POOL_A, defaultTypedShareClassId, defaultPricePoolPerShare.raw(), uint64(block.timestamp)\n        );\n        poolManager.updatePricePoolPerAsset(\n            POOL_A, defaultTypedShareClassId, assetId, defaultPricePoolPerShare.raw(), uint64(block.timestamp)\n        );\n        poolManager.updateRestriction(\n            POOL_A,\n            defaultTypedShareClassId,\n            MessageLib.UpdateRestrictionMember({user: address(this).toBytes32(), validUntil: MAX_UINT64}).serialize()\n        );\n    }\n\n    // Deployment\n    function testDeployment(address nonWard) public {\n        vm.assume(\n            nonWard != address(root) && nonWard != address(asyncRequestManager)\n                && nonWard != address(syncRequestManager) && nonWard != address(messageProcessor)\n                && nonWard != address(messageDispatcher) && nonWard != address(this)\n        );\n\n        // redeploying within test to increase coverage\n        new BalanceSheet(root, address(this));\n\n        // values set correctly\n        assertEq(address(balanceSheet.root()), address(root));\n        assertEq(address(balanceSheet.poolManager()), address(poolManager));\n        assertEq(address(balanceSheet.sender()), address(messageDispatcher));\n        assertEq(address(balanceSheet.poolEscrowProvider()), address(poolEscrowFactory));\n\n        // permissions set correctly\n        assertEq(balanceSheet.wards(address(root)), 1);\n        assertEq(balanceSheet.wards(address(asyncRequestManager)), 1);\n        assertEq(balanceSheet.wards(address(syncRequestManager)), 1);\n        assertEq(balanceSheet.wards(address(messageProcessor)), 1);\n        assertEq(balanceSheet.wards(address(messageDispatcher)), 1);\n        assertEq(balanceSheet.wards(nonWard), 0);\n    }\n\n    // --- Administration ---\n    function testFile() public {\n        // fail: unrecognized param\n        vm.expectRevert(IBalanceSheet.FileUnrecognizedParam.selector);\n        balanceSheet.file(\"random\", self);\n\n        // success\n        balanceSheet.file(\"poolManager\", randomUser);\n        assertEq(address(balanceSheet.poolManager()), randomUser);\n        balanceSheet.file(\"sender\", randomUser);\n        assertEq(address(balanceSheet.sender()), randomUser);\n        balanceSheet.file(\"poolEscrowProvider\", randomUser);\n        assertEq(address(balanceSheet.poolEscrowProvider()), randomUser);\n\n        // remove self from wards\n        balanceSheet.deny(self);\n        // auth fail\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.file(\"poolManager\", randomUser);\n    }\n\n    // --- IUpdateContract ---\n    function testUpdate() public {\n        erc20.mint(address(this), defaultAmount);\n        erc20.approve(address(balanceSheet), defaultAmount);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        vm.expectEmit();\n        emit IBalanceSheet.UpdateManager(POOL_A, randomUser, true);\n\n        balanceSheet.update(\n            POOL_A,\n            defaultTypedShareClassId,\n            MessageLib.UpdateContractUpdateManager({who: bytes20(randomUser), canManage: true}).serialize()\n        );\n\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        vm.expectEmit();\n        emit IBalanceSheet.UpdateManager(POOL_A, randomUser, false);\n\n        balanceSheet.update(\n            POOL_A,\n            defaultTypedShareClassId,\n            MessageLib.UpdateContractUpdateManager({who: bytes20(randomUser), canManage: false}).serialize()\n        );\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n    }\n\n    // --- IBalanceSheet ---\n    function testDeposit() public {\n        balanceSheet.setQueue(POOL_A, defaultTypedShareClassId, true);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        erc20.mint(address(this), defaultAmount);\n        erc20.approve(address(balanceSheet), defaultAmount);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Deposit(\n            POOL_A,\n            defaultTypedShareClassId,\n            address(erc20),\n            erc20TokenId,\n            address(this),\n            defaultAmount,\n            defaultPricePoolPerAsset\n        );\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        assertEq(erc20.balanceOf(address(this)), 0);\n        (uint128 increase,) = balanceSheet.queuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n        assertEq(increase, defaultAmount);\n        assertEq(erc20.balanceOf(address(balanceSheet.poolEscrowProvider().escrow(POOL_A))), defaultAmount);\n    }\n\n    function testNoteDeposit() public {\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        vm.expectEmit();\n        emit IBalanceSheet.Deposit(\n            POOL_A,\n            defaultTypedShareClassId,\n            address(erc20),\n            erc20TokenId,\n            address(this),\n            defaultAmount,\n            defaultPricePoolPerAsset\n        );\n        balanceSheet.noteDeposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        // Ensure no balance transfer occurred but escrow holding was incremented nevertheless\n        assertEq(erc20.balanceOf(address(this)), 0);\n        assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(POOL_A))), 0);\n        assertEq(\n            poolEscrowFactory.escrow(POOL_A).availableBalanceOf(defaultTypedShareClassId, address(erc20), erc20TokenId),\n            defaultAmount\n        );\n    }\n\n    function testWithdraw() public {\n        testDeposit();\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.withdraw(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        assertEq(erc20.balanceOf(address(this)), 0);\n\n        balanceSheet.overridePricePoolPerShare(POOL_A, defaultTypedShareClassId, defaultPricePoolPerShare);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Withdraw(\n            POOL_A,\n            defaultTypedShareClassId,\n            address(erc20),\n            erc20TokenId,\n            address(this),\n            defaultAmount,\n            defaultPricePoolPerAsset\n        );\n        balanceSheet.withdraw(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        (, uint128 decrease) = balanceSheet.queuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n\n        assertEq(erc20.balanceOf(address(this)), defaultAmount);\n        assertEq(decrease, defaultAmount);\n        assertEq(erc20.balanceOf(address(balanceSheet.poolEscrowProvider().escrow(POOL_A))), 0);\n    }\n\n    function testIssue() public {\n        balanceSheet.setQueue(POOL_A, defaultTypedShareClassId, true);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.issue(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n\n        IERC20 token = IERC20(poolManager.shareToken(POOL_A, defaultTypedShareClassId));\n        assertEq(token.balanceOf(address(this)), 0);\n\n        balanceSheet.overridePricePoolPerShare(POOL_A, defaultTypedShareClassId, defaultPricePoolPerShare);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Issue(\n            POOL_A, defaultTypedShareClassId, address(this), defaultPricePoolPerShare, defaultAmount\n        );\n        balanceSheet.issue(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n\n        (uint128 increase,) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(token.balanceOf(address(this)), defaultAmount);\n        assertEq(increase, defaultAmount);\n\n        balanceSheet.issue(POOL_A, defaultTypedShareClassId, address(this), defaultAmount * 2);\n\n        (uint128 increase2,) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(token.balanceOf(address(this)), defaultAmount * 3);\n        assertEq(increase2, defaultAmount * 3);\n    }\n\n    function testRevoke() public {\n        testIssue();\n        IERC20 token = IERC20(poolManager.shareToken(POOL_A, defaultTypedShareClassId));\n        assertEq(token.balanceOf(address(this)), defaultAmount * 3);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.revoke(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n\n        balanceSheet.overridePricePoolPerShare(POOL_A, defaultTypedShareClassId, defaultPricePoolPerShare);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Revoke(\n            POOL_A, defaultTypedShareClassId, address(this), defaultPricePoolPerShare, defaultAmount\n        );\n        balanceSheet.revoke(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n\n        (, uint128 decrease) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(token.balanceOf(address(this)), defaultAmount * 2);\n        assertEq(decrease, defaultAmount);\n\n        balanceSheet.revoke(POOL_A, defaultTypedShareClassId, address(this), defaultAmount * 2);\n\n        (, uint128 decrease2) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(token.balanceOf(address(this)), 0);\n        assertEq(decrease2, defaultAmount * 3);\n    }\n\n    function testQueuedShares() public {\n        testRevoke();\n\n        DispatcherSpy dispatcherSpy = new DispatcherSpy();\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateShares.selector)\n        );\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateShares_result.selector)\n        );\n\n        // Add extra issuance to have an unequal number\n        balanceSheet.issue(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n        (uint128 increase, uint128 decrease) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n\n        assertEq(increase, defaultAmount * 4);\n        assertEq(decrease, defaultAmount * 3);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.submitQueuedShares(POOL_A, defaultTypedShareClassId);\n\n        balanceSheet.submitQueuedShares(POOL_A, defaultTypedShareClassId);\n\n        (uint128 increaseAfter, uint128 decreaseAfter) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(increaseAfter, 0);\n        assertEq(decreaseAfter, 0);\n        (uint128 shares, bool isIssuance) = DispatcherSpy(address(balanceSheet.sender())).sendUpdateShares_result();\n        assertEq(shares, defaultAmount);\n        assertEq(isIssuance, true);\n    }\n\n    function testQueuedAssets() public {\n        testDeposit();\n\n        DispatcherSpy dispatcherSpy = new DispatcherSpy();\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateHoldingAmount.selector)\n        );\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateHoldingAmount_result.selector)\n        );\n\n        (uint128 increase,) = balanceSheet.queuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n        assertEq(increase, defaultAmount);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.submitQueuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n\n        balanceSheet.submitQueuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n\n        (uint128 increaseAfter,) = balanceSheet.queuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n        assertEq(increaseAfter, 0);\n        (uint128 amount, bool isIncrease) =\n            DispatcherSpy(address(balanceSheet.sender())).sendUpdateHoldingAmount_result();\n        assertEq(amount, defaultAmount);\n        assertEq(isIncrease, true);\n    }\n\n    function testAssetsQueueDisabled() public {\n        DispatcherSpy dispatcherSpy = new DispatcherSpy();\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateHoldingAmount.selector)\n        );\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateHoldingAmount_result.selector)\n        );\n\n        erc20.mint(address(this), defaultAmount);\n        erc20.approve(address(balanceSheet), defaultAmount);\n\n        balanceSheet.deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        (uint128 increase,) = balanceSheet.queuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n        assertEq(increase, 0);\n        (uint128 amount, bool isIncrease) =\n            DispatcherSpy(address(balanceSheet.sender())).sendUpdateHoldingAmount_result();\n        assertEq(amount, defaultAmount);\n        assertEq(isIncrease, true);\n\n        balanceSheet.withdraw(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount / 2\n        );\n\n        (, uint128 decrease) = balanceSheet.queuedAssets(POOL_A, defaultTypedShareClassId, assetId);\n        assertEq(decrease, 0);\n        (uint128 amount2, bool isIncrease2) =\n            DispatcherSpy(address(balanceSheet.sender())).sendUpdateHoldingAmount_result();\n        assertEq(amount2, defaultAmount / 2);\n        assertEq(isIncrease2, false);\n    }\n\n    function testSharesQueueDisabled() public {\n        DispatcherSpy dispatcherSpy = new DispatcherSpy();\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateShares.selector)\n        );\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateShares_result.selector)\n        );\n\n        balanceSheet.issue(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n\n        (uint128 increase,) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(increase, 0);\n        (uint128 shares, bool isIssuance) = DispatcherSpy(address(balanceSheet.sender())).sendUpdateShares_result();\n        assertEq(shares, defaultAmount);\n        assertEq(isIssuance, true);\n    }\n\n    function testSubmitWithQueueDisabled() public {\n        DispatcherSpy dispatcherSpy = new DispatcherSpy();\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateShares.selector)\n        );\n        vm.mockFunction(\n            address(balanceSheet.sender()),\n            address(dispatcherSpy),\n            abi.encodeWithSelector(DispatcherSpy.sendUpdateShares_result.selector)\n        );\n\n        // Issue with queue enabled\n        balanceSheet.setQueue(POOL_A, defaultTypedShareClassId, true);\n        balanceSheet.issue(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n\n        (uint128 increase,) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(increase, defaultAmount);\n\n        // Submit with queue disabled\n        balanceSheet.setQueue(POOL_A, defaultTypedShareClassId, false);\n        balanceSheet.submitQueuedShares(POOL_A, defaultTypedShareClassId);\n\n        // Shares should be submitted even if disabled\n        (increase,) = balanceSheet.queuedShares(POOL_A, defaultTypedShareClassId);\n        assertEq(increase, 0);\n\n        (uint128 shares, bool isIssuance) = DispatcherSpy(address(balanceSheet.sender())).sendUpdateShares_result();\n        assertEq(shares, defaultAmount);\n        assertEq(isIssuance, true);\n    }\n\n    function testTransferSharesFrom() public {\n        testIssue();\n\n        IERC20 token = IERC20(poolManager.shareToken(POOL_A, defaultTypedShareClassId));\n\n        assertEq(token.balanceOf(address(this)), defaultAmount * 3);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.transferSharesFrom(POOL_A, defaultTypedShareClassId, address(this), address(1), defaultAmount);\n\n        vm.expectRevert(IBalanceSheet.CannotTransferFromEndorsedContract.selector);\n        balanceSheet.transferSharesFrom(\n            POOL_A, defaultTypedShareClassId, address(globalEscrow), address(1), defaultAmount\n        );\n\n        balanceSheet.transferSharesFrom(POOL_A, defaultTypedShareClassId, address(this), address(1), defaultAmount);\n\n        assertEq(token.balanceOf(address(this)), defaultAmount * 2);\n        assertEq(token.balanceOf(address(1)), defaultAmount);\n    }\n\n    function testPriceOverride() public {\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.overridePricePoolPerShare(POOL_A, defaultTypedShareClassId, defaultPricePoolPerShare);\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        balanceSheet.overridePricePoolPerAsset(POOL_A, defaultTypedShareClassId, assetId, defaultPricePoolPerAsset);\n\n        D18 pricePerAsset = d18(3, 1);\n        D18 pricePerShare = d18(2, 1);\n\n        balanceSheet.overridePricePoolPerAsset(POOL_A, defaultTypedShareClassId, assetId, pricePerAsset);\n        balanceSheet.overridePricePoolPerShare(POOL_A, defaultTypedShareClassId, pricePerShare);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Deposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount, pricePerAsset\n        );\n        balanceSheet.noteDeposit(\n            POOL_A, defaultTypedShareClassId, address(erc20), erc20TokenId, address(this), defaultAmount\n        );\n\n        vm.expectEmit();\n        emit IBalanceSheet.Revoke(POOL_A, defaultTypedShareClassId, address(this), pricePerShare, defaultAmount);\n        balanceSheet.noteRevoke(POOL_A, defaultTypedShareClassId, address(this), defaultAmount);\n    }\n}\n\ncontract DispatcherSpy {\n    function sendUpdateShares(PoolId, ShareClassId, uint128 shares, bool isIssuance) external {\n        bytes32 slot = keccak256(\"dispatchedShares\");\n        bytes32 slot2 = keccak256(\"dispatchedSharesIsIssuance\");\n        assembly {\n            sstore(slot, shares)\n            sstore(slot2, isIssuance)\n        }\n    }\n\n    function sendUpdateShares_result() external view returns (uint128 shares, bool isIssuance) {\n        bytes32 slot = keccak256(\"dispatchedShares\");\n        bytes32 slot2 = keccak256(\"dispatchedSharesIsIssuance\");\n        assembly {\n            shares := sload(slot)\n            isIssuance := sload(slot2)\n        }\n    }\n\n    function sendUpdateHoldingAmount(PoolId, ShareClassId, AssetId, address, uint128 amount, D18, bool isIncrease)\n        external\n    {\n        bytes32 slot = keccak256(\"dispatchedHoldingAmount\");\n        bytes32 slot2 = keccak256(\"dispatchedHoldingAmountIsIncrease\");\n        assembly {\n            sstore(slot, amount)\n            sstore(slot2, isIncrease)\n        }\n    }\n\n    function sendUpdateHoldingAmount_result() external view returns (uint128 amount, bool inIncrease) {\n        bytes32 slot = keccak256(\"dispatchedHoldingAmount\");\n        bytes32 slot2 = keccak256(\"dispatchedHoldingAmountIsIncrease\");\n        assembly {\n            amount := sload(slot)\n            inIncrease := sload(slot2)\n        }\n    }\n}\n"
    },
    "test/vaults/integration/Burn.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\n\ncontract BurnTest is BaseTest {\n    function testBurn(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128));\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        root.relyContract(address(shareToken), self); // give self auth permissions\n        // add investor as member\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n\n        shareToken.mint(investor, amount);\n        root.denyContract(address(shareToken), self); // remove auth permissions from self\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        shareToken.burn(investor, amount);\n\n        root.relyContract(address(shareToken), self); // give self auth permissions\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        shareToken.burn(investor, amount);\n\n        // success\n        vm.prank(investor);\n        shareToken.approve(self, amount); // approve to burn shareTokens\n        shareToken.burn(investor, amount);\n\n        assertEq(shareToken.balanceOf(investor), 0);\n        assertEq(shareToken.balanceOf(investor), shareToken.balanceOf(investor));\n    }\n}\n"
    },
    "test/vaults/integration/Deposit.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {d18} from \"src/misc/types/D18.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport \"test/vaults/BaseTest.sol\";\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IBaseVault, IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ncontract DepositTest is BaseTest {\n    using MessageLib for *;\n    using CastLib for *;\n    using MathLib for uint256;\n\n    /// forge-config: default.isolate = true\n    function testDepositMint() public {\n        _testDepositMint(4, true);\n    }\n\n    /// forge-config: default.isolate = true\n    function testDepositMintFuzz(uint256 amount) public {\n        vm.assume(amount % 2 == 0);\n        _testDepositMint(amount, false);\n    }\n\n    function _testDepositMint(uint256 amount, bool snap) internal {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n\n        uint128 price = 2 * 10 ** 18;\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), price, uint64(block.timestamp)\n        );\n\n        erc20.mint(self, amount);\n\n        // will fail - user not member: can not send funds\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vault.requestDeposit(amount, self, self);\n\n        assertEq(vault.isPermissioned(self), false);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max); // add user as\n            // member\n        assertEq(vault.isPermissioned(self), true);\n\n        // will fail - user not member: can not receive share class\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vault.requestDeposit(amount, nonMember, self);\n\n        // will fail - user did not give asset allowance to vault\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        vault.requestDeposit(amount, self, self);\n\n        // will fail - zero deposit not allowed\n        vm.expectRevert(IAsyncRequestManager.ZeroAmountNotAllowed.selector);\n        vault.requestDeposit(0, self, self);\n\n        // will fail - owner != msg.sender not allowed\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vault.requestDeposit(amount, self, nonMember);\n\n        // will fail - cannot fulfill if there is no pending request\n        uint128 shares = uint128((amount * 10 ** 18) / price); // sharePrice = 2$\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        vm.expectRevert(IAsyncRequestManager.NoPendingRequest.selector);\n        asyncRequestManager.fulfillDepositRequest(poolId, scId, self, AssetId.wrap(assetId), uint128(amount), shares);\n\n        // success\n        erc20.approve(vault_, amount);\n        if (snap) {\n            vm.startSnapshotGas(\"AsyncVault\", \"requestDeposit\");\n        }\n        vault.requestDeposit(amount, self, self);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n\n        // fail: no asset left\n        vm.expectRevert(IBaseVault.InsufficientBalance.selector);\n        vault.requestDeposit(amount, self, self);\n\n        // ensure funds are locked in escrow\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n        assertEq(erc20.balanceOf(self), 0);\n        assertEq(vault.pendingDepositRequest(0, self), amount);\n        assertEq(vault.claimableDepositRequest(0, self), 0);\n\n        // trigger executed collectInvest\n        assertApproxEqAbs(shares, amount / 2, 2);\n        if (snap) {\n            vm.startSnapshotGas(\"AsyncVault\", \"fulfillDepositRequest\");\n        }\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, uint128(amount), shares\n        );\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n\n        // assert deposit & mint values adjusted\n        assertEq(vault.maxMint(self), shares);\n        assertApproxEqAbs(vault.maxDeposit(self), amount, 1);\n        assertEq(vault.pendingDepositRequest(0, self), 0);\n        assertEq(vault.claimableDepositRequest(0, self), amount);\n        // assert share class tokens minted\n        assertEq(shareToken.balanceOf(address(globalEscrow)), shares);\n\n        // check maxDeposit and maxMint are 0 for non-members\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, uint64(block.timestamp));\n        vm.warp(block.timestamp + 1);\n        assertEq(vault.maxDeposit(self), 0);\n        assertEq(vault.maxMint(self), 0);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n\n        vm.assume(randomUser != self);\n        // deposit 50% of the amount\n        vm.startPrank(randomUser); // try to claim deposit on behalf of user and set the wrong user as receiver\n        vm.expectRevert(IBaseVault.InvalidController.selector);\n        vault.deposit(amount / 2, randomUser, self);\n        vm.stopPrank();\n\n        vault.deposit(amount / 2, self, self); // deposit half the amount\n        // Allow 2 difference because of rounding\n        assertApproxEqAbs(shareToken.balanceOf(self), shares / 2, 2);\n        assertApproxEqAbs(shareToken.balanceOf(address(globalEscrow)), shares - shares / 2, 2);\n        assertApproxEqAbs(vault.maxMint(self), shares - shares / 2, 2);\n        assertApproxEqAbs(vault.maxDeposit(self), amount - amount / 2, 2);\n\n        // mint the rest\n        vault.mint(vault.maxMint(self), self);\n        assertApproxEqAbs(shareToken.balanceOf(self), shares - vault.maxMint(self), 2);\n        assertTrue(shareToken.balanceOf(address(globalEscrow)) <= 1);\n        assertTrue(vault.maxMint(self) <= 1);\n\n        // minting or depositing more should revert\n        vm.expectRevert(IAsyncRequestManager.ExceedsDepositLimits.selector);\n        vault.mint(1, self);\n        vm.expectRevert(IBaseRequestManager.ExceedsMaxDeposit.selector);\n        vault.deposit(2, self, self);\n\n        // remainder is rounding difference\n        assertTrue(vault.maxDeposit(self) <= amount * 0.01e18);\n    }\n\n    function testPartialDepositExecutions() public {\n        uint8 SHARE_TOKEN_DECIMALS = 18; // Like DAI\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) = deployVault(\n            VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, bytes16(bytes(\"1\")), address(asset), 0, 0\n        );\n        AsyncVault vault = AsyncVault(vault_);\n        centrifugeChain.updatePricePoolPerShare(\n            poolId, vault.scId().raw(), 1000000000000000000, uint64(block.timestamp)\n        );\n\n        // invest\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(poolId, vault.scId().raw(), self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // first trigger executed collectInvest of the first 50% at a price of 1.4\n        uint128 assets = 50000000; // 50 * 10**6\n        uint128 firstSharePayout = 35714285714285714285; // 50 * 10**18 / 1.4, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, firstSharePayout\n        );\n\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1400000000000000000);\n\n        // second trigger executed collectInvest of the second 50% at a price of 1.2\n        uint128 secondSharePayout = 41666666666666666666; // 50 * 10**18 / 1.2, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, secondSharePayout\n        );\n\n        (,, depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1292307679384615384);\n\n        // assert deposit & mint values adjusted\n        assertApproxEqAbs(vault.maxDeposit(self), assets * 2, 2);\n        assertEq(vault.maxMint(self), firstSharePayout + secondSharePayout);\n    }\n\n    // function testDepositFairRounding(uint256 totalAmount, uint256 tokenAmount) public {\n    //     totalAmount = bound(totalAmount, 1 * 10 ** 6, type(uint128).max / 10 ** 12);\n    //     tokenAmount = bound(tokenAmount, 1 * 10 ** 6, type(uint128).max / 10 ** 12);\n\n    //     //Deploy a pool\n    //     AsyncVault vault = AsyncVault(deploySimpleVault(VaultKind.Async));\n    //     IShareToken shareToken = IShareToken(address(vault.share()));\n\n    //     root.relyContract(address(token), self);\n    //     shareToken.mint(poolEscrowFactory.escrow(POOL_A), type(uint128).max); // mint buffer to the escrow.\n    // Mock funds from other\n    // users\n\n    //     // fund user & request deposit\n    //     centrifugeChain.updateMember(vault.poolId(), vault.scId(), self, uint64(block.timestamp));\n    //     erc20.mint(self, totalAmount);\n    //     erc20.approve(address(vault), totalAmount);\n    //     vault.requestDeposit(totalAmount, self, self);\n\n    //     // Ensure funds were locked in escrow\n    //     assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), totalAmount);\n    //     assertEq(erc20.balanceOf(self), 0);\n\n    //     // Gateway returns randomly generated values for amount of share class tokens and asset\n    //     centrifugeChain.isFulfilledDepositRequest(\n    //         vault.poolId(),\n    //         vault.scId(),\n    //         bytes32(bytes20(self)),\n    //         defaultAssetId,\n    //         uint128(totalAmount),\n    //         uint128(tokenAmount)\n    //     );\n\n    //     // user claims multiple partial deposits\n    //     vm.assume(vault.maxDeposit(self) > 0);\n    //     assertEq(erc20.balanceOf(self), 0);\n    //     uint256 remaining = type(uint128).max;\n    //     while (vault.maxDeposit(self) > 0 && vault.maxDeposit(self) > remaining) {\n    //         uint256 randomDeposit = random(vault.maxDeposit(self), 1);\n\n    //         try vault.deposit(randomDeposit, self, self) {\n    //             if (vault.maxDeposit(self) == 0 && vault.maxMint(self) > 0) {\n    //                 // If you cannot deposit anymore because the 1 wei remaining is rounded down,\n    //                 // you should mint the remainder instead.\n    //                 uint256 minted = vault.mint(vault.maxMint(self), self);\n    //                 remaining -= minted;\n    //                 break;\n    //             }\n    //         } catch {\n    //             // If you cannot deposit anymore because the 1 wei remaining is rounded down,\n    //             // you should mint the remainder instead.\n    //             uint256 minted = vault.mint(vault.maxMint(self), self);\n    //             remaining -= minted;\n    //             break;\n    //         }\n    //     }\n\n    //     assertEq(vault.maxDeposit(self), 0);\n    //     assertApproxEqAbs(shareToken.balanceOf(self), tokenAmount, 1);\n    // }\n\n    // function testMintFairRounding(uint256 totalAmount, uint256 tokenAmount) public {\n    //     totalAmount = bound(totalAmount, 1 * 10 ** 6, type(uint128).max / 10 ** 12);\n    //     tokenAmount = bound(tokenAmount, 1 * 10 ** 6, type(uint128).max / 10 ** 12);\n\n    //     //Deploy a pool\n    //     AsyncVault vault = AsyncVault(deploySimpleVault(VaultKind.Async));\n    //     IShareToken shareToken = IShareToken(address(vault.share()));\n\n    //     root.relyContract(address(token), self);\n    //     shareToken.mint(poolEscrowFactory.escrow(POOL_A), type(uint128).max); // mint buffer to the escrow.\n    // Mock funds from other\n    // users\n\n    //     // fund user & request deposit\n    //     centrifugeChain.updateMember(vault.poolId(), vault.scId(), self, uint64(block.timestamp));\n    //     erc20.mint(self, totalAmount);\n    //     erc20.approve(address(vault), totalAmount);\n    //     vault.requestDeposit(totalAmount, self, self);\n\n    //     // Ensure funds were locked in escrow\n    //     assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), totalAmount);\n    //     assertEq(erc20.balanceOf(self), 0);\n\n    //     // Gateway returns randomly generated values for amount of share class tokens and asset\n    //     centrifugeChain.isFulfilledDepositRequest(\n    //         vault.poolId(),\n    //         vault.scId(),\n    //         bytes32(bytes20(self)),\n    //         defaultAssetId,\n    //         uint128(totalAmount),\n    //         uint128(tokenAmount)\n    //     );\n\n    //     // user claims multiple partial mints\n    //     uint256 i = 0;\n    //     while (vault.maxMint(self) > 0) {\n    //         uint256 randomMint = random(vault.maxMint(self), i);\n    //         try vault.mint(randomMint, self) {\n    //             i++;\n    //         } catch {\n    //             break;\n    //         }\n    //     }\n\n    //     assertEq(vault.maxMint(self), 0);\n    //     assertLe(shareToken.balanceOf(self), tokenAmount);\n    // }\n\n    function testDepositMintToReceiver(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        uint128 price = 2 * 10 ** 18;\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        address receiver = makeAddr(\"receiver\");\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), price, uint64(block.timestamp)\n        );\n        erc20.mint(self, amount);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max); // add user as\n            // member\n        erc20.approve(vault_, amount); // add allowance\n        vault.requestDeposit(amount, self, self);\n\n        // trigger executed collectInvest\n        uint128 shares = uint128(amount * 10 ** 18 / price); // sharePrice = 2$\n        assertApproxEqAbs(shares, amount / 2, 2);\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, uint128(amount), shares\n        );\n\n        // assert deposit & mint values adjusted\n        assertEq(vault.maxMint(self), shares); // max deposit\n        assertEq(vault.maxDeposit(self), amount); // max deposit\n        // assert share class tokens minted\n        assertEq(shareToken.balanceOf(address(globalEscrow)), shares);\n\n        // deposit 1/2 funds to receiver\n        vm.expectRevert(SafeTransferLib.SafeTransferFailed.selector);\n        vault.deposit(amount / 2, receiver, self); // mint half the amount\n\n        vm.expectRevert(SafeTransferLib.SafeTransferFailed.selector);\n        vault.mint(amount / 2, receiver); // mint half the amount\n\n        // add receiver number\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), receiver, type(uint64).max);\n\n        // success\n        vault.deposit(amount / 2, receiver, self); // mint half the amount\n        vault.mint(vault.maxMint(self), receiver); // mint half the amount\n\n        assertApproxEqAbs(shareToken.balanceOf(receiver), shares, 1);\n        assertApproxEqAbs(shareToken.balanceOf(receiver), shares, 1);\n        assertApproxEqAbs(shareToken.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), amount, 1);\n    }\n\n    function testDepositAsEndorsedOperator(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        uint128 price = 2 * 10 ** 18;\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        address receiver = makeAddr(\"receiver\");\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), price, uint64(block.timestamp)\n        );\n\n        erc20.mint(self, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max); // add user as\n            // member\n        erc20.approve(vault_, amount); // add allowance\n        vault.requestDeposit(amount, self, self);\n\n        // trigger executed collectInvest\n        uint128 sharePayout = uint128(amount * 10 ** 18 / price); // sharePrice = 2$\n        assertApproxEqAbs(sharePayout, amount / 2, 2);\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, uint128(amount), sharePayout\n        );\n\n        // assert deposit & mint values adjusted\n        assertEq(vault.maxMint(self), sharePayout); // max deposit\n        assertEq(vault.maxDeposit(self), amount); // max deposit\n        // assert share class tokens minted\n        assertEq(shareToken.balanceOf(address(globalEscrow)), sharePayout);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), receiver, type(uint64).max); // add\n            // receiver\n\n        address router = makeAddr(\"router\");\n\n        vm.startPrank(router);\n        vm.expectRevert(IBaseVault.InvalidController.selector); // fail without endorsement\n        vault.deposit(amount, receiver, address(this));\n        vm.stopPrank();\n\n        // endorse router\n        root.endorse(router);\n\n        vm.startPrank(router);\n        vm.expectRevert(IBaseVault.CannotSetSelfAsOperator.selector);\n        vault.setEndorsedOperator(address(router), true);\n\n        vault.setEndorsedOperator(address(this), true);\n        vault.deposit(amount, receiver, address(this));\n        vm.stopPrank();\n\n        assertApproxEqAbs(shareToken.balanceOf(receiver), sharePayout, 1);\n        assertApproxEqAbs(shareToken.balanceOf(receiver), sharePayout, 1);\n        assertApproxEqAbs(shareToken.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), amount, 1);\n    }\n\n    function testDepositAndRedeemPrecision() public {\n        uint8 SHARE_TOKEN_DECIMALS = 18; // Like DAI\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) = deployVault(\n            VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, bytes16(bytes(\"1\")), address(asset), 0, 0\n        );\n        AsyncVault vault = AsyncVault(vault_);\n        centrifugeChain.updatePricePoolPerShare(\n            poolId, vault.scId().raw(), 1000000000000000000, uint64(block.timestamp)\n        );\n\n        // invest\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(poolId, vault.scId().raw(), self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // trigger executed collectInvest of the first 50% at a price of 1.2\n        uint128 assets = 50000000; // 50 * 10**6\n        uint128 firstSharePayout = 41666666666666666666; // 50 * 10**18 / 1.2, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, firstSharePayout\n        );\n\n        // assert deposit & mint values adjusted\n        assertApproxEqAbs(vault.maxDeposit(self), assets, 1);\n        assertEq(vault.maxMint(self), firstSharePayout);\n\n        // deposit price should be ~1.2*10**18\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1200000000000000000);\n\n        // trigger executed collectInvest of the second 50% at a price of 1.4\n        assets = 50000000; // 50 * 10**6\n        uint128 secondSharePayout = 35714285714285714285; // 50 * 10**18 / 1.4, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, secondSharePayout\n        );\n\n        // collect the share class tokens\n        vault.mint(firstSharePayout + secondSharePayout, self);\n        assertEq(IShareToken(address(vault.share())).balanceOf(self), firstSharePayout + secondSharePayout);\n\n        // redeem\n        vault.requestRedeem(firstSharePayout + secondSharePayout, address(this), address(this));\n\n        // trigger executed collectRedeem at a price of 1.5\n        // 50% invested at 1.2 and 50% invested at 1.4 leads to ~77 share class tokens\n        // when redeeming at a price of 1.5, this leads to ~115.5 asset\n        assets = 115500000; // 115.5*10**6\n\n        // mint interest into escrow\n        asset.mint(address(poolEscrowFactory.escrow(vault.poolId())), assets - investmentAmount);\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            poolId, vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, firstSharePayout + secondSharePayout\n        );\n\n        // redeem price should now be ~1.5*10**18.\n        (,,, uint256 redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1492615384615384615);\n    }\n\n    function testDepositAndRedeemPrecisionWithInverseDecimals(bytes16 scId) public {\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", 18);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1000000000000000000000000000, uint64(block.timestamp));\n\n        // invest\n        uint256 investmentAmount = 100e18;\n        centrifugeChain.updateMember(poolId, scId, self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // trigger executed collectInvest of the first 50% at a price of 1.2\n        uint128 assets = 50e18;\n        uint128 firstSharePayout = 41666666; // 50 * 10**6 / 1.2, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId, assets, firstSharePayout\n        );\n\n        // assert deposit & mint values adjusted\n        assertApproxEqAbs(vault.maxDeposit(self), assets, 10);\n        assertEq(vault.maxMint(self), firstSharePayout);\n\n        // deposit price should be ~1.2*10**18\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1200000019200000307);\n\n        // trigger executed collectInvest of the second 50% at a price of 1.4\n        assets = 50e18; // 50 * 10**18\n        uint128 secondSharePayout = 35714285; // 50 * 10**6 / 1.4, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId, assets, secondSharePayout\n        );\n\n        // collect the share class tokens\n        vault.mint(firstSharePayout + secondSharePayout, self);\n        assertEq(shareToken.balanceOf(self), firstSharePayout + secondSharePayout);\n\n        // redeem\n        vault.requestRedeem(firstSharePayout + secondSharePayout, address(this), address(this));\n\n        // trigger executed collectRedeem at a price of 1.5\n        // 50% invested at 1.2 and 50% invested at 1.4 leads to ~77 share class tokens\n        // when redeeming at a price of 1.5, this leads to ~115.5 assets\n        // assets = 115500000000000000000; // 115.5*10**18\n        assets = 115.5e18; // 115.5*10**18\n\n        // Adjust escrow for interest\n        // NOTE: In reality, the FM would have allocate the interest;\n        asset.approve(address(poolEscrowFactory.escrow(PoolId.wrap(poolId))), type(uint256).max);\n        _topUpEscrow(PoolId.wrap(poolId), ShareClassId.wrap(scId), asset, assets - investmentAmount);\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId, assets, firstSharePayout + secondSharePayout\n        );\n\n        // redeem price should now be ~1.5*10**18.\n        (,,, uint256 redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1492615411252828877);\n\n        // collect the asset\n        vault.withdraw(assets, self, self);\n        assertEq(asset.balanceOf(self), assets);\n    }\n\n    // Test that assumes the swap from usdc (investment asset) to dai (pool asset) has a cost of 1%\n    function testDepositAndRedeemPrecisionWithSlippage(bytes16 scId) public {\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n        uint8 SHARE_TOKEN_DECIMALS = 18; // Like DAI\n\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n\n        // price = (100*10**18) /  (99 * 10**18) = 101.010101 * 10**18\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1010101010101010101, uint64(block.timestamp));\n\n        // invest\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(poolId, scId, self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // trigger executed collectInvest at a share class token price of 1.2\n        uint128 assets = 99000000; // 99 * 10**6\n\n        // invested amount in dai is 99 * 10**18\n        // executed at price of 1.2, leads to a share class token payout of\n        // 99 * 10**18 / 1.2 = 82500000000000000000\n        uint128 shares = 82500000000000000000;\n        centrifugeChain.isFulfilledDepositRequest(poolId, scId, bytes32(bytes20(self)), assetId, assets, shares);\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1200000000000000000, uint64(block.timestamp));\n\n        // assert deposit & mint values adjusted\n        assertEq(vault.maxDeposit(self), assets);\n        assertEq(vault.maxMint(self), shares);\n\n        // lp price is set to the deposit price\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1200000000000000000);\n    }\n\n    // Test that assumes the swap from usdc (investment asset) to dai (pool asset) has a cost of 1%\n    function testDepositAndRedeemPrecisionWithSlippageAndWithInverseDecimal(bytes16 scId) public {\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 18; // 18, like DAI\n        uint8 SHARE_TOKEN_DECIMALS = 6; // Like USDC\n\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n\n        // price = (100*10**18) /  (99 * 10**18) = 101.010101 * 10**18\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1010101010101010101, uint64(block.timestamp));\n\n        // invest\n        uint256 investmentAmount = 100000000000000000000; // 100 * 10**18\n        centrifugeChain.updateMember(poolId, scId, self, type(uint64).max);\n        asset.approve(vault_, investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // trigger executed collectInvest at a share class token price of 1.2\n        uint128 assets = 99000000000000000000; // 99 * 10**18\n\n        // invested amount in dai is 99 * 10**18\n        // executed at price of 1.2, leads to a share class token payout of\n        // 99 * 10**6 / 1.2 = 82500000\n        uint128 shares = 82500000;\n        centrifugeChain.isFulfilledDepositRequest(poolId, scId, bytes32(bytes20(self)), assetId, assets, shares);\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1200000000000000000, uint64(block.timestamp));\n\n        // assert deposit & mint values adjusted\n        assertEq(vault.maxDeposit(self), assets);\n        assertEq(vault.maxMint(self), shares);\n\n        // lp price is set to the deposit price\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1200000000000000000);\n    }\n\n    function testCancelDepositOrder(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128));\n\n        uint128 price = 2 * 10 ** 18;\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        centrifugeChain.updatePricePoolPerShare(poolId.raw(), scId.raw(), price, uint64(block.timestamp));\n        erc20.mint(self, amount);\n        erc20.approve(vault_, amount);\n        centrifugeChain.updateMember(poolId.raw(), scId.raw(), self, type(uint64).max);\n\n        vault.requestDeposit(amount, self, self);\n\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n        assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0);\n        assertEq(erc20.balanceOf(address(self)), 0);\n\n        vm.expectRevert(IAsyncRequestManager.NoPendingRequest.selector);\n        asyncRequestManager.fulfillCancelDepositRequest(\n            poolId, scId, self, AssetId.wrap(assetId), uint128(amount), uint128(amount)\n        );\n\n        // check message was send out to centchain\n        vault.cancelDepositRequest(0, self);\n\n        MessageLib.CancelDepositRequest memory m = adapter1.values_bytes(\"send\").deserializeCancelDepositRequest();\n        assertEq(m.poolId, vault.poolId().raw());\n        assertEq(m.scId, vault.scId().raw());\n        assertEq(m.investor, bytes32(bytes20(self)));\n        assertEq(m.assetId, assetId);\n\n        assertEq(vault.pendingCancelDepositRequest(0, self), true);\n\n        // Cannot cancel twice\n        vm.expectRevert(IAsyncRequestManager.CancellationIsPending.selector);\n        vault.cancelDepositRequest(0, self);\n\n        erc20.mint(self, amount);\n        erc20.approve(vault_, amount);\n        vm.expectRevert(IAsyncRequestManager.CancellationIsPending.selector);\n        vault.requestDeposit(amount, self, self);\n        erc20.burn(self, amount);\n\n        centrifugeChain.isFulfilledCancelDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), self.toBytes32(), assetId, uint128(amount)\n        );\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n        assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0);\n        assertEq(erc20.balanceOf(self), 0);\n        assertEq(vault.claimableCancelDepositRequest(0, self), amount);\n        assertEq(vault.pendingCancelDepositRequest(0, self), false);\n\n        // After cancellation is executed, new request can be submitted\n        erc20.mint(self, amount);\n        erc20.approve(vault_, amount);\n        vault.requestDeposit(amount, self, self);\n    }\n\n    function partialDeposit(bytes16 scId, AsyncVault vault, ERC20 asset) public {\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(vault.poolId().raw(), scId, self, type(uint64).max);\n        asset.approve(address(vault), investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n        AssetId assetId = poolManager.assetToId(address(asset), erc20TokenId); // retrieve assetId\n\n        // first trigger executed collectInvest of the first 50% at a price of 1.4\n        uint128 assets = 50000000; // 50 * 10**6\n        uint128 firstSharePayout = 35714285714285714285; // 50 * 10**18 / 1.4, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), scId, bytes32(bytes20(self)), assetId.raw(), assets, firstSharePayout\n        );\n\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1400000000000000000);\n\n        // second trigger executed collectInvest of the second 50% at a price of 1.2\n        uint128 secondSharePayout = 41666666666666666666; // 50 * 10**18 / 1.2, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), scId, bytes32(bytes20(self)), assetId.raw(), assets, secondSharePayout\n        );\n\n        (,, depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1292307679384615384);\n\n        // assert deposit & mint values adjusted\n        assertApproxEqAbs(vault.maxDeposit(self), assets * 2, 2);\n        assertEq(vault.maxMint(self), firstSharePayout + secondSharePayout);\n\n        // collect the share class tokens\n        vault.mint(firstSharePayout + secondSharePayout, self);\n        assertEq(shareToken.balanceOf(self), firstSharePayout + secondSharePayout);\n    }\n\n    function testDepositAsInvestorDirectly(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        assertEq(shareToken.balanceOf(investor), 0);\n\n        erc20.mint(investor, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max); // add user\n            // as\n\n        vm.startPrank(investor);\n        erc20.approve(vault_, amount);\n        vault.requestDeposit(amount, investor, investor);\n        vm.stopPrank();\n\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), investor.toBytes32(), assetId, uint128(amount), uint128(amount)\n        );\n        vm.expectRevert(IBaseRequestManager.ExceedsMaxDeposit.selector);\n        vault.deposit(amount, investor);\n\n        vm.prank(investor);\n        uint256 shares = vault.deposit(amount, investor);\n\n        assertEq(shareToken.balanceOf(investor), amount);\n        assertEq(shares, amount);\n    }\n\n    function _topUpEscrow(PoolId poolId, ShareClassId scId, ERC20 asset, uint256 assetAmount) internal {\n        asset.mint(address(this), assetAmount);\n        asset.approve(address(balanceSheet), assetAmount);\n        balanceSheet.deposit(poolId, scId, address(asset), 0, address(this), assetAmount.toUint128());\n    }\n}\n"
    },
    "test/vaults/integration/DepositRedeem.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\n\ncontract DepositRedeem is BaseTest {\n    function testPartialDepositAndRedeemExecutions(bytes16 scId) public {\n        uint8 SHARE_TOKEN_DECIMALS = 18; // Like DAI\n        uint8 INVESTMENT_CURRENCY_DECIMALS = 6; // 6, like USDC\n\n        ERC20 asset = _newErc20(\"Currency\", \"CR\", INVESTMENT_CURRENCY_DECIMALS);\n        (uint64 poolId, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, SHARE_TOKEN_DECIMALS, fullRestrictionsHook, scId, address(asset), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n\n        centrifugeChain.updatePricePoolPerShare(poolId, scId, 1e18, uint64(block.timestamp));\n\n        centrifugeChain.updatePricePoolPerAsset(poolId, scId, assetId, 1e18, uint64(block.timestamp));\n\n        partialDeposit(poolId, scId, vault, asset);\n\n        partialRedeem(poolId, scId, vault, asset);\n    }\n\n    // Helpers\n\n    function partialDeposit(uint64 poolId, bytes16 scId, AsyncVault vault, ERC20 asset) public {\n        vm.assume(poolId >> 48 != THIS_CHAIN_ID);\n\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(poolId, scId, self, type(uint64).max);\n        asset.approve(address(vault), investmentAmount);\n        asset.mint(self, investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        // first trigger executed collectInvest of the first 50% at a price of 1.4\n        AssetId assetId = poolManager.assetToId(address(asset), erc20TokenId); // retrieve assetId\n        uint128 assets = 50000000; // 50 * 10**6\n        uint128 firstSharePayout = 35714285714285714285; // 50 * 10**18 / 1.4, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId.raw(), assets, firstSharePayout\n        );\n\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1400000000000000000);\n\n        // second trigger executed collectInvest of the second 50% at a price of 1.2\n        uint128 secondSharePayout = 41666666666666666666; // 50 * 10**18 / 1.2, rounded down\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId.raw(), assets, secondSharePayout\n        );\n\n        (,, depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1292307679384615384);\n\n        // assert deposit & mint values adjusted\n        assertApproxEqAbs(vault.maxDeposit(self), assets * 2, 2);\n        assertEq(vault.maxMint(self), firstSharePayout + secondSharePayout);\n\n        // collect the share class tokens\n        vault.mint(firstSharePayout + secondSharePayout, self);\n        assertEq(shareToken.balanceOf(self), firstSharePayout + secondSharePayout);\n    }\n\n    function partialRedeem(uint64 poolId, bytes16 scId, AsyncVault vault, ERC20 asset) public {\n        vm.assume(poolId >> 48 != THIS_CHAIN_ID);\n\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        AssetId assetId = poolManager.assetToId(address(asset), erc20TokenId);\n        uint256 totalShares = shareToken.balanceOf(self);\n        uint256 redeemAmount = 50000000000000000000;\n        assertTrue(redeemAmount <= totalShares);\n        vault.requestRedeem(redeemAmount, self, self);\n\n        // first trigger executed collectRedeem of the first 25 share class tokens at a price of 1.1\n        uint128 firstShareRedeem = 25000000000000000000;\n        uint128 secondShareRedeem = 25000000000000000000;\n        assertEq(firstShareRedeem + secondShareRedeem, redeemAmount);\n        uint128 firstCurrencyPayout = 27500000; // (25000000000000000000/10**18) * 10**6 * 1.1\n        centrifugeChain.isFulfilledRedeemRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId.raw(), firstCurrencyPayout, firstShareRedeem\n        );\n\n        assertEq(vault.maxRedeem(self), firstShareRedeem);\n\n        (,,, uint256 redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1100000000000000000);\n\n        // second trigger executed collectRedeem of the second 25 share class tokens at a price of 1.3\n        uint128 secondCurrencyPayout = 32500000; // (25000000000000000000/10**18) * 10**6 * 1.3\n        centrifugeChain.isFulfilledRedeemRequest(\n            poolId, scId, bytes32(bytes20(self)), assetId.raw(), secondCurrencyPayout, secondShareRedeem\n        );\n\n        (,,, redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1200000000000000000);\n\n        assertApproxEqAbs(vault.maxWithdraw(self), firstCurrencyPayout + secondCurrencyPayout, 2);\n        assertEq(vault.maxRedeem(self), redeemAmount);\n\n        // collect the asset\n        vault.redeem(redeemAmount, self, self);\n        assertEq(shareToken.balanceOf(self), totalShares - redeemAmount);\n        assertEq(asset.balanceOf(self), firstCurrencyPayout + secondCurrencyPayout);\n    }\n}\n"
    },
    "test/vaults/integration/Mint.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\n\ncontract MintTest is BaseTest {\n    function testMint(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128));\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        root.denyContract(address(shareToken), self);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        shareToken.mint(investor, amount);\n\n        root.relyContract(address(shareToken), self); // give self auth permissions\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        shareToken.mint(investor, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n\n        // success\n        shareToken.mint(investor, amount);\n        assertEq(shareToken.balanceOf(investor), amount);\n    }\n}\n"
    },
    "test/vaults/integration/Operator.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\n\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\nimport {IBaseVault, IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ncontract OperatorTest is BaseTest {\n    function testDepositAsOperator(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        uint128 price = 2 * 10 ** 18;\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        address investor = makeAddr(\"investor\");\n        address operator = makeAddr(\"operator\");\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), price, uint64(block.timestamp)\n        );\n\n        erc20.mint(investor, amount);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        vm.prank(investor);\n        erc20.approve(vault_, amount);\n\n        vm.prank(operator);\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vault.requestDeposit(amount, investor, investor);\n\n        vm.prank(investor);\n        vm.expectRevert(IBaseVault.CannotSetSelfAsOperator.selector);\n        vault.setOperator(investor, true);\n\n        assertEq(vault.isOperator(investor, operator), false);\n        vm.prank(investor);\n        vault.setOperator(operator, true);\n        assertEq(vault.isOperator(investor, operator), true);\n\n        vm.prank(operator);\n        vault.requestDeposit(amount, investor, investor);\n        assertEq(vault.pendingDepositRequest(0, investor), amount);\n        assertEq(vault.pendingDepositRequest(0, operator), 0);\n\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(),\n            vault.scId().raw(),\n            bytes32(bytes20(investor)),\n            assetId,\n            uint128(amount),\n            uint128(amount)\n        );\n\n        vm.prank(operator);\n        vault.deposit(amount, investor, investor);\n        assertEq(vault.pendingDepositRequest(0, investor), 0);\n        assertEq(shareToken.balanceOf(investor), amount);\n\n        vm.prank(investor);\n        vault.setOperator(operator, false);\n\n        vm.prank(operator);\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vault.requestDeposit(amount, investor, investor);\n    }\n\n    function testDepositAsAuthorizedOperator(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        uint128 price = 2 * 10 ** 18;\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        (address controller, uint256 controllerPk) = makeAddrAndKey(\"controller\");\n        address operator = makeAddr(\"operator\");\n        AsyncVault vault = AsyncVault(vault_);\n\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), price, uint64(block.timestamp)\n        );\n\n        erc20.mint(controller, amount);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), controller, type(uint64).max);\n        vm.prank(controller);\n        erc20.approve(vault_, amount);\n\n        vm.prank(operator);\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vault.requestDeposit(amount, controller, controller);\n\n        uint256 deadline = type(uint64).max;\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            controllerPk,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    vault.DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            vault.AUTHORIZE_OPERATOR_TYPEHASH(),\n                            controller,\n                            controller,\n                            true,\n                            bytes32(\"nonce\"),\n                            deadline\n                        )\n                    )\n                )\n            )\n        );\n        bytes memory signature = abi.encodePacked(r, s, v);\n        vm.prank(controller);\n        vm.expectRevert(IBaseVault.CannotSetSelfAsOperator.selector);\n        vault.authorizeOperator(controller, controller, true, bytes32(\"nonce\"), deadline, signature);\n\n        (v, r, s) = vm.sign(\n            controllerPk,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    vault.DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            vault.AUTHORIZE_OPERATOR_TYPEHASH(), controller, operator, true, bytes32(\"nonce\"), deadline\n                        )\n                    )\n                )\n            )\n        );\n        signature = abi.encodePacked(r, s, v);\n        delete r;\n        delete s;\n        delete v;\n\n        assertEq(vault.isOperator(controller, operator), false);\n        vm.prank(operator);\n        vault.authorizeOperator(controller, operator, true, bytes32(\"nonce\"), deadline, signature);\n        assertEq(vault.isOperator(controller, operator), true);\n\n        vm.prank(operator);\n        vault.requestDeposit(amount, controller, controller);\n        assertEq(vault.pendingDepositRequest(0, controller), amount);\n        assertEq(vault.pendingDepositRequest(0, operator), 0);\n    }\n\n    function testRedeemAsOperator(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128 / 2));\n        vm.assume(amount % 2 == 0);\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        address investor = makeAddr(\"investor\");\n        address operator = makeAddr(\"operator\");\n        AsyncVault vault = AsyncVault(vault_);\n\n        deposit(vault_, investor, amount); // deposit funds first\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), defaultPrice, uint64(block.timestamp)\n        );\n\n        vm.prank(operator);\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        vault.requestRedeem(amount, investor, investor);\n\n        assertEq(vault.isOperator(investor, operator), false);\n        vm.prank(investor);\n        vault.setOperator(operator, true);\n        assertEq(vault.isOperator(investor, operator), true);\n\n        vm.prank(operator);\n        vault.requestRedeem(amount, investor, investor);\n        assertEq(vault.pendingRedeemRequest(0, investor), amount);\n        assertEq(vault.pendingRedeemRequest(0, operator), 0);\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(),\n            vault.scId().raw(),\n            bytes32(bytes20(investor)),\n            assetId,\n            uint128(amount),\n            uint128(amount)\n        );\n\n        vm.prank(operator);\n        vault.redeem(amount, investor, investor);\n        assertEq(vault.pendingRedeemRequest(0, investor), 0);\n        assertEq(erc20.balanceOf(investor), amount);\n\n        vm.prank(investor);\n        vault.setOperator(operator, false);\n\n        deposit(vault_, investor, amount);\n        vm.prank(operator);\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        vault.requestRedeem(amount, investor, investor);\n    }\n\n    function testInvalidateNonce(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        uint128 price = 2 * 10 ** 18;\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        (address controller, uint256 controllerPk) = makeAddrAndKey(\"controller\");\n        address operator = makeAddr(\"operator\");\n        AsyncVault vault = AsyncVault(vault_);\n\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), price, uint64(block.timestamp)\n        );\n\n        erc20.mint(controller, amount);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), controller, type(uint64).max);\n        vm.prank(controller);\n        erc20.approve(vault_, amount);\n\n        vm.prank(operator);\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vault.requestDeposit(amount, controller, controller);\n\n        uint256 deadline = type(uint64).max;\n        bytes32 nonce = bytes32(\"nonce\");\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            controllerPk,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    vault.DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(vault.AUTHORIZE_OPERATOR_TYPEHASH(), controller, operator, true, deadline, nonce)\n                    )\n                )\n            )\n        );\n        bytes memory signature = abi.encodePacked(r, s, v);\n        delete r;\n        delete s;\n        delete v;\n\n        vm.prank(controller);\n        vault.invalidateNonce(nonce);\n\n        assertEq(vault.authorizations(controller, nonce), true);\n\n        vm.expectRevert(IBaseVault.AlreadyUsedAuthorization.selector);\n        vm.prank(operator);\n        vault.authorizeOperator(controller, operator, true, nonce, deadline, signature);\n        assertEq(vault.isOperator(controller, operator), false);\n    }\n}\n"
    },
    "test/vaults/integration/PoolManager.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MockERC6909} from \"test/misc/mocks/MockERC6909.sol\";\nimport {MockHook} from \"test/vaults/mocks/MockHook.sol\";\nimport \"test/vaults/BaseTest.sol\";\n\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IERC6909} from \"src/misc/interfaces/IERC6909.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {D18} from \"src/misc/types/D18.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IPoolManager, VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {ISyncRequestManager} from \"src/vaults/interfaces/investments/ISyncRequestManager.sol\";\nimport {IUpdateContract} from \"src/vaults/interfaces/IUpdateContract.sol\";\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\n\nimport {IMemberlist} from \"src/hooks/interfaces/IMemberlist.sol\";\n\ncontract PoolManagerTestHelper is BaseTest {\n    PoolId poolId;\n    uint8 decimals;\n    string tokenName;\n    string tokenSymbol;\n    ShareClassId scId;\n    address assetErc20;\n    AssetId assetIdErc20;\n\n    // helpers\n    function hasDuplicates(ShareClassId[4] calldata array) internal pure returns (bool) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length; i++) {\n            for (uint256 j = i + 1; j < length; j++) {\n                if (array[i].raw() == array[j].raw()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function setUpPoolAndShare(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        decimals_ = uint8(bound(decimals_, 2, 18));\n        vm.assume(bytes(tokenName_).length <= 128);\n        vm.assume(bytes(tokenSymbol_).length <= 32);\n\n        poolId = poolId_;\n        decimals = decimals_;\n        tokenName = tokenName;\n        tokenSymbol = tokenSymbol_;\n        scId = scId_;\n\n        poolManager.addPool(poolId);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, bytes32(0), address(new MockHook()));\n    }\n\n    function registerAssetErc20() public {\n        assetErc20 = address(_newErc20(tokenName, tokenSymbol, decimals));\n        assetIdErc20 = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, assetErc20, 0);\n    }\n}\n\ncontract PoolManagerTest is BaseTest, PoolManagerTestHelper {\n    using MessageLib for *;\n    using CastLib for *;\n\n    // Deployment\n    function testDeployment(address nonWard) public {\n        vm.assume(\n            nonWard != address(root) && nonWard != address(vaultRouter) && nonWard != address(this)\n                && nonWard != address(messageProcessor) && nonWard != address(messageDispatcher)\n                && nonWard != address(gateway)\n        );\n\n        // redeploying within test to increase coverage\n        new PoolManager(tokenFactory, address(this));\n        poolManager.file(\"vaultFactory\", address(asyncVaultFactory), true);\n\n        // values set correctly\n        assertEq(address(messageDispatcher.poolManager()), address(poolManager));\n        assertEq(address(balanceSheet.poolManager()), address(poolManager));\n        assertEq(address(asyncRequestManager.poolManager()), address(poolManager));\n        assertEq(address(syncRequestManager.poolManager()), address(poolManager));\n\n        assertEq(address(poolManager.poolEscrowFactory()), address(poolEscrowFactory));\n        assertEq(address(poolManager.tokenFactory()), address(tokenFactory));\n        assertEq(address(poolManager.balanceSheet()), address(balanceSheet));\n        assertEq(address(poolManager.sender()), address(messageDispatcher));\n\n        // permissions set correctly\n        assertEq(poolManager.wards(address(root)), 1);\n        assertEq(poolManager.wards(address(gateway)), 1);\n        assertEq(poolManager.wards(address(vaultRouter)), 1);\n        assertEq(poolManager.wards(nonWard), 0);\n    }\n\n    function testFile() public {\n        address newSender = makeAddr(\"newSender\");\n        vm.expectEmit();\n        emit IPoolManager.File(\"sender\", newSender);\n        poolManager.file(\"sender\", newSender);\n        assertEq(address(poolManager.sender()), newSender);\n\n        address newBalanceSheet = makeAddr(\"newBalanceSheet\");\n        vm.expectEmit();\n        emit IPoolManager.File(\"balanceSheet\", newBalanceSheet);\n        poolManager.file(\"balanceSheet\", newBalanceSheet);\n        assertEq(poolManager.balanceSheet(), newBalanceSheet);\n\n        address newTokenFactory = makeAddr(\"newTokenFactory\");\n        vm.expectEmit();\n        emit IPoolManager.File(\"tokenFactory\", newTokenFactory);\n        poolManager.file(\"tokenFactory\", newTokenFactory);\n        assertEq(address(poolManager.tokenFactory()), newTokenFactory);\n\n        address newPoolEscrowFactory = makeAddr(\"newPoolEscrowFactory\");\n        vm.expectEmit();\n        emit IPoolManager.File(\"poolEscrowFactory\", newPoolEscrowFactory);\n        poolManager.file(\"poolEscrowFactory\", newPoolEscrowFactory);\n        assertEq(address(poolManager.poolEscrowFactory()), newPoolEscrowFactory);\n\n        IVaultFactory newVaultFactory = IVaultFactory(makeAddr(\"newVaultFactory\"));\n        assertEq(poolManager.vaultFactory(newVaultFactory), false);\n        poolManager.file(\"vaultFactory\", address(newVaultFactory), true);\n        assertEq(poolManager.vaultFactory(newVaultFactory), true);\n        assertEq(poolManager.vaultFactory(asyncVaultFactory), true);\n\n        vm.expectEmit();\n        emit IPoolManager.File(\"vaultFactory\", address(newVaultFactory), false);\n        poolManager.file(\"vaultFactory\", address(newVaultFactory), false);\n        assertEq(poolManager.vaultFactory(newVaultFactory), false);\n\n        IAsyncRequestManager newAsyncRequestManager = IAsyncRequestManager(makeAddr(\"newAsyncRequestManager\"));\n        vm.expectEmit();\n        emit IPoolManager.File(\"asyncRequestManager\", address(newAsyncRequestManager));\n        poolManager.file(\"asyncRequestManager\", address(newAsyncRequestManager));\n        assertEq(address(poolManager.asyncRequestManager()), address(newAsyncRequestManager));\n\n        IAsyncRequestManager newSyncRequestManager = IAsyncRequestManager(makeAddr(\"newSyncRequestManager\"));\n        vm.expectEmit();\n        emit IPoolManager.File(\"syncRequestManager\", address(newSyncRequestManager));\n        poolManager.file(\"syncRequestManager\", address(newSyncRequestManager));\n        assertEq(address(poolManager.syncRequestManager()), address(newSyncRequestManager));\n\n        address newEscrow = makeAddr(\"newEscrow\");\n        vm.expectRevert(IPoolManager.FileUnrecognizedParam.selector);\n        poolManager.file(\"escrow\", newEscrow);\n\n        vm.expectRevert(IPoolManager.FileUnrecognizedParam.selector);\n        poolManager.file(\"escrow\", newEscrow, true);\n\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.file(\"\", address(0));\n\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.file(\"\", address(0), true);\n    }\n\n    function testAddPool(PoolId poolId) public {\n        poolManager.addPool(poolId);\n\n        vm.expectRevert(IPoolManager.PoolAlreadyAdded.selector);\n        poolManager.addPool(poolId);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.addPool(poolId);\n    }\n\n    function testAddShareClass(\n        PoolId poolId,\n        ShareClassId scId,\n        string memory tokenName,\n        string memory tokenSymbol,\n        bytes32 salt,\n        uint8 decimals\n    ) public {\n        decimals = uint8(bound(decimals, 2, 18));\n        vm.assume(bytes(tokenName).length <= 128);\n        vm.assume(bytes(tokenSymbol).length <= 32);\n\n        address hook = address(new MockHook());\n\n        vm.expectRevert(IPoolManager.InvalidPool.selector);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, salt, hook);\n        poolManager.addPool(poolId);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, salt, hook);\n\n        vm.expectRevert(IPoolManager.TooFewDecimals.selector);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, 0, bytes32(0), hook);\n\n        vm.expectRevert(IPoolManager.TooManyDecimals.selector);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, 19, bytes32(0), hook);\n\n        vm.expectRevert(IPoolManager.InvalidHook.selector);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, salt, address(1));\n\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, salt, hook);\n        IShareToken shareToken = poolManager.shareToken(poolId, scId);\n        assertEq(tokenName, shareToken.name());\n        assertEq(tokenSymbol, shareToken.symbol());\n        assertEq(decimals, shareToken.decimals());\n        assertEq(hook, shareToken.hook());\n\n        vm.expectRevert(IPoolManager.ShareClassAlreadyRegistered.selector);\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, salt, hook);\n    }\n\n    function testAddMultipleSharesWorks(\n        PoolId poolId,\n        ShareClassId[4] calldata scIds,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals\n    ) public {\n        decimals = uint8(bound(decimals, 2, 18));\n        vm.assume(!hasDuplicates(scIds));\n        vm.assume(bytes(tokenName).length <= 128);\n        vm.assume(bytes(tokenSymbol).length <= 32);\n\n        poolManager.addPool(poolId);\n\n        address hook = address(new MockHook());\n\n        for (uint256 i = 0; i < scIds.length; i++) {\n            poolManager.addShareClass(poolId, scIds[i], tokenName, tokenSymbol, decimals, bytes32(i), hook);\n            IShareToken shareToken = poolManager.shareToken(poolId, scIds[i]);\n            assertEq(tokenName, shareToken.name());\n            assertEq(tokenSymbol, shareToken.symbol());\n            assertEq(decimals, shareToken.decimals());\n        }\n    }\n\n    function testTransferSharesToCentrifuge(uint128 amount) public {\n        vm.assume(amount > 0);\n        uint64 validUntil = uint64(block.timestamp + 7 days);\n        bytes32 centChainAddress = makeAddr(\"centChainAddress\").toBytes32();\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n\n        // fund this account with amount\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(address(this).toBytes32(), validUntil).serialize()\n        );\n\n        poolManager.handleTransferShares(vault.poolId(), vault.scId(), address(this), amount);\n        assertEq(shareToken.balanceOf(address(this)), amount); // Verify the address(this) has the expected amount\n\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(address(uint160(OTHER_CHAIN_ID)).toBytes32(), type(uint64).max).serialize(\n            )\n        );\n\n        // fails for invalid share class token\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.transferShares{value: defaultGas}(\n            OTHER_CHAIN_ID, PoolId.wrap(poolId.raw() + 1), scId, centChainAddress, amount\n        );\n\n        // send the transfer from EVM -> Cent Chain\n        poolManager.transferShares{value: defaultGas}(OTHER_CHAIN_ID, poolId, scId, centChainAddress, amount);\n        assertEq(shareToken.balanceOf(address(this)), 0);\n\n        // Finally, verify the connector called `adapter.send`\n        bytes memory message = MessageLib.TransferShares(poolId.raw(), scId.raw(), centChainAddress, amount).serialize();\n        assertEq(adapter1.sent(message), 1);\n    }\n\n    function testTransferSharesFromCentrifuge(uint128 amount) public {\n        vm.assume(amount > 0);\n        uint64 validUntil = uint64(block.timestamp + 7 days);\n        address destinationAddress = makeAddr(\"destinationAddress\");\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        poolManager.handleTransferShares(poolId, scId, destinationAddress, amount);\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionMember(destinationAddress.toBytes32(), validUntil).serialize()\n        );\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.handleTransferShares(PoolId.wrap(poolId.raw() + 1), scId, destinationAddress, amount);\n\n        assertTrue(shareToken.checkTransferRestriction(address(0), destinationAddress, 0));\n        poolManager.handleTransferShares(poolId, scId, destinationAddress, amount);\n        assertEq(shareToken.balanceOf(destinationAddress), amount);\n    }\n\n    function testTransferSharesToEVM(uint128 amount) public {\n        uint64 validUntil = uint64(block.timestamp + 7 days);\n        address destinationAddress = makeAddr(\"destinationAddress\");\n        vm.assume(amount > 0);\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(destinationAddress.toBytes32(), validUntil).serialize()\n        );\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(address(this).toBytes32(), validUntil).serialize()\n        );\n        assertTrue(shareToken.checkTransferRestriction(address(0), address(this), 0));\n        assertTrue(shareToken.checkTransferRestriction(address(0), destinationAddress, 0));\n\n        // Fund this address with samount\n        poolManager.handleTransferShares(vault.poolId(), vault.scId(), address(this), amount);\n        assertEq(shareToken.balanceOf(address(this)), amount);\n\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(address(uint160(OTHER_CHAIN_ID)).toBytes32(), type(uint64).max).serialize(\n            )\n        );\n\n        // fails for invalid share class token\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.transferShares{value: defaultGas}(\n            OTHER_CHAIN_ID, PoolId.wrap(poolId.raw() + 1), scId, destinationAddress.toBytes32(), amount\n        );\n\n        // Transfer amount from this address to destinationAddress\n        poolManager.transferShares{value: defaultGas}(\n            OTHER_CHAIN_ID, vault.poolId(), vault.scId(), destinationAddress.toBytes32(), amount\n        );\n        assertEq(shareToken.balanceOf(address(this)), 0);\n    }\n\n    function testUpdateMember(uint64 validUntil) public {\n        validUntil = uint64(bound(validUntil, block.timestamp, type(uint64).max));\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(AsyncVault(vault_).share());\n\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        IMemberlist hook = IMemberlist(shareToken.hook());\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        hook.updateMember(address(shareToken), randomUser, validUntil);\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.updateRestriction(\n            PoolId.wrap(100),\n            ShareClassId.wrap(bytes16(bytes(\"100\"))),\n            MessageLib.UpdateRestrictionMember(randomUser.toBytes32(), validUntil).serialize()\n        ); // use random poolId & shareId\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionMember(randomUser.toBytes32(), validUntil).serialize()\n        );\n        assertTrue(shareToken.checkTransferRestriction(address(0), randomUser, 0));\n    }\n\n    function testFreezeAndUnfreeze() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        IShareToken shareToken = IShareToken(AsyncVault(vault_).share());\n        uint64 validUntil = uint64(block.timestamp + 7 days);\n        address secondUser = makeAddr(\"secondUser\");\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.updateRestriction(\n            PoolId.wrap(poolId.raw() + 1), scId, MessageLib.UpdateRestrictionFreeze(randomUser.toBytes32()).serialize()\n        );\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.updateRestriction(\n            PoolId.wrap(poolId.raw() + 1),\n            scId,\n            MessageLib.UpdateRestrictionUnfreeze(randomUser.toBytes32()).serialize()\n        );\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionMember(randomUser.toBytes32(), validUntil).serialize()\n        );\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionMember(secondUser.toBytes32(), validUntil).serialize()\n        );\n        assertTrue(shareToken.checkTransferRestriction(randomUser, secondUser, 0));\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionFreeze(randomUser.toBytes32()).serialize()\n        );\n        assertFalse(shareToken.checkTransferRestriction(randomUser, secondUser, 0));\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionUnfreeze(randomUser.toBytes32()).serialize()\n        );\n        assertTrue(shareToken.checkTransferRestriction(randomUser, secondUser, 0));\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionFreeze(secondUser.toBytes32()).serialize()\n        );\n        assertFalse(shareToken.checkTransferRestriction(randomUser, secondUser, 0));\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionUnfreeze(secondUser.toBytes32()).serialize()\n        );\n        assertTrue(shareToken.checkTransferRestriction(randomUser, secondUser, 0));\n    }\n\n    function testUpdateShareMetadata() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n\n        string memory updatedTokenName = \"newName\";\n        string memory updatedTokenSymbol = \"newSymbol\";\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.updateShareMetadata(\n            PoolId.wrap(100), ShareClassId.wrap(bytes16(bytes(\"100\"))), updatedTokenName, updatedTokenSymbol\n        );\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.updateShareMetadata(poolId, scId, updatedTokenName, updatedTokenSymbol);\n\n        assertEq(shareToken.name(), \"name\");\n        assertEq(shareToken.symbol(), \"symbol\");\n\n        poolManager.updateShareMetadata(poolId, scId, updatedTokenName, updatedTokenSymbol);\n        assertEq(shareToken.name(), updatedTokenName);\n        assertEq(shareToken.symbol(), updatedTokenSymbol);\n\n        vm.expectRevert(IPoolManager.OldMetadata.selector);\n        poolManager.updateShareMetadata(poolId, scId, updatedTokenName, updatedTokenSymbol);\n    }\n\n    function testUpdateShareHook() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n\n        address newHook = makeAddr(\"NewHook\");\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.updateShareHook(PoolId.wrap(100), ShareClassId.wrap(bytes16(bytes(\"100\"))), newHook);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.updateShareHook(poolId, scId, newHook);\n\n        assertEq(shareToken.hook(), fullRestrictionsHook);\n\n        poolManager.updateShareHook(poolId, scId, newHook);\n        assertEq(shareToken.hook(), newHook);\n\n        vm.expectRevert(IPoolManager.OldHook.selector);\n        poolManager.updateShareHook(poolId, scId, newHook);\n    }\n\n    function testUpdateRestriction() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n\n        bytes memory update = MessageLib.UpdateRestrictionFreeze(makeAddr(\"User\").toBytes32()).serialize();\n\n        vm.expectRevert(IPoolManager.UnknownToken.selector);\n        poolManager.updateRestriction(PoolId.wrap(100), ShareClassId.wrap(bytes16(bytes(\"100\"))), update);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.updateRestriction(poolId, scId, update);\n\n        address hook = shareToken.hook();\n        poolManager.updateShareHook(poolId, scId, address(0));\n\n        vm.expectRevert(IPoolManager.InvalidHook.selector);\n        poolManager.updateRestriction(poolId, scId, update);\n\n        poolManager.updateShareHook(poolId, scId, hook);\n\n        poolManager.updateRestriction(poolId, scId, update);\n    }\n\n    function testUpdatePricePoolPerShareWorks(\n        PoolId poolId,\n        uint8 decimals,\n        string memory tokenName,\n        string memory tokenSymbol,\n        ShareClassId scId,\n        uint128 price,\n        bytes32 salt\n    ) public {\n        decimals = uint8(bound(decimals, 2, 18));\n        vm.assume(poolId.raw() > 0);\n        vm.assume(scId.raw() > 0);\n        poolManager.addPool(poolId);\n        AssetId assetId = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(erc20), 0);\n\n        address hook = address(new MockHook());\n\n        vm.expectRevert(IPoolManager.ShareTokenDoesNotExist.selector);\n        poolManager.updatePricePoolPerShare(poolId, scId, price, uint64(block.timestamp));\n\n        poolManager.addShareClass(poolId, scId, tokenName, tokenSymbol, decimals, salt, hook);\n\n        poolManager.updatePricePoolPerAsset(poolId, scId, assetId, 1e18, uint64(block.timestamp));\n\n        vm.expectRevert(IPoolManager.InvalidPrice.selector);\n        poolManager.priceAssetPerShare(poolId, scId, assetId, true);\n\n        // Allows us to go back in time later\n        vm.warp(block.timestamp + 1 days);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.updatePricePoolPerShare(poolId, scId, price, uint64(block.timestamp));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vm.prank(randomUser);\n        poolManager.updatePricePoolPerAsset(poolId, scId, assetId, price, uint64(block.timestamp));\n\n        poolManager.updatePricePoolPerShare(poolId, scId, price, uint64(block.timestamp));\n        D18 latestPrice = poolManager.priceAssetPerShare(poolId, scId, assetId, false);\n        assertEq(latestPrice.raw(), price);\n\n        vm.expectRevert(IPoolManager.CannotSetOlderPrice.selector);\n        poolManager.updatePricePoolPerShare(poolId, scId, price, uint64(block.timestamp - 1));\n\n        // NOTE: We have no maxAge set, so price is invalid after timestamp of block increases\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(IPoolManager.InvalidPrice.selector);\n        poolManager.priceAssetPerShare(poolId, scId, assetId, true);\n\n        // NOTE: Unchecked version will work\n        latestPrice = poolManager.priceAssetPerShare(poolId, scId, assetId, false);\n        assertEq(latestPrice.raw(), price);\n    }\n\n    function testVaultMigration() public {\n        (, address oldVault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n\n        AsyncVault oldVault = AsyncVault(oldVault_);\n        PoolId poolId = oldVault.poolId();\n        ShareClassId scId = oldVault.scId();\n        address asset = address(oldVault.asset());\n\n        AsyncVaultFactory newVaultFactory = new AsyncVaultFactory(address(root), asyncRequestManager, address(this));\n\n        // rewire factory contracts\n        newVaultFactory.rely(address(poolManager));\n        asyncRequestManager.rely(address(newVaultFactory));\n        poolManager.file(\"vaultFactory\", address(newVaultFactory), true);\n\n        // Remove old vault\n        address vaultManager = address(oldVault.manager());\n        IBaseRequestManager(vaultManager).removeVault(poolId, scId, oldVault, asset, AssetId.wrap(assetId));\n        assertEq(poolManager.shareToken(poolId, scId).vault(asset), address(0));\n\n        // Deploy new vault\n        IBaseVault newVault = poolManager.deployVault(poolId, scId, AssetId.wrap(assetId), newVaultFactory);\n        assert(oldVault_ != address(newVault));\n    }\n\n    function testPoolManagerCannotTransferSharesOnAccountRestrictions(uint128 amount) public {\n        uint64 validUntil = uint64(block.timestamp + 7 days);\n        address destinationAddress = makeAddr(\"destinationAddress\");\n        vm.assume(amount > 0);\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(AsyncVault(vault_).share()));\n        shareToken.approve(address(poolManager), amount);\n\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(destinationAddress.toBytes32(), validUntil).serialize()\n        );\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(address(this).toBytes32(), validUntil).serialize()\n        );\n\n        assertTrue(shareToken.checkTransferRestriction(address(0), address(this), 0));\n        assertTrue(shareToken.checkTransferRestriction(address(0), destinationAddress, 0));\n\n        // Fund this address with amount\n        poolManager.handleTransferShares(vault.poolId(), vault.scId(), address(this), amount);\n        assertEq(shareToken.balanceOf(address(this)), amount);\n\n        // fails for invalid share class token\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionFreeze(address(this).toBytes32()).serialize()\n        );\n        assertFalse(shareToken.checkTransferRestriction(address(this), destinationAddress, 0));\n\n        vm.expectRevert(IPoolManager.CrossChainTransferNotAllowed.selector);\n        poolManager.transferShares{value: defaultGas}(\n            OTHER_CHAIN_ID, poolId, scId, destinationAddress.toBytes32(), amount\n        );\n\n        poolManager.updateRestriction(\n            vault.poolId(),\n            vault.scId(),\n            MessageLib.UpdateRestrictionMember(address(uint160(OTHER_CHAIN_ID)).toBytes32(), type(uint64).max).serialize(\n            )\n        );\n\n        vm.expectRevert(IPoolManager.CrossChainTransferNotAllowed.selector);\n        poolManager.transferShares{value: defaultGas}(\n            OTHER_CHAIN_ID, poolId, scId, destinationAddress.toBytes32(), amount\n        );\n        assertEq(shareToken.balanceOf(address(this)), amount);\n\n        poolManager.updateRestriction(\n            poolId, scId, MessageLib.UpdateRestrictionUnfreeze(address(this).toBytes32()).serialize()\n        );\n        poolManager.transferShares{value: defaultGas}(\n            OTHER_CHAIN_ID, poolId, scId, destinationAddress.toBytes32(), amount\n        );\n        assertEq(shareToken.balanceOf(address(poolEscrowFactory.escrow(poolId))), 0);\n    }\n\n    function testLinkVaultInvalidShare(PoolId poolId, ShareClassId scId) public {\n        vm.expectRevert(IPoolManager.ShareTokenDoesNotExist.selector);\n        poolManager.linkVault(poolId, scId, AssetId.wrap(defaultAssetId), IBaseVault(address(0)));\n    }\n\n    function testUnlinkVaultInvalidShare(PoolId poolId, ShareClassId scId) public {\n        vm.expectRevert(IPoolManager.ShareTokenDoesNotExist.selector);\n        poolManager.unlinkVault(poolId, scId, AssetId.wrap(defaultAssetId), IBaseVault(address(0)));\n    }\n\n    function testLinkVaultUnauthorized(PoolId poolId, ShareClassId scId) public {\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.linkVault(poolId, scId, AssetId.wrap(defaultAssetId), IBaseVault(address(0)));\n    }\n\n    function testUnlinkVaultUnauthorized(PoolId poolId, ShareClassId scId) public {\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.unlinkVault(poolId, scId, AssetId.wrap(defaultAssetId), IBaseVault(address(0)));\n    }\n}\n\ncontract PoolManagerDeployVaultTest is BaseTest, PoolManagerTestHelper {\n    using MessageLib for *;\n    using CastLib for *;\n    using BytesLib for *;\n\n    function _assertVaultSetup(address vaultAddress, AssetId assetId, address asset, uint256 tokenId, bool isLinked)\n        private\n        view\n    {\n        address vaultManager = address(IBaseVault(vaultAddress).manager());\n        IShareToken token_ = poolManager.shareToken(poolId, scId);\n        address vault_ = IShareToken(token_).vault(asset);\n\n        assert(poolManager.isPoolActive(poolId));\n\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(IBaseVault(vaultAddress));\n        assertEq(assetId.raw(), vaultDetails.assetId.raw(), \"vault assetId mismatch\");\n        assertEq(asset, vaultDetails.asset, \"vault asset mismatch\");\n        assertEq(tokenId, vaultDetails.tokenId, \"vault asset mismatch\");\n        assertEq(false, vaultDetails.isWrapper, \"vault isWrapper mismatch\");\n        assertEq(isLinked, vaultDetails.isLinked, \"vault isLinked mismatch\");\n\n        if (isLinked) {\n            assert(poolManager.isLinked(poolId, scId, asset, IBaseVault(vaultAddress)));\n\n            // check vault state\n            assertEq(vaultAddress, vault_, \"vault address mismatch\");\n            AsyncVault vault = AsyncVault(vault_);\n            assertEq(address(vault.manager()), address(asyncRequestManager), \"investment manager mismatch\");\n            assertEq(vault.asset(), asset, \"asset mismatch\");\n            assertEq(vault.poolId().raw(), poolId.raw(), \"poolId mismatch\");\n            assertEq(vault.scId().raw(), scId.raw(), \"scId mismatch\");\n            assertEq(address(vault.share()), address(token_), \"share class token mismatch\");\n\n            assertEq(vault.wards(address(asyncRequestManager)), 1);\n            assertEq(vault.wards(address(this)), 0);\n            assertEq(asyncRequestManager.wards(vaultAddress), 1);\n        } else {\n            assert(!poolManager.isLinked(poolId, scId, asset, IBaseVault(vaultAddress)));\n            // Check Share permissions\n            assertEq(ShareToken(address(token_)).wards(vaultManager), 1);\n\n            // Check missing link\n            assertEq(vault_, address(0), \"Share link to vault requires linkVault\");\n            assertEq(\n                asyncRequestManager.wards(vaultAddress), 0, \"Vault auth on asyncRequestManager set up in linkVault\"\n            );\n        }\n    }\n\n    function _assertShareSetup(address vaultAddress, bool isLinked) private view {\n        IShareToken token_ = poolManager.shareToken(poolId, scId);\n        ShareToken shareToken = ShareToken(address(token_));\n\n        assertEq(shareToken.wards(address(poolManager)), 1);\n        assertEq(shareToken.wards(address(this)), 0);\n\n        assertEq(shareToken.name(), tokenName, \"share class token name mismatch\");\n        assertEq(shareToken.symbol(), tokenSymbol, \"share class token symbol mismatch\");\n        assertEq(shareToken.decimals(), decimals, \"share class token decimals mismatch\");\n\n        if (isLinked) {\n            assertEq(shareToken.wards(vaultAddress), 1);\n        } else {\n            assertEq(shareToken.wards(vaultAddress), 0, \"Vault auth on Share set up in linkVault\");\n        }\n    }\n\n    function _assertDeployedVault(address vaultAddress, AssetId assetId, address asset, uint256 tokenId, bool isLinked)\n        internal\n        view\n    {\n        _assertVaultSetup(vaultAddress, assetId, asset, tokenId, isLinked);\n        _assertShareSetup(vaultAddress, isLinked);\n    }\n\n    function testDeployVaultWithoutLinkERC20(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n\n        address asset = address(erc20);\n\n        // Check event except for vault address which cannot be known\n        AssetId assetId = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, asset, erc20TokenId);\n        vm.expectEmit(true, true, true, false);\n        emit IPoolManager.DeployVault(\n            poolId, scId, asset, erc20TokenId, asyncVaultFactory, IBaseVault(address(0)), VaultKind.Async\n        );\n        IBaseVault vault = poolManager.deployVault(poolId, scId, assetId, asyncVaultFactory);\n\n        _assertDeployedVault(address(vault), assetId, asset, erc20TokenId, false);\n    }\n\n    function testDeployVaultWithLinkERC20(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n\n        address asset = address(erc20);\n\n        AssetId assetId = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, asset, erc20TokenId);\n        IBaseVault vault = poolManager.deployVault(poolId, scId, assetId, asyncVaultFactory);\n\n        vm.expectEmit(true, true, true, false);\n        emit IPoolManager.LinkVault(poolId, scId, asset, erc20TokenId, vault);\n        poolManager.linkVault(poolId, scId, assetId, vault);\n\n        _assertDeployedVault(address(vault), assetId, asset, erc20TokenId, true);\n    }\n\n    function testDeploVaultInvalidShare(PoolId poolId, ShareClassId scId) public {\n        vm.expectRevert(IPoolManager.ShareTokenDoesNotExist.selector);\n        poolManager.deployVault(poolId, scId, AssetId.wrap(defaultAssetId), asyncVaultFactory);\n    }\n\n    function testDeploVaultInvalidVaultFactory(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n\n        vm.expectRevert(IPoolManager.InvalidFactory.selector);\n        poolManager.deployVault(poolId, scId, AssetId.wrap(defaultAssetId), IVaultFactory(address(0)));\n    }\n\n    function testDeployVaultUnauthorized() public {\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.deployVault(PoolId.wrap(0), ShareClassId.wrap(0), AssetId.wrap(0), IVaultFactory(address(0)));\n    }\n}\n\ncontract PoolManagerRegisterAssetTest is BaseTest {\n    using MessageLib for *;\n    using CastLib for *;\n    using BytesLib for *;\n\n    uint32 constant STORAGE_INDEX_ASSET_COUNTER = 7;\n    uint256 constant STORAGE_OFFSET_ASSET_COUNTER = 20;\n\n    function _assertAssetCounterEq(uint32 expected) internal view {\n        bytes32 slotData = vm.load(address(poolManager), bytes32(uint256(STORAGE_INDEX_ASSET_COUNTER)));\n\n        // Extract `_assetCounter` at offset 20 bytes (rightmost 4 bytes)\n        uint32 assetCounter = uint32(uint256(slotData >> (STORAGE_OFFSET_ASSET_COUNTER * 8)));\n        assertEq(assetCounter, expected, \"Asset counter does not match expected value\");\n    }\n\n    function _assertAssetRegistered(address asset, AssetId assetId, uint256 tokenId, uint32 expectedAssetCounter)\n        internal\n        view\n    {\n        assertEq(poolManager.assetToId(asset, tokenId).raw(), assetId.raw(), \"Asset to id mismatch\");\n        (address asset_, uint256 tokenId_) = poolManager.idToAsset(assetId);\n        assertEq(asset_, asset);\n        assertEq(tokenId_, tokenId);\n        _assertAssetCounterEq(expectedAssetCounter);\n    }\n\n    function testRegisterSingleAssetERC20() public {\n        address asset = address(erc20);\n        bytes memory message =\n            MessageLib.RegisterAsset({assetId: defaultAssetId, decimals: erc20.decimals()}).serialize();\n\n        vm.expectEmit();\n        emit IPoolManager.RegisterAsset(\n            AssetId.wrap(defaultAssetId), asset, 0, erc20.name(), erc20.symbol(), erc20.decimals()\n        );\n        vm.expectEmit(false, false, false, false);\n        emit IGateway.PrepareMessage(OTHER_CHAIN_ID, PoolId.wrap(0), message);\n        AssetId assetId = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, asset, 0);\n\n        assertEq(assetId.raw(), defaultAssetId);\n\n        // Allowance is set during vault deployment\n        assertEq(erc20.allowance(address(poolEscrowFactory.escrow(POOL_A)), address(poolManager)), 0);\n        _assertAssetRegistered(asset, assetId, 0, 1);\n    }\n\n    function testRegisterMultipleAssetsERC20(string calldata name, string calldata symbol, uint8 decimals) public {\n        decimals = uint8(bound(decimals, 2, 18));\n\n        ERC20 assetA = erc20;\n        ERC20 assetB = _newErc20(name, symbol, decimals);\n\n        AssetId assetIdA = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(assetA), 0);\n        _assertAssetRegistered(address(assetA), assetIdA, 0, 1);\n\n        AssetId assetIdB = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(assetB), 0);\n        _assertAssetRegistered(address(assetB), assetIdB, 0, 2);\n\n        assert(assetIdA.raw() != assetIdB.raw());\n    }\n\n    function testRegisterSingleAssetERC20_emptyNameSymbol() public {\n        ERC20 asset = _newErc20(\"\", \"\", 10);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(asset), 0);\n        _assertAssetRegistered(address(asset), AssetId.wrap(defaultAssetId), 0, 1);\n    }\n\n    function testRegisterSingleAssetERC6909(uint8 decimals) public {\n        uint256 tokenId = uint256(bound(decimals, 2, 18));\n        MockERC6909 erc6909 = new MockERC6909();\n        address asset = address(erc6909);\n\n        bytes memory message =\n            MessageLib.RegisterAsset({assetId: defaultAssetId, decimals: erc6909.decimals(tokenId)}).serialize();\n\n        vm.expectEmit();\n        emit IPoolManager.RegisterAsset(\n            AssetId.wrap(defaultAssetId),\n            asset,\n            tokenId,\n            erc6909.name(tokenId),\n            erc6909.symbol(tokenId),\n            erc6909.decimals(tokenId)\n        );\n        vm.expectEmit(false, false, false, false);\n        emit IGateway.PrepareMessage(OTHER_CHAIN_ID, PoolId.wrap(0), message);\n        AssetId assetId = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, asset, tokenId);\n\n        assertEq(assetId.raw(), defaultAssetId);\n\n        // Allowance is set during vault deployment\n        assertEq(erc6909.allowance(address(poolEscrowFactory.escrow(POOL_A)), address(poolManager), tokenId), 0);\n        _assertAssetRegistered(asset, assetId, tokenId, 1);\n    }\n\n    function testRegisterMultipleAssetsERC6909(uint8 decimals) public {\n        MockERC6909 erc6909 = new MockERC6909();\n        uint256 tokenIdA = uint256(bound(decimals, 3, 18));\n        uint256 tokenIdB = uint256(bound(decimals, 2, tokenIdA - 1));\n\n        AssetId assetIdA = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(erc6909), tokenIdA);\n        _assertAssetRegistered(address(erc6909), assetIdA, tokenIdA, 1);\n\n        AssetId assetIdB = poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(erc6909), tokenIdB);\n        _assertAssetRegistered(address(erc6909), assetIdB, tokenIdB, 2);\n\n        assert(assetIdA.raw() != assetIdB.raw());\n    }\n\n    function testRegisterAssetTwice() public {\n        vm.expectEmit();\n        emit IPoolManager.RegisterAsset(\n            AssetId.wrap(defaultAssetId), address(erc20), 0, erc20.name(), erc20.symbol(), erc20.decimals()\n        );\n        vm.expectEmit(false, false, false, false);\n        emit IGateway.PrepareMessage(OTHER_CHAIN_ID, PoolId.wrap(0), bytes(\"\"));\n        emit IGateway.PrepareMessage(OTHER_CHAIN_ID, PoolId.wrap(0), bytes(\"\"));\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(erc20), 0);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(erc20), 0);\n    }\n\n    function testRegisterAsset_decimalsMissing() public {\n        address asset = address(new MockERC6909());\n        vm.expectRevert(IPoolManager.AssetMissingDecimals.selector);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, asset, 0);\n    }\n\n    function testRegisterAsset_invalidContract(uint256 tokenId) public {\n        vm.expectRevert(IPoolManager.AssetMissingDecimals.selector);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(0), tokenId);\n    }\n\n    function testRegisterAssetERC20_decimalDeficit() public {\n        ERC20 asset = _newErc20(\"\", \"\", 1);\n        vm.expectRevert(IPoolManager.TooFewDecimals.selector);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(asset), 0);\n    }\n\n    function testRegisterAssetERC20_decimalExcess() public {\n        ERC20 asset = _newErc20(\"\", \"\", 19);\n        vm.expectRevert(IPoolManager.TooManyDecimals.selector);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(asset), 0);\n    }\n\n    function testRegisterAssetERC6909_decimalDeficit() public {\n        MockERC6909 asset = new MockERC6909();\n        vm.expectRevert(IPoolManager.TooFewDecimals.selector);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(asset), 1);\n    }\n\n    function testRegisterAssetERC6909_decimalExcess() public {\n        MockERC6909 asset = new MockERC6909();\n        vm.expectRevert(IPoolManager.TooManyDecimals.selector);\n        poolManager.registerAsset{value: defaultGas}(OTHER_CHAIN_ID, address(asset), 19);\n    }\n}\n\ncontract UpdateContractMock is IUpdateContract {\n    IUpdateContract immutable poolManager;\n\n    constructor(address poolManager_) {\n        poolManager = IUpdateContract(poolManager_);\n    }\n\n    function update(PoolId poolId, ShareClassId scId, bytes calldata payload) public {\n        poolManager.update(poolId, scId, payload);\n    }\n}\n\ncontract PoolManagerUpdateContract is BaseTest, PoolManagerTestHelper {\n    using MessageLib for *;\n\n    function testUpdateContractTargetThis(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n        registerAssetErc20();\n        bytes memory vaultUpdate = _serializedUpdateContractNewVault(asyncVaultFactory);\n\n        vm.expectEmit();\n        emit IPoolManager.UpdateContract(poolId, scId, address(poolManager), vaultUpdate);\n        poolManager.updateContract(poolId, scId, address(poolManager), vaultUpdate);\n    }\n\n    function testUpdateContractTargetUpdateContractMock(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n        registerAssetErc20();\n        bytes memory vaultUpdate = _serializedUpdateContractNewVault(asyncVaultFactory);\n        UpdateContractMock mock = new UpdateContractMock(address(poolManager));\n        IAuth(address(poolManager)).rely(address(mock));\n\n        vm.expectEmit();\n        emit IPoolManager.UpdateContract(poolId, scId, address(mock), vaultUpdate);\n        poolManager.updateContract(poolId, scId, address(mock), vaultUpdate);\n    }\n\n    function testUpdateContractInvalidVaultFactory(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n        registerAssetErc20();\n        bytes memory vaultUpdate = _serializedUpdateContractNewVault(IVaultFactory(address(1)));\n\n        vm.expectRevert(IPoolManager.InvalidFactory.selector);\n        poolManager.updateContract(poolId, scId, address(poolManager), vaultUpdate);\n    }\n\n    function testUpdateContractUnknownVault(\n        PoolId poolId_,\n        uint8 decimals_,\n        string memory tokenName_,\n        string memory tokenSymbol_,\n        ShareClassId scId_\n    ) public {\n        setUpPoolAndShare(poolId_, decimals_, tokenName_, tokenSymbol_, scId_);\n        registerAssetErc20();\n        bytes memory vaultUpdate = MessageLib.UpdateContractVaultUpdate({\n            vaultOrFactory: bytes32(\"1\"),\n            assetId: assetIdErc20.raw(),\n            kind: uint8(VaultUpdateKind.Link)\n        }).serialize();\n\n        vm.expectRevert(IPoolManager.UnknownVault.selector);\n        poolManager.updateContract(poolId, scId, address(poolManager), vaultUpdate);\n    }\n\n    function testUpdateContractInvalidShare(PoolId poolId) public {\n        poolManager.addPool(poolId);\n        bytes memory vaultUpdate = _serializedUpdateContractNewVault(asyncVaultFactory);\n\n        vm.expectRevert(IPoolManager.ShareTokenDoesNotExist.selector);\n        poolManager.updateContract(poolId, scId, address(poolManager), vaultUpdate);\n    }\n\n    function testUpdateContractUnauthorized() public {\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.updateContract(PoolId.wrap(0), ShareClassId.wrap(bytes16(0)), address(0), bytes(\"\"));\n    }\n\n    function testUpdateUnauthorized() public {\n        vm.prank(makeAddr(\"unauthorized\"));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        poolManager.update(PoolId.wrap(0), ShareClassId.wrap(0), bytes(\"\"));\n    }\n\n    function _serializedUpdateContractNewVault(IVaultFactory vaultFactory_)\n        internal\n        view\n        returns (bytes memory payload)\n    {\n        return MessageLib.UpdateContractVaultUpdate({\n            vaultOrFactory: bytes32(bytes20(address(vaultFactory_))),\n            assetId: assetIdErc20.raw(),\n            kind: uint8(VaultUpdateKind.DeployAndLink)\n        }).serialize();\n    }\n}\n"
    },
    "test/vaults/integration/Redeem.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ncontract RedeemTest is BaseTest {\n    using MessageLib for *;\n    using CastLib for *;\n\n    function testRedeem(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128 / 2));\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        deposit(vault_, self, amount); // deposit funds first\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), defaultPrice, uint64(block.timestamp)\n        );\n\n        // will fail - zero deposit not allowed\n        vm.expectRevert(IAsyncRequestManager.ZeroAmountNotAllowed.selector);\n        vault.requestRedeem(0, self, self);\n\n        // will fail - investment asset not allowed\n        centrifugeChain.unlinkVault(vault.poolId().raw(), vault.scId().raw(), vault_);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vault.requestRedeem(amount, address(this), address(this));\n\n        // will fail - cannot fulfill if there is no pending redeem request\n        uint128 assets = uint128((amount * 10 ** 18) / defaultPrice);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        vm.expectRevert(IAsyncRequestManager.NoPendingRequest.selector);\n        asyncRequestManager.fulfillRedeemRequest(poolId, scId, self, AssetId.wrap(assetId), assets, uint128(amount));\n\n        // success\n        centrifugeChain.linkVault(vault.poolId().raw(), vault.scId().raw(), vault_);\n        vault.requestRedeem(amount, address(this), address(this));\n        assertEq(shareToken.balanceOf(address(globalEscrow)), amount);\n        assertEq(vault.pendingRedeemRequest(0, self), amount);\n        assertEq(vault.claimableRedeemRequest(0, self), 0);\n\n        // fail: no tokens left\n        vm.expectRevert(IBaseVault.InsufficientBalance.selector);\n        vault.requestRedeem(amount, address(this), address(this));\n\n        // trigger executed collectRedeem\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, uint128(amount)\n        );\n\n        // assert withdraw & redeem values adjusted\n        assertEq(vault.maxWithdraw(self), assets); // max deposit\n        assertEq(vault.maxRedeem(self), amount); // max deposit\n        assertEq(vault.pendingRedeemRequest(0, self), 0);\n        assertEq(vault.claimableRedeemRequest(0, self), amount);\n        assertEq(shareToken.balanceOf(address(globalEscrow)), 0);\n        assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), assets);\n\n        // can redeem to self\n        vault.redeem(amount / 2, self, self); // redeem half the amount to own wallet\n\n        // can also redeem to another user on the memberlist\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        vault.redeem(amount / 2, investor, self); // redeem half the amount to investor wallet\n\n        assertEq(shareToken.balanceOf(self), 0);\n\n        assertTrue(shareToken.balanceOf(address(globalEscrow)) <= 1);\n        assertTrue(erc20.balanceOf(address(globalEscrow)) <= 1);\n\n        assertApproxEqAbs(erc20.balanceOf(self), (amount / 2), 1);\n        assertApproxEqAbs(erc20.balanceOf(investor), (amount / 2), 1);\n        assertTrue(vault.maxWithdraw(self) <= 1);\n        assertTrue(vault.maxRedeem(self) <= 1);\n\n        // withdrawing or redeeming more should revert\n        vm.expectRevert(IAsyncRequestManager.ExceedsRedeemLimits.selector);\n        vault.withdraw(2, investor, self);\n        vm.expectRevert(IAsyncRequestManager.ExceedsMaxRedeem.selector);\n        vault.redeem(2, investor, self);\n    }\n\n    function testWithdraw(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128 / 2));\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        deposit(vault_, self, amount); // deposit funds first\n        centrifugeChain.updatePricePoolPerShare(\n            vault.poolId().raw(), vault.scId().raw(), defaultPrice, uint64(block.timestamp)\n        );\n\n        vault.requestRedeem(amount, address(this), address(this));\n        assertEq(shareToken.balanceOf(address(globalEscrow)), amount);\n        assertGt(vault.pendingRedeemRequest(0, self), 0);\n\n        // trigger executed collectRedeem\n        uint128 assets = uint128((amount * 10 ** 18) / defaultPrice);\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, assets, uint128(amount)\n        );\n\n        // assert withdraw & redeem values adjusted\n        assertEq(vault.maxWithdraw(self), assets); // max deposit\n        assertEq(vault.maxRedeem(self), amount); // max deposit\n        assertEq(shareToken.balanceOf(address(globalEscrow)), 0);\n        assertEq(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), assets);\n\n        // can redeem to self\n        vault.withdraw(amount / 2, self, self); // redeem half the amount to own wallet\n\n        // can also withdraw to another user on the memberlist\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        vault.withdraw(amount / 2, investor, self); // redeem half the amount to investor wallet\n\n        assertTrue(shareToken.balanceOf(self) <= 1);\n        assertTrue(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))) <= 1);\n        assertApproxEqAbs(erc20.balanceOf(self), assets / 2, 1);\n        assertApproxEqAbs(erc20.balanceOf(investor), assets / 2, 1);\n        assertTrue(vault.maxRedeem(self) <= 1);\n        assertTrue(vault.maxWithdraw(self) <= 1);\n    }\n\n    function testRequestRedeemWithApproval(uint256 redemption1, uint256 redemption2) public {\n        vm.assume(investor != address(this));\n\n        redemption1 = uint128(bound(redemption1, 2, MAX_UINT128 / 4));\n        redemption2 = uint128(bound(redemption2, 2, MAX_UINT128 / 4));\n        uint256 amount = redemption1 + redemption2;\n        vm.assume(amountAssumption(amount));\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        deposit(vault_, investor, amount); // deposit funds first // deposit funds first\n\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        vault.requestRedeem(amount, investor, investor);\n\n        assertEq(shareToken.allowance(investor, address(this)), 0);\n        vm.prank(investor);\n        shareToken.approve(address(this), amount);\n        assertEq(shareToken.allowance(investor, address(this)), amount);\n\n        // investor can requestRedeem\n        vault.requestRedeem(amount, investor, investor);\n        assertEq(shareToken.allowance(investor, address(this)), 0);\n    }\n\n    function testCancelRedeemOrder(uint256 amount) public {\n        amount = uint128(bound(amount, 2, MAX_UINT128 / 2));\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        deposit(vault_, self, amount * 2); // deposit funds first\n\n        vm.expectRevert(IAsyncRequestManager.NoPendingRequest.selector);\n        vault.cancelRedeemRequest(0, self);\n\n        vault.requestRedeem(amount, address(this), address(this));\n\n        // will fail - user not member\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, uint64(block.timestamp));\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vault.cancelRedeemRequest(0, self);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n\n        assertEq(shareToken.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0);\n        assertEq(shareToken.balanceOf(address(globalEscrow)), amount);\n        assertEq(shareToken.balanceOf(self), amount);\n\n        // check message was send out to centchain\n        vault.cancelRedeemRequest(0, self);\n\n        MessageLib.CancelRedeemRequest memory m = adapter1.values_bytes(\"send\").deserializeCancelRedeemRequest();\n        assertEq(m.poolId, vault.poolId().raw());\n        assertEq(m.scId, vault.scId().raw());\n        assertEq(m.investor, bytes32(bytes20(self)));\n        assertEq(m.assetId, assetId);\n\n        assertEq(vault.pendingCancelRedeemRequest(0, self), true);\n\n        // Cannot cancel twice\n        vm.expectRevert(IAsyncRequestManager.CancellationIsPending.selector);\n        vault.cancelRedeemRequest(0, self);\n\n        vm.expectRevert(IAsyncRequestManager.CancellationIsPending.selector);\n        vault.requestRedeem(amount, address(this), address(this));\n\n        centrifugeChain.isFulfilledCancelRedeemRequest(\n            vault.poolId().raw(), vault.scId().raw(), self.toBytes32(), assetId, uint128(amount)\n        );\n\n        assertEq(shareToken.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0);\n        assertEq(shareToken.balanceOf(address(globalEscrow)), amount);\n        assertEq(shareToken.balanceOf(self), amount);\n        assertEq(vault.claimableCancelRedeemRequest(0, self), amount);\n        assertEq(vault.pendingCancelRedeemRequest(0, self), false);\n\n        // After cancellation is executed, new request can be submitted\n        vault.requestRedeem(amount, address(this), address(this));\n    }\n\n    function testPartialRedemptionExecutions() public {\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        ERC20 asset = ERC20(address(vault.asset()));\n        centrifugeChain.updatePricePoolPerShare(poolId.raw(), scId.raw(), 1000000000000000000, uint64(block.timestamp));\n\n        // invest\n        uint256 investmentAmount = 100000000; // 100 * 10**6\n        centrifugeChain.updateMember(poolId.raw(), scId.raw(), self, type(uint64).max);\n        asset.approve(address(asyncRequestManager), investmentAmount);\n        asset.mint(self, investmentAmount);\n        erc20.approve(address(vault), investmentAmount);\n        vault.requestDeposit(investmentAmount, self, self);\n\n        uint128 shares = 100000000;\n        centrifugeChain.isFulfilledDepositRequest(\n            poolId.raw(), scId.raw(), bytes32(bytes20(self)), assetId, uint128(investmentAmount), shares\n        );\n\n        (,, uint256 depositPrice,,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(depositPrice, 1000000000000000000);\n\n        // assert deposit & mint values adjusted\n        assertApproxEqAbs(vault.maxDeposit(self), investmentAmount, 2);\n        assertEq(vault.maxMint(self), shares);\n\n        // collect the share class tokens\n        vault.mint(shares, self);\n        assertEq(shareToken.balanceOf(self), shares);\n\n        // redeem\n        vault.requestRedeem(shares, self, self);\n\n        // trigger first executed collectRedeem at a price of 1.5\n        // user is able to redeem 50 share class tokens, at 1.5 price, 75 asset is paid out\n        uint128 assets = 75000000; // 150*10**6\n\n        // mint approximate interest amount into escrow\n        asset.mint(address(poolEscrowFactory.escrow(vault.poolId())), assets * 2 - investmentAmount);\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            poolId.raw(), scId.raw(), bytes32(bytes20(self)), assetId, assets, shares / 2\n        );\n\n        (,,, uint256 redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1500000000000000000);\n\n        // trigger second executed collectRedeem at a price of 1.0\n        // user has 50 share class tokens left, at 1.0 price, 50 asset is paid out\n        assets = 50000000; // 50*10**6\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            poolId.raw(), scId.raw(), bytes32(bytes20(self)), assetId, assets, shares / 2\n        );\n\n        (,,, redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1250000000000000000);\n    }\n\n    function partialRedeem(ShareClassId scId, AsyncVault vault, ERC20 asset) public {\n        IShareToken shareToken = IShareToken(address(vault.share()));\n\n        AssetId assetId = poolManager.assetToId(address(asset), erc20TokenId);\n        uint256 totalShares = shareToken.balanceOf(self);\n        uint256 redeemAmount = 50000000000000000000;\n        assertTrue(redeemAmount <= totalShares);\n        vault.requestRedeem(redeemAmount, self, self);\n\n        // first trigger executed collectRedeem of the first 25 share class tokens at a price of 1.1\n        uint128 firstShareRedeem = 25000000000000000000;\n        uint128 secondShareRedeem = 25000000000000000000;\n        assertEq(firstShareRedeem + secondShareRedeem, redeemAmount);\n        uint128 firstCurrencyPayout = 27500000; // (25000000000000000000/10**18) * 10**6 * 1.1\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(),\n            scId.raw(),\n            bytes32(bytes20(self)),\n            assetId.raw(),\n            firstCurrencyPayout,\n            firstShareRedeem\n        );\n\n        assertEq(vault.maxRedeem(self), firstShareRedeem);\n\n        (,,, uint256 redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1100000000000000000);\n\n        // second trigger executed collectRedeem of the second 25 share class tokens at a price of 1.3\n        uint128 secondCurrencyPayout = 32500000; // (25000000000000000000/10**18) * 10**6 * 1.3\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(),\n            scId.raw(),\n            bytes32(bytes20(self)),\n            assetId.raw(),\n            secondCurrencyPayout,\n            secondShareRedeem\n        );\n\n        (,,, redeemPrice,,,,,,) = asyncRequestManager.investments(vault, self);\n        assertEq(redeemPrice, 1200000000000000000);\n\n        assertApproxEqAbs(vault.maxWithdraw(self), firstCurrencyPayout + secondCurrencyPayout, 2);\n        assertEq(vault.maxRedeem(self), redeemAmount);\n\n        // collect the asset\n        vault.redeem(redeemAmount, self, self);\n        assertEq(shareToken.balanceOf(self), totalShares - redeemAmount);\n        assertEq(asset.balanceOf(self), firstCurrencyPayout + secondCurrencyPayout);\n    }\n}\n"
    },
    "test/vaults/integration/SyncDeposit.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {AssetId} from \"src/common/types/AssetId.sol\";\n\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\nimport {IBalanceSheet} from \"src/vaults/interfaces/IBalanceSheet.sol\";\nimport {SyncDepositVault} from \"src/vaults/SyncDepositVault.sol\";\nimport {VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {ISyncRequestManager} from \"src/vaults/interfaces/investments/ISyncRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\n\ncontract SyncDepositTestHelper is BaseTest {\n    using CastLib for *;\n    using MessageLib for *;\n    using MathLib for *;\n\n    function _deploySyncDepositVault(D18 pricePoolPerShare, D18 pricePoolPerAsset)\n        internal\n        returns (SyncDepositVault syncVault, uint128 assetId)\n    {\n        (, address syncVault_, uint128 assetId_) = deploySimpleVault(VaultKind.SyncDepositAsyncRedeem);\n        assetId = assetId_;\n        syncVault = SyncDepositVault(syncVault_);\n\n        centrifugeChain.updatePricePoolPerShare(\n            syncVault.poolId().raw(), syncVault.scId().raw(), pricePoolPerShare.inner(), uint64(block.timestamp)\n        );\n        centrifugeChain.updatePricePoolPerAsset(\n            syncVault.poolId().raw(),\n            syncVault.scId().raw(),\n            assetId,\n            pricePoolPerAsset.inner(),\n            uint64(block.timestamp)\n        );\n    }\n\n    function _assertDepositEvents(SyncDepositVault vault, uint128 shares, D18 pricePoolPerShare, D18 pricePoolPerAsset)\n        internal\n    {\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        uint128 depositAssetAmount = vault.previewMint(shares).toUint128();\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Issue(poolId, scId, self, pricePoolPerShare, shares);\n\n        vm.expectEmit();\n        emit IBalanceSheet.Deposit(\n            poolId, scId, vault.asset(), vaultDetails.tokenId, self, depositAssetAmount, pricePoolPerAsset\n        );\n    }\n}\n\ncontract SyncDepositTest is SyncDepositTestHelper {\n    using CastLib for *;\n    using MessageLib for *;\n    using MathLib for *;\n\n    uint128 assetsPerShare = 2;\n    D18 priceAssetPerShare = d18(assetsPerShare, 1);\n    D18 pricePoolPerShare = d18(4, 1);\n    D18 pricePoolPerAsset = pricePoolPerShare / priceAssetPerShare;\n\n    function testFile(bytes32 fileTarget, address nonWard) public {\n        vm.assume(fileTarget != \"manager\" && fileTarget != \"asyncRedeemManager\" && fileTarget != \"syncDepositManager\");\n        vm.assume(\n            nonWard != address(root) && nonWard != address(this) && nonWard != address(syncRequestManager)\n                && nonWard != address(asyncRequestManager)\n        );\n        address random = makeAddr(\"random\");\n        (SyncDepositVault vault,) = _deploySyncDepositVault(d18(0), d18(0));\n\n        vm.startPrank(address(root));\n\n        vm.expectEmit();\n        emit IBaseVault.File(\"manager\", random);\n        vault.file(\"manager\", random);\n        assertEq(address(vault.manager()), random);\n\n        vm.expectEmit();\n        emit IBaseVault.File(\"syncDepositManager\", random);\n        vault.file(\"syncDepositManager\", random);\n        assertEq(address(vault.syncDepositManager()), random);\n\n        vm.expectEmit();\n        emit IBaseVault.File(\"asyncRedeemManager\", random);\n        vault.file(\"asyncRedeemManager\", random);\n        assertEq(address(vault.asyncRedeemManager()), random);\n\n        vm.expectRevert(IBaseVault.FileUnrecognizedParam.selector);\n        vault.file(fileTarget, random);\n\n        vm.stopPrank();\n        vm.prank(random);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vault.file(\"manager\", random);\n    }\n\n    function testSyncDepositERC20(uint256 amount) public {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128 / assetsPerShare));\n        vm.assume(amount % 2 == 0);\n\n        // Fund such that we can deposit\n        erc20.mint(self, amount);\n\n        // Deploy sync vault\n        (SyncDepositVault syncVault, uint128 assetId) = _deploySyncDepositVault(pricePoolPerShare, pricePoolPerAsset);\n        IShareToken shareToken = IShareToken(address(syncVault.share()));\n\n        // Retrieve async vault\n        IBaseVault asyncVault_ =\n            syncVault.asyncRedeemManager().vaultByAssetId(syncVault.poolId(), syncVault.scId(), AssetId.wrap(assetId));\n        assertNotEq(address(syncVault), address(0), \"Failed to retrieve async vault\");\n        AsyncVault asyncVault = AsyncVault(address(asyncVault_));\n\n        // Check price and max amounts\n        uint256 shares = syncVault.previewDeposit(amount);\n        uint256 assetsForShares = syncVault.previewMint(shares);\n        assertEq(shares, amount / assetsPerShare, \"shares, amount / assetsPerShare\");\n        assertEq(assetsForShares, amount, \"assetsForShares, amount\");\n        assertEq(syncVault.maxDeposit(self), MAX_UINT128, \"syncVault.maxDeposit(self) != type(uint128).max\");\n        assertEq(\n            syncVault.maxMint(self),\n            syncVault.convertToShares(MAX_UINT128),\n            \"syncVault.maxMint(self) != convertToShares(MAX_UINT128)\"\n        );\n\n        // Will fail - user not member: can not send funds\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        syncVault.deposit(amount, self);\n\n        assertEq(syncVault.isPermissioned(self), false);\n        centrifugeChain.updateMember(syncVault.poolId().raw(), syncVault.scId().raw(), self, type(uint64).max);\n        assertEq(syncVault.isPermissioned(self), true);\n\n        // Will fail - user did not give asset allowance to syncVault\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        syncVault.deposit(amount, self);\n        erc20.approve(address(syncVault), amount);\n\n        // Will fail - above max reserve\n        centrifugeChain.updateMaxReserve(\n            syncVault.poolId().raw(), syncVault.scId().raw(), address(syncVault), uint128(amount / 2)\n        );\n\n        vm.expectRevert(IBaseRequestManager.ExceedsMaxDeposit.selector);\n        syncVault.deposit(amount, self);\n\n        centrifugeChain.updateMaxReserve(\n            syncVault.poolId().raw(), syncVault.scId().raw(), address(syncVault), uint128(amount)\n        );\n\n        _assertDepositEvents(syncVault, shares.toUint128(), pricePoolPerShare, pricePoolPerAsset);\n        syncVault.deposit(amount, self);\n        assertEq(erc20.balanceOf(self), 0, \"Mismatch in sync deposited amount\");\n        assertEq(shareToken.balanceOf(self), shares, \"Mismatch in amount of sync received shares\");\n\n        // Can now request redemption through async syncVault\n        assertEq(asyncVault.pendingRedeemRequest(0, self), 0);\n        asyncVault.requestRedeem(amount / 2, self, self);\n        assertEq(asyncVault.pendingRedeemRequest(0, self), amount / 2);\n    }\n}\n"
    },
    "test/vaults/integration/SyncRequestManager.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {PricingLib} from \"src/common/libraries/PricingLib.sol\";\n\nimport {\n    ISyncRequestManager,\n    Prices,\n    ISyncDepositValuation\n} from \"src/vaults/interfaces/investments/ISyncRequestManager.sol\";\nimport {SyncRequestManager} from \"src/vaults/SyncRequestManager.sol\";\nimport {SyncDepositVault} from \"src/vaults/SyncDepositVault.sol\";\nimport {VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\nimport \"test/vaults/BaseTest.sol\";\n\ncontract SyncRequestManagerBaseTest is BaseTest {\n    function _assumeUnauthorizedCaller(address nonWard) internal view {\n        vm.assume(\n            nonWard != address(root) && nonWard != address(poolManager) && nonWard != address(syncDepositVaultFactory)\n                && nonWard != address(this)\n        );\n    }\n\n    function _deploySyncDepositVault(D18 pricePoolPerShare, D18 pricePoolPerAsset)\n        internal\n        returns (SyncDepositVault syncVault, uint128 assetId)\n    {\n        (, address syncVault_, uint128 assetId_) = deploySimpleVault(VaultKind.SyncDepositAsyncRedeem);\n        assetId = assetId_;\n        syncVault = SyncDepositVault(syncVault_);\n\n        centrifugeChain.updatePricePoolPerShare(\n            syncVault.poolId().raw(), syncVault.scId().raw(), pricePoolPerShare.inner(), uint64(block.timestamp)\n        );\n        centrifugeChain.updatePricePoolPerAsset(\n            syncVault.poolId().raw(),\n            syncVault.scId().raw(),\n            assetId,\n            pricePoolPerAsset.inner(),\n            uint64(block.timestamp)\n        );\n    }\n\n    function _setValuation(SyncDepositVault vault, address valuation_) internal {\n        vm.expectEmit();\n        emit ISyncRequestManager.SetValuation(vault.poolId(), vault.scId(), valuation_);\n        syncRequestManager.setValuation(vault.poolId(), vault.scId(), valuation_);\n        assertEq(address(syncRequestManager.valuation(vault.poolId(), vault.scId())), valuation_);\n    }\n}\n\ncontract SyncRequestManagerTest is SyncRequestManagerBaseTest {\n    using MessageLib for *;\n\n    // Deployment\n    function testDeployment(address nonWard) public {\n        _assumeUnauthorizedCaller(nonWard);\n\n        // redeploying within test to increase coverage\n        new SyncRequestManager(globalEscrow, address(root), address(this));\n\n        // values set correctly\n        assertEq(address(syncRequestManager.poolManager()), address(poolManager));\n        assertEq(address(syncRequestManager.balanceSheet()), address(balanceSheet));\n        assertEq(address(syncRequestManager.poolEscrowProvider()), address(poolEscrowFactory));\n\n        // permissions set correctly\n        assertEq(syncRequestManager.wards(address(root)), 1);\n        assertEq(syncRequestManager.wards(address(poolManager)), 1);\n        assertEq(syncRequestManager.wards(address(syncDepositVaultFactory)), 1);\n        assertEq(balanceSheet.wards(address(syncRequestManager)), 1);\n        assertEq(syncRequestManager.wards(nonWard), 0);\n    }\n\n    // --- Administration ---\n    function testFile() public {\n        // fail: unrecognized param\n        vm.expectRevert(IBaseRequestManager.FileUnrecognizedParam.selector);\n        syncRequestManager.file(\"random\", self);\n\n        assertEq(address(syncRequestManager.poolManager()), address(poolManager));\n        assertEq(address(syncRequestManager.balanceSheet()), address(balanceSheet));\n\n        // success\n        syncRequestManager.file(\"poolManager\", randomUser);\n        assertEq(address(syncRequestManager.poolManager()), randomUser);\n        syncRequestManager.file(\"balanceSheet\", randomUser);\n        assertEq(address(syncRequestManager.balanceSheet()), randomUser);\n        syncRequestManager.file(\"poolEscrowProvider\", randomUser);\n        assertEq(address(syncRequestManager.balanceSheet()), randomUser);\n\n        // remove self from wards\n        syncRequestManager.deny(self);\n        // auth fail\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        syncRequestManager.file(\"poolManager\", randomUser);\n    }\n\n    // --- Simple Errors ---\n    function testDepositUnlinkedVault() public {\n        (SyncDepositVault vault, uint128 assetId) = _deploySyncDepositVault(d18(0), d18(0));\n        poolManager.unlinkVault(vault.poolId(), vault.scId(), AssetId.wrap(assetId), vault);\n\n        vm.expectRevert(IBaseRequestManager.AssetNotAllowed.selector);\n        syncRequestManager.deposit(vault, 1, address(0), address(0));\n    }\n\n    function testAddVaultEmptySecondaryManager() public {\n        (SyncDepositVault vault, uint128 assetId_) = _deploySyncDepositVault(d18(0), d18(0));\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        AssetId assetId = AssetId.wrap(assetId_);\n\n        syncRequestManager.removeVault(poolId, scId, vault, vaultDetails.asset, assetId);\n\n        vm.prank(address(root));\n        vault.file(\"asyncRedeemManager\", address(0));\n\n        vm.expectRevert(ISyncRequestManager.SecondaryManagerDoesNotExist.selector);\n        syncRequestManager.addVault(poolId, scId, vault, vaultDetails.asset, assetId);\n    }\n\n    function testRemoveVaultEmptySecondaryManager() public {\n        (SyncDepositVault vault, uint128 assetId_) = _deploySyncDepositVault(d18(0), d18(0));\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(vault);\n        PoolId poolId = vault.poolId();\n        ShareClassId scId = vault.scId();\n        AssetId assetId = AssetId.wrap(assetId_);\n\n        vm.prank(address(root));\n        vault.file(\"asyncRedeemManager\", address(0));\n\n        vm.expectRevert(ISyncRequestManager.SecondaryManagerDoesNotExist.selector);\n        syncRequestManager.removeVault(poolId, scId, vault, vaultDetails.asset, assetId);\n    }\n}\n\ncontract SyncRequestManagerUnauthorizedTest is SyncRequestManagerBaseTest {\n    function testFileUnauthorized(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.file(bytes32(0), address(0));\n    }\n\n    function testAddVaultUnauthorized(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.addVault(\n            PoolId.wrap(0), ShareClassId.wrap(0), IBaseVault(address(0)), address(0), AssetId.wrap(0)\n        );\n    }\n\n    function testRemoveVaultUnauthorized(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.removeVault(\n            PoolId.wrap(0), ShareClassId.wrap(0), IBaseVault(address(0)), address(0), AssetId.wrap(0)\n        );\n    }\n\n    function testDepositUnauthorized(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.deposit(IBaseVault(address(0)), 0, address(0), address(0));\n    }\n\n    function testMintUnauthorized(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.mint(IBaseVault(address(0)), 0, address(0), address(0));\n    }\n\n    function testSetValuationUnauthorized(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.setValuation(PoolId.wrap(0), ShareClassId.wrap(0), address(0));\n    }\n\n    function testUpdate(address nonWard) public {\n        _expectUnauthorized(nonWard);\n        syncRequestManager.update(PoolId.wrap(0), ShareClassId.wrap(0), bytes(\"\"));\n    }\n\n    function _expectUnauthorized(address caller) internal {\n        vm.assume(\n            caller != address(root) && caller != address(poolManager) && caller != address(syncDepositVaultFactory)\n                && caller != address(this)\n        );\n\n        vm.prank(caller);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n    }\n}\n\ncontract SyncRequestManagerPrices is SyncRequestManagerBaseTest {\n    function testPricesWithoutValuation(uint128 pricePoolPerShare_, uint128 pricePoolPerAsset_) public {\n        D18 pricePoolPerShare = d18(uint128(bound(pricePoolPerShare_, 1e6, 1e24)));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, 1e4, pricePoolPerShare.inner())));\n        D18 priceAssetPerShare = pricePoolPerShare / pricePoolPerAsset;\n\n        (SyncDepositVault syncVault, uint128 assetId) = _deploySyncDepositVault(pricePoolPerShare, pricePoolPerAsset);\n\n        Prices memory prices = syncRequestManager.prices(syncVault.poolId(), syncVault.scId(), AssetId.wrap(assetId));\n        assertEq(prices.assetPerShare.inner(), priceAssetPerShare.inner(), \"priceAssetPerShare mismatch\");\n        assertEq(prices.poolPerShare.inner(), pricePoolPerShare.inner(), \"pricePoolPerShare mismatch\");\n        assertEq(prices.poolPerAsset.inner(), pricePoolPerAsset.inner(), \"pricePoolPerAsset mismatch\");\n    }\n}\n\ncontract SyncRequestManagerUpdateValuation is SyncRequestManagerBaseTest {\n    using MathLib for uint256;\n\n    address valuation_ = makeAddr(\"valuation\");\n\n    function _mockValuation(SyncDepositVault syncVault, D18 pricePoolPerShare) internal {\n        vm.mockCall(\n            address(valuation_),\n            abi.encodeWithSelector(\n                ISyncDepositValuation.pricePoolPerShare.selector, syncVault.poolId(), syncVault.scId()\n            ),\n            abi.encode(pricePoolPerShare)\n        );\n    }\n\n    function _assertPrices(SyncDepositVault syncVault, D18 prePoolPerShare, Prices memory expected, uint128 assetId)\n        internal\n        view\n    {\n        Prices memory prices = syncRequestManager.prices(syncVault.poolId(), syncVault.scId(), AssetId.wrap(assetId));\n\n        D18 pricePost = syncRequestManager.pricePoolPerShare(syncVault.poolId(), syncVault.scId());\n        assertNotEq(prePoolPerShare.inner(), pricePost.inner(), \"Price should be changed by valuation\");\n        assertEq(expected.poolPerShare.inner(), prices.poolPerShare.inner(), \"poolPerShare mismatch\");\n        assertEq(expected.poolPerShare.inner(), pricePost.inner(), \"poolPerShare vs pricePost mismatch\");\n\n        assertEq(expected.poolPerAsset.inner(), prices.poolPerAsset.inner(), \"poolPerAsset mismatch\");\n        assertEq(expected.assetPerShare.inner(), prices.assetPerShare.inner(), \"assetPerShare mismatch\");\n    }\n\n    function testSetValuationERC20() public {\n        (SyncDepositVault syncVault,) = _deploySyncDepositVault(d18(1e18), d18(1e18));\n\n        _setValuation(syncVault, valuation_);\n    }\n\n    function testPricesWithValuationERC20() public {\n        D18 pricePoolPerShare = d18(10e18);\n        D18 pricePoolPerAsset = d18(5e18);\n        D18 priceAssetPerShare = d18(2e18);\n\n        (SyncDepositVault syncVault, uint128 assetId) = _deploySyncDepositVault(pricePoolPerShare, pricePoolPerAsset);\n        D18 pricePre = syncRequestManager.pricePoolPerShare(syncVault.poolId(), syncVault.scId());\n\n        _setValuation(syncVault, valuation_);\n\n        // Change pricePoolPerShare\n        pricePoolPerShare = d18(20e18);\n        priceAssetPerShare = d18(4e18); // 20e18 / 5e18\n\n        // Mock valuation and perform checks\n        _mockValuation(syncVault, pricePoolPerShare);\n        _assertPrices(\n            syncVault,\n            pricePre,\n            Prices({assetPerShare: priceAssetPerShare, poolPerAsset: pricePoolPerAsset, poolPerShare: pricePoolPerShare}),\n            assetId\n        );\n    }\n\n    function testFuzzedPricesWithValuationERC20(\n        uint128 pricePoolPerShare_,\n        uint128 pricePoolPerAsset_,\n        uint8 multiplier_\n    ) public {\n        D18 pricePoolPerShare = d18(uint128(bound(pricePoolPerShare_, 1e8, 1e24)));\n        D18 pricePoolPerAsset = d18(uint128(bound(pricePoolPerAsset_, 1e6, pricePoolPerShare.inner())));\n        D18 priceAssetPerShare = pricePoolPerShare / pricePoolPerAsset;\n        uint128 multiplier = uint128(bound(multiplier_, 2, 10));\n        vm.assume(priceAssetPerShare.inner() % multiplier == 0);\n\n        (SyncDepositVault syncVault, uint128 assetId) = _deploySyncDepositVault(pricePoolPerShare, pricePoolPerAsset);\n        D18 pricePre = syncRequestManager.pricePoolPerShare(syncVault.poolId(), syncVault.scId());\n\n        _setValuation(syncVault, valuation_);\n\n        // Change pricePoolPerShare\n        pricePoolPerShare = d18(pricePoolPerShare.inner() * multiplier);\n        priceAssetPerShare = pricePoolPerShare / pricePoolPerAsset;\n\n        // Mock valuation and perform checks\n        _mockValuation(syncVault, pricePoolPerShare);\n        _assertPrices(\n            syncVault,\n            pricePre,\n            Prices({assetPerShare: priceAssetPerShare, poolPerAsset: pricePoolPerAsset, poolPerShare: pricePoolPerShare}),\n            assetId\n        );\n    }\n}\n"
    },
    "test/vaults/integration/VaultRouter.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\n\nimport \"src/misc/interfaces/IERC7575.sol\";\nimport \"src/misc/interfaces/IERC7540.sol\";\nimport \"src/misc/interfaces/IERC20.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\nimport {IMulticall} from \"src/misc/interfaces/IMulticall.sol\";\nimport {ReentrancyProtection} from \"src/misc/ReentrancyProtection.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\n\nimport {IBaseVault, IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {VaultRouter} from \"src/vaults/VaultRouter.sol\";\nimport {IVaultRouter} from \"src/vaults/interfaces/IVaultRouter.sol\";\nimport {IPoolManager} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {MockERC20Wrapper} from \"test/vaults/mocks/MockERC20Wrapper.sol\";\nimport {MockReentrantERC20Wrapper1, MockReentrantERC20Wrapper2} from \"test/vaults/mocks/MockReentrantERC20Wrapper.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\n\ncontract VaultRouterTest is BaseTest {\n    using MessageLib for *;\n    using MathLib for uint256;\n\n    uint256 constant GAS_BUFFER = 10 gwei;\n    bytes PAYLOAD_FOR_GAS_ESTIMATION = MessageLib.NotifyPool(1).serialize();\n\n    /// forge-config: default.isolate = true\n    function testCFGRouterDeposit() public {\n        _testCFGRouterDeposit(4, true);\n    }\n\n    /// forge-config: default.isolate = true\n    function testCFGRouterDepositFuzz(uint256 amount) public {\n        vm.assume(amount % 2 == 0);\n        _testCFGRouterDeposit(amount, false);\n    }\n\n    function _testCFGRouterDeposit(uint256 amount, bool snap) internal {\n        // If lower than 4 or odd, rounding down can lead to not receiving any tokens\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        erc20.mint(self, amount);\n\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vaultRouter.requestDeposit{value: 1 wei}(vault, amount, self, self);\n\n        vaultRouter.enable(vault);\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vaultRouter.requestDeposit{value: 1 wei}(vault, amount, self, self);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n\n        uint256 preBalance = address(gateway).balance;\n        uint256 gas = estimateGas() + GAS_BUFFER;\n\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        erc20.approve(vault_, amount);\n\n        address nonOwner = makeAddr(\"NonOwner\");\n        vm.deal(nonOwner, 10 ether);\n        vm.prank(nonOwner);\n        vm.expectRevert(IVaultRouter.InvalidOwner.selector);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n\n        if (snap) {\n            vm.startSnapshotGas(\"VaultRouter\", \"requestDeposit\");\n        }\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n\n        assertEq(address(gateway).balance, preBalance + GAS_BUFFER, \"Gateway balance mismatch\");\n        for (uint8 i; i < testAdapters.length; i++) {\n            MockAdapter adapter = MockAdapter(address(testAdapters[i]));\n            uint256[] memory payCalls = adapter.callsWithValue(\"send\");\n            // Messages: registerAsset and requestDeposit\n            assertEq(payCalls.length, 2);\n            assertEq(\n                payCalls[1],\n                adapter.estimate(\n                    OTHER_CHAIN_ID,\n                    PAYLOAD_FOR_GAS_ESTIMATION,\n                    mockedGasService.gasLimit(OTHER_CHAIN_ID, PAYLOAD_FOR_GAS_ESTIMATION)\n                ),\n                \"payload gas mismatch\"\n            );\n        }\n\n        // trigger - deposit order fulfillment\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, self);\n\n        assertEq(vault.maxMint(self), sharePayout);\n        assertEq(vault.maxDeposit(self), amount);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        assertEq(shareToken.balanceOf(address(globalEscrow)), sharePayout);\n\n        if (snap) {\n            vm.startSnapshotGas(\"VaultRouter\", \"claimDeposit\");\n        }\n        vaultRouter.claimDeposit(vault, self, self);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n        assertApproxEqAbs(shareToken.balanceOf(self), sharePayout, 1);\n        assertApproxEqAbs(shareToken.balanceOf(self), sharePayout, 1);\n        assertApproxEqAbs(shareToken.balanceOf(address(globalEscrow)), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), amount, 1);\n    }\n\n    function testEnableDisableVaults() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        root.veto(address(vaultRouter));\n        vm.expectRevert(IBaseVault.NotEndorsed.selector);\n        vaultRouter.enable(vault);\n        assertEq(vault.isOperator(address(this), address(vaultRouter)), false);\n        assertEq(vaultRouter.isEnabled(vault, address(this)), false);\n\n        root.endorse(address(vaultRouter));\n        vaultRouter.enable(vault);\n        assertEq(vault.isOperator(address(this), address(vaultRouter)), true);\n        assertEq(vaultRouter.isEnabled(vault, address(this)), true);\n\n        root.veto(address(vaultRouter));\n        vm.expectRevert(IBaseVault.NotEndorsed.selector);\n        vaultRouter.disable(vault);\n        assertEq(vault.isOperator(address(this), address(vaultRouter)), true);\n        assertEq(vaultRouter.isEnabled(vault, address(this)), true);\n\n        root.endorse(address(vaultRouter));\n        vaultRouter.disable(vault);\n        assertEq(vault.isOperator(address(this), address(vaultRouter)), false);\n        assertEq(vaultRouter.isEnabled(vault, address(this)), false);\n    }\n\n    function testRouterAsyncDeposit(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        erc20.mint(self, amount);\n        erc20.approve(address(vaultRouter), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        vaultRouter.enableLockDepositRequest(vault, amount);\n\n        uint256 fuel = estimateGas();\n\n        // Any address should be able to call executeLockedDepositRequest for an investor\n        address randomAddress = address(0x123);\n        vm.label(randomAddress, \"randomAddress\");\n        vm.deal(randomAddress, 10 ether);\n        vm.startPrank(randomAddress);\n        vaultRouter.executeLockedDepositRequest{value: fuel}(vault, address(this));\n        vm.stopPrank();\n\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, self);\n\n        assertEq(vault.maxMint(self), sharePayout);\n        assertEq(vault.maxDeposit(self), amount);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        assertEq(shareToken.balanceOf(address(globalEscrow)), sharePayout);\n\n        // Any address should be able to call claimDeposit for an investor\n        vm.prank(randomUser);\n        vaultRouter.claimDeposit(vault, self, self);\n        assertApproxEqAbs(shareToken.balanceOf(self), sharePayout, 1);\n        assertApproxEqAbs(shareToken.balanceOf(address(globalEscrow)), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), amount, 1);\n    }\n\n    /// forge-config: default.isolate = true\n    function testRouterRedeem() public {\n        _testRouterRedeem(4, true);\n    }\n\n    /// forge-config: default.isolate = true\n    function testRouterRedeemFuzz(uint256 amount) public {\n        vm.assume(amount % 2 == 0);\n        _testRouterRedeem(amount, false);\n    }\n\n    function _testRouterRedeem(uint256 amount, bool snap) internal {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n\n        // deposit\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n        erc20.mint(self, amount);\n        erc20.approve(vault_, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        if (snap) {\n            vm.startSnapshotGas(\"VaultRouter\", \"enable\");\n        }\n        vaultRouter.enable(vault);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n\n        uint256 fuel = estimateGas();\n        vaultRouter.requestDeposit{value: fuel}(vault, amount, self, self);\n\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, self);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        vaultRouter.claimDeposit(vault, self, self);\n        shareToken.approve(address(vaultRouter), sharePayout);\n\n        address nonOwner = makeAddr(\"NonOwner\");\n        vm.deal(nonOwner, 10 ether);\n        vm.prank(nonOwner);\n        vm.expectRevert(IVaultRouter.InvalidOwner.selector);\n        vaultRouter.requestRedeem{value: fuel}(vault, sharePayout, self, self);\n\n        // redeem\n        if (snap) {\n            vm.startSnapshotGas(\"VaultRouter\", \"requestRedeem\");\n        }\n        vaultRouter.requestRedeem{value: fuel}(vault, sharePayout, self, self);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n        (uint128 assetPayout) = fulfillRedeemRequest(vault, assetId, sharePayout, self);\n        assertApproxEqAbs(shareToken.balanceOf(self), 0, 1);\n        assertApproxEqAbs(shareToken.balanceOf(address(globalEscrow)), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), assetPayout, 1);\n        assertApproxEqAbs(erc20.balanceOf(self), 0, 1);\n        vaultRouter.claimRedeem(vault, self, self);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(self), assetPayout, 1);\n    }\n\n    function testRouterDepositIntoMultipleVaults(uint256 amount1, uint256 amount2) public {\n        amount1 = uint128(bound(amount1, 4, MAX_UINT128));\n        vm.assume(amount1 % 2 == 0);\n        amount2 = uint128(bound(amount2, 4, MAX_UINT128));\n        vm.assume(amount2 % 2 == 0);\n\n        uint256 fuel = estimateGas();\n        (ERC20 erc20X, ERC20 erc20Y, AsyncVault vault1, AsyncVault vault2) = setUpMultipleVaults(amount1, amount2);\n\n        vaultRouter.enable(vault1);\n        vaultRouter.enable(vault2);\n\n        vaultRouter.requestDeposit{value: fuel}(vault1, amount1, self, self);\n        vaultRouter.requestDeposit{value: fuel}(vault2, amount2, self, self);\n\n        // trigger - deposit order fulfillment\n        AssetId assetId1 = poolManager.assetToId(address(erc20X), erc20TokenId);\n        AssetId assetId2 = poolManager.assetToId(address(erc20Y), erc20TokenId);\n        (uint128 sharePayout1) = fulfillDepositRequest(vault1, assetId1.raw(), amount1, self);\n        (uint128 sharePayout2) = fulfillDepositRequest(vault2, assetId2.raw(), amount2, self);\n\n        assertEq(vault1.maxMint(self), sharePayout1);\n        assertEq(vault2.maxMint(self), sharePayout2);\n        assertEq(vault1.maxDeposit(self), amount1);\n        assertEq(vault2.maxDeposit(self), amount2);\n        IShareToken shareToken1 = IShareToken(address(vault1.share()));\n        IShareToken shareToken2 = IShareToken(address(vault2.share()));\n        assertEq(shareToken1.balanceOf(address(globalEscrow)), sharePayout1);\n        assertEq(shareToken2.balanceOf(address(globalEscrow)), sharePayout2);\n\n        vaultRouter.claimDeposit(vault1, self, self);\n        vaultRouter.claimDeposit(vault2, self, self);\n        assertApproxEqAbs(shareToken1.balanceOf(self), sharePayout1, 1);\n        assertApproxEqAbs(shareToken2.balanceOf(self), sharePayout2, 1);\n        assertApproxEqAbs(shareToken1.balanceOf(address(globalEscrow)), 0, 1);\n        assertApproxEqAbs(shareToken2.balanceOf(address(globalEscrow)), 0, 1);\n        assertApproxEqAbs(erc20X.balanceOf(address(poolEscrowFactory.escrow(vault1.poolId()))), amount1, 1);\n        assertApproxEqAbs(erc20Y.balanceOf(address(poolEscrowFactory.escrow(vault2.poolId()))), amount2, 1);\n    }\n\n    function testRouterRedeemFromMultipleVaults(uint256 amount1, uint256 amount2) public {\n        amount1 = uint128(bound(amount1, 4, MAX_UINT128));\n        vm.assume(amount1 % 2 == 0);\n        amount2 = uint128(bound(amount2, 4, MAX_UINT128));\n        vm.assume(amount2 % 2 == 0);\n\n        // NOTE: Multiply by 2 due to coupling Fulfilled* with either ApprovedDeposit or RevokedShares which send a\n        //       message back to Hub\n        uint256 fuel = 2 * estimateGas();\n        // deposit\n        (ERC20 erc20X, ERC20 erc20Y, AsyncVault vault1, AsyncVault vault2) = setUpMultipleVaults(amount1, amount2);\n\n        vaultRouter.enable(vault1);\n        vaultRouter.enable(vault2);\n        vaultRouter.requestDeposit{value: fuel}(vault1, amount1, self, self);\n        vaultRouter.requestDeposit{value: fuel}(vault2, amount2, self, self);\n\n        AssetId assetId1 = poolManager.assetToId(address(erc20X), erc20TokenId);\n        AssetId assetId2 = poolManager.assetToId(address(erc20Y), erc20TokenId);\n        (uint128 sharePayout1) = fulfillDepositRequest(vault1, assetId1.raw(), amount1, self);\n        (uint128 sharePayout2) = fulfillDepositRequest(vault2, assetId2.raw(), amount2, self);\n        vaultRouter.claimDeposit(vault1, self, self);\n        vaultRouter.claimDeposit(vault2, self, self);\n\n        // redeem\n        IShareToken(address(vault1.share())).approve(address(vaultRouter), sharePayout1);\n        IShareToken(address(vault2.share())).approve(address(vaultRouter), sharePayout2);\n        vaultRouter.requestRedeem{value: fuel}(vault1, sharePayout1, self, self);\n        vaultRouter.requestRedeem{value: fuel}(vault2, sharePayout2, self, self);\n        (uint128 assetPayout1) = fulfillRedeemRequest(vault1, assetId1.raw(), sharePayout1, self);\n        (uint128 assetPayout2) = fulfillRedeemRequest(vault2, assetId2.raw(), sharePayout2, self);\n        assertApproxEqAbs(IShareToken(address(vault1.share())).balanceOf(self), 0, 1);\n        assertApproxEqAbs(IShareToken(address(vault2.share())).balanceOf(self), 0, 1);\n        assertApproxEqAbs(\n            IShareToken(address(vault1.share())).balanceOf(address(poolEscrowFactory.escrow(vault1.poolId()))), 0, 1\n        );\n        assertApproxEqAbs(\n            IShareToken(address(vault2.share())).balanceOf(address(poolEscrowFactory.escrow(vault2.poolId()))), 0, 1\n        );\n        assertApproxEqAbs(erc20X.balanceOf(address(poolEscrowFactory.escrow(vault1.poolId()))), assetPayout1, 1);\n        assertApproxEqAbs(erc20Y.balanceOf(address(poolEscrowFactory.escrow(vault2.poolId()))), assetPayout2, 1);\n        assertApproxEqAbs(erc20X.balanceOf(self), 0, 1);\n        assertApproxEqAbs(erc20Y.balanceOf(self), 0, 1);\n\n        // claim redeem\n        vaultRouter.claimRedeem(vault1, self, self);\n        vaultRouter.claimRedeem(vault2, self, self);\n        assertApproxEqAbs(erc20X.balanceOf(address(poolEscrowFactory.escrow(vault1.poolId()))), 0, 1);\n        assertApproxEqAbs(erc20Y.balanceOf(address(poolEscrowFactory.escrow(vault2.poolId()))), 0, 1);\n        assertApproxEqAbs(erc20X.balanceOf(self), assetPayout1, 1);\n        assertApproxEqAbs(erc20Y.balanceOf(self), assetPayout2, 1);\n    }\n\n    /// forge-config: default.isolate = true\n    function testMulticallingApproveVaultAndExecuteLockedDepositRequest() public {\n        _testMulticallingApproveVaultAndExecuteLockedDepositRequest(4, true);\n    }\n\n    /// forge-config: default.isolate = true\n    function testMulticallingApproveVaultAndExecuteLockedDepositRequestFuzz(uint256 amount) public {\n        vm.assume(amount % 2 == 0);\n        _testMulticallingApproveVaultAndExecuteLockedDepositRequest(amount, false);\n    }\n\n    function _testMulticallingApproveVaultAndExecuteLockedDepositRequest(uint256 amount, bool snap) internal {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        erc20.mint(self, amount);\n        erc20.approve(address(vaultRouter), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        vaultRouter.enable(vault);\n        if (snap) {\n            vm.startSnapshotGas(\"VaultRouter\", \"lockDepositRequest\");\n        }\n        vaultRouter.lockDepositRequest(vault, amount, self, self);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n\n        // multicall\n        uint256 fuel = estimateGas();\n        bytes[] memory calls = new bytes[](1);\n        calls[0] = abi.encodeWithSelector(vaultRouter.executeLockedDepositRequest.selector, vault_, self, fuel);\n        vaultRouter.multicall{value: fuel}(calls);\n\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, self);\n\n        assertEq(vault.maxMint(self), sharePayout);\n        assertEq(vault.maxDeposit(self), amount);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        assertEq(shareToken.balanceOf(address(globalEscrow)), sharePayout);\n    }\n\n    function testMulticallingDepositClaimAndRequestRedeem(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        // deposit\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n        erc20.mint(self, amount);\n        erc20.approve(vault_, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        vaultRouter.enable(vault);\n\n        uint256 fuel = estimateGas();\n        vaultRouter.requestDeposit{value: fuel}(vault, amount, self, self);\n\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, self);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        shareToken.approve(address(vaultRouter), sharePayout);\n\n        // multicall\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(vaultRouter.claimDeposit.selector, vault_, self, self);\n        calls[1] = abi.encodeWithSelector(vaultRouter.requestRedeem.selector, vault_, sharePayout, self, self, fuel);\n        vaultRouter.multicall{value: fuel}(calls);\n\n        (uint128 assetPayout) = fulfillRedeemRequest(vault, assetId, sharePayout, self);\n        assertApproxEqAbs(shareToken.balanceOf(self), 0, 1);\n        assertApproxEqAbs(shareToken.balanceOf(address(globalEscrow)), 0, 1);\n        assertApproxEqAbs(erc20.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), assetPayout, 1);\n        assertApproxEqAbs(erc20.balanceOf(self), 0, 1);\n    }\n\n    function testMulticallingDepositIntoMultipleVaults(uint256 amount1, uint256 amount2) public {\n        amount1 = uint128(bound(amount1, 4, MAX_UINT128));\n        vm.assume(amount1 % 2 == 0);\n        amount2 = uint128(bound(amount2, 4, MAX_UINT128));\n        vm.assume(amount2 % 2 == 0);\n\n        (ERC20 erc20X, ERC20 erc20Y, AsyncVault vault1, AsyncVault vault2) = setUpMultipleVaults(amount1, amount2);\n\n        vaultRouter.enable(vault1);\n        vaultRouter.enable(vault2);\n\n        uint256 gas = estimateGas();\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(vaultRouter.requestDeposit.selector, vault1, amount1, self, self);\n        calls[1] = abi.encodeWithSelector(vaultRouter.requestDeposit.selector, vault2, amount2, self, self);\n        vaultRouter.multicall{value: gas * calls.length}(calls);\n\n        // trigger - deposit order fulfillment\n        AssetId assetId1 = poolManager.assetToId(address(erc20X), erc20TokenId);\n        AssetId assetId2 = poolManager.assetToId(address(erc20Y), erc20TokenId);\n        (uint128 sharePayout1) = fulfillDepositRequest(vault1, assetId1.raw(), amount1, self);\n        (uint128 sharePayout2) = fulfillDepositRequest(vault2, assetId2.raw(), amount2, self);\n\n        assertEq(vault1.maxMint(self), sharePayout1);\n        assertEq(vault2.maxMint(self), sharePayout2);\n        assertEq(vault1.maxDeposit(self), amount1);\n        assertEq(vault2.maxDeposit(self), amount2);\n        IShareToken shareToken1 = IShareToken(address(vault1.share()));\n        IShareToken shareToken2 = IShareToken(address(vault2.share()));\n        assertEq(shareToken1.balanceOf(address(globalEscrow)), sharePayout1);\n        assertEq(shareToken2.balanceOf(address(globalEscrow)), sharePayout2);\n    }\n\n    function testLockAndExecuteDepositRequest(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n        (, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(wrapper), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        address investor = makeAddr(\"investor\");\n        vm.deal(investor, 10 ether);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n\n        erc20.mint(investor, amount);\n        vm.startPrank(investor);\n        erc20.approve(address(vaultRouter), amount);\n\n        uint256 fuel = estimateGas() + GAS_BUFFER;\n\n        // multicall\n        bytes[] memory calls = new bytes[](3);\n        calls[0] = abi.encodeWithSelector(vaultRouter.wrap.selector, wrapper, amount, address(vaultRouter), investor);\n        calls[1] = abi.encodeWithSelector(\n            vaultRouter.lockDepositRequest.selector, vault_, amount, investor, address(vaultRouter)\n        );\n        calls[2] = abi.encodeWithSelector(vaultRouter.executeLockedDepositRequest.selector, vault_, investor, fuel);\n        vaultRouter.multicall{value: fuel}(calls);\n\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, investor);\n\n        assertEq(vault.maxMint(investor), sharePayout);\n        assertEq(vault.maxDeposit(investor), amount);\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        assertEq(shareToken.balanceOf(address(globalEscrow)), sharePayout);\n    }\n\n    function testWrapAndUnwrap(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n        (, address vault_,) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(wrapper), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        address investor = makeAddr(\"investor\");\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        vaultRouter.enable(vault);\n\n        erc20.mint(investor, amount);\n        vm.startPrank(investor);\n        erc20.approve(address(vaultRouter), amount);\n\n        assertEq(erc20.balanceOf(investor), amount);\n\n        // multicall\n        bytes[] memory calls = new bytes[](2);\n        calls[0] =\n            abi.encodeWithSelector(vaultRouter.wrap.selector, address(wrapper), amount, address(vaultRouter), investor);\n        calls[1] = abi.encodeWithSelector(vaultRouter.unwrap.selector, address(wrapper), amount, investor);\n        vaultRouter.multicall(calls);\n\n        assertEq(erc20.balanceOf(investor), amount);\n    }\n\n    function testWrapAndDeposit(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n        (, address vault_,) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(wrapper), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        address investor = makeAddr(\"investor\");\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        vaultRouter.enable(vault);\n\n        erc20.mint(investor, amount);\n        vm.startPrank(investor);\n        erc20.approve(address(vaultRouter), amount);\n\n        assertEq(erc20.balanceOf(investor), amount);\n\n        vm.deal(investor, 10 ether);\n        uint256 fuel = estimateGas();\n        vaultRouter.wrap(address(wrapper), amount, address(vaultRouter), investor);\n        vaultRouter.requestDeposit{value: fuel}(vault, amount, investor, address(vaultRouter));\n    }\n\n    function testWrapAndAutoUnwrapOnRedeem(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n        (, address vault_, uint128 assetId) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(wrapper), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        address investor = makeAddr(\"investor\");\n\n        erc20.mint(investor, amount);\n\n        // Investor locks deposit request and enables permissionless lcaiming\n        vm.startPrank(investor);\n        erc20.approve(address(vaultRouter), amount);\n        vaultRouter.enableLockDepositRequest(vault, amount);\n        vm.stopPrank();\n\n        // NOTE: Multiply by 2 due to coupling Fulfilled* with either ApprovedDeposit or RevokedShares which send a\n        //       message back to Hub\n        uint256 fuel = 2 * estimateGas();\n\n        // Anyone else can execute the request and claim the deposit\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), investor, type(uint64).max);\n        vaultRouter.executeLockedDepositRequest{value: fuel}(vault, investor);\n        (uint128 sharePayout) = fulfillDepositRequest(vault, assetId, amount, investor);\n\n        IShareToken shareToken = IShareToken(address(vault.share()));\n        vaultRouter.claimDeposit(vault, investor, investor);\n\n        // Investors submits redemption request\n        vm.deal(investor, 10 ether);\n        vm.startPrank(investor);\n        shareToken.approve(address(vaultRouter), sharePayout);\n        vaultRouter.requestRedeem{value: fuel}(vault, sharePayout, investor, investor);\n        vm.stopPrank();\n\n        // Anyone else claims the redeem\n        (uint128 assetPayout) = fulfillRedeemRequest(vault, assetId, sharePayout, investor);\n        assertEq(wrapper.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), assetPayout);\n        assertEq(erc20.balanceOf(address(investor)), 0);\n        vaultRouter.claimRedeem(vault, investor, investor);\n\n        // Token was immediately unwrapped\n        assertEq(wrapper.balanceOf(address(poolEscrowFactory.escrow(vault.poolId()))), 0);\n        assertEq(erc20.balanceOf(investor), assetPayout);\n    }\n\n    function testEnableLockDepositRequest(uint256 wrappedAmount, uint256 underlyingAmount) public {\n        wrappedAmount = uint128(bound(wrappedAmount, 4, MAX_UINT128));\n        vm.assume(wrappedAmount % 2 == 0);\n\n        underlyingAmount = uint128(bound(underlyingAmount, 4, MAX_UINT128));\n        vm.assume(underlyingAmount % 2 == 0);\n\n        vm.assume(wrappedAmount != underlyingAmount);\n        vm.assume(wrappedAmount < underlyingAmount);\n\n        address routerEscrowAddress = address(routerEscrow);\n\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n        (, address vault_,) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(wrapper), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        erc20.mint(self, underlyingAmount);\n        erc20.approve(address(vaultRouter), underlyingAmount);\n        wrapper.mint(self, wrappedAmount);\n        wrapper.approve(address(vaultRouter), wrappedAmount);\n\n        // Testing partial of wrapped asset balance\n        uint256 wrappedBalance = wrapper.balanceOf(self);\n        uint256 deposit = wrappedBalance / 2;\n        uint256 remainingWrapped = wrappedBalance / 2;\n        uint256 remainingUnderlying = erc20.balanceOf(self);\n        uint256 escrowBalance = deposit;\n        vaultRouter.enableLockDepositRequest(vault, deposit);\n        assertEq(wrapper.balanceOf(routerEscrowAddress), escrowBalance);\n        assertEq(wrapper.balanceOf(self), remainingWrapped);\n        assertEq(erc20.balanceOf(routerEscrowAddress), 0);\n        assertEq(erc20.balanceOf(self), remainingUnderlying);\n\n        // Testing more than the wrapped asset balance\n        wrappedBalance = wrapper.balanceOf(self);\n        deposit = wrappedBalance + 1;\n        remainingWrapped = wrappedBalance;\n        remainingUnderlying = erc20.balanceOf(self) - deposit;\n        escrowBalance = escrowBalance + deposit;\n        vaultRouter.enableLockDepositRequest(vault, deposit);\n        assertEq(wrapper.balanceOf(routerEscrowAddress), escrowBalance); // amount was used from the underlying asset\n            // and wrapped\n        assertEq(wrapper.balanceOf(self), remainingWrapped);\n        assertEq(erc20.balanceOf(routerEscrowAddress), 0);\n        assertEq(erc20.balanceOf(self), remainingUnderlying);\n\n        // Testing whole wrapped amount\n        wrappedBalance = wrapper.balanceOf(self);\n        deposit = wrappedBalance;\n        remainingUnderlying = erc20.balanceOf(self);\n        escrowBalance = escrowBalance + deposit;\n        vaultRouter.enableLockDepositRequest(vault, deposit);\n        assertEq(wrapper.balanceOf(routerEscrowAddress), escrowBalance);\n        assertEq(wrapper.balanceOf(self), 0);\n        assertEq(erc20.balanceOf(routerEscrowAddress), 0);\n        assertEq(erc20.balanceOf(self), remainingUnderlying);\n\n        // Testing more than the underlying\n        uint256 underlyingBalance = erc20.balanceOf(self);\n        deposit = underlyingBalance + 1;\n        remainingUnderlying = underlyingBalance;\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        vaultRouter.enableLockDepositRequest(vault, deposit);\n        assertEq(wrapper.balanceOf(routerEscrowAddress), escrowBalance);\n        assertEq(wrapper.balanceOf(self), 0);\n        assertEq(erc20.balanceOf(routerEscrowAddress), 0);\n        assertEq(erc20.balanceOf(self), remainingUnderlying);\n\n        // Testing all the underlying\n        deposit = erc20.balanceOf(self);\n        escrowBalance = escrowBalance + deposit;\n        vaultRouter.enableLockDepositRequest(vault, deposit);\n        assertEq(wrapper.balanceOf(routerEscrowAddress), escrowBalance);\n        assertEq(wrapper.balanceOf(self), 0);\n        assertEq(erc20.balanceOf(routerEscrowAddress), 0);\n        assertEq(erc20.balanceOf(self), 0);\n\n        // Testing with empty balance for both wrapped and underlying\n        vm.expectRevert(IVaultRouter.ZeroBalance.selector);\n        vaultRouter.enableLockDepositRequest(vault, wrappedAmount);\n    }\n\n    function testMultipleTopUpScenarios(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        erc20.mint(self, amount);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        erc20.approve(vault_, amount);\n        vaultRouter.enable(vault);\n\n        uint256 gasLimit =\n            gateway.estimate(OTHER_CHAIN_ID, bytes.concat(PAYLOAD_FOR_GAS_ESTIMATION, PAYLOAD_FOR_GAS_ESTIMATION));\n\n        vm.expectRevert(IPoolManager.UnknownVault.selector);\n        vaultRouter.requestDeposit{value: gasLimit}(IAsyncVault(makeAddr(\"maliciousVault\")), amount, self, self);\n\n        bytes[] memory calls = new bytes[](2);\n        calls[0] = abi.encodeWithSelector(vaultRouter.requestDeposit.selector, vault_, amount / 2, self, self);\n        calls[1] = abi.encodeWithSelector(vaultRouter.requestDeposit.selector, vault_, amount / 2, self, self);\n\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        vaultRouter.multicall{value: gasLimit - 1}(calls);\n\n        assertEq(address(vaultRouter).balance, 0);\n        vaultRouter.multicall{value: gasLimit}(calls);\n    }\n\n    // --- helpers ---\n    function fulfillDepositRequest(AsyncVault vault, uint128 assetId, uint256 amount, address user)\n        public\n        returns (uint128 sharePayout)\n    {\n        uint128 price = 2 * 10 ** 18;\n        sharePayout = uint128(amount * 10 ** 18 / price);\n        assertApproxEqAbs(sharePayout, amount / 2, 2);\n\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(user)), assetId, uint128(amount), sharePayout\n        );\n    }\n\n    function fulfillRedeemRequest(AsyncVault vault, uint128 assetId, uint256 amount, address user)\n        public\n        returns (uint128 assetPayout)\n    {\n        uint128 price = 2 * 10 ** 18;\n        assetPayout = uint128(amount * price / 10 ** 18);\n        assertApproxEqAbs(assetPayout, amount * 2, 2);\n\n        centrifugeChain.isFulfilledRedeemRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(user)), assetId, assetPayout, uint128(amount)\n        );\n    }\n\n    function setUpMultipleVaults(uint256 amount1, uint256 amount2)\n        public\n        returns (ERC20 erc20X, ERC20 erc20Y, AsyncVault vault1, AsyncVault vault2)\n    {\n        erc20X = _newErc20(\"X's Dollar\", \"USDX\", 6);\n        erc20Y = _newErc20(\"Y's Dollar\", \"USDY\", 6);\n        vm.label(address(erc20X), \"erc20X\");\n        vm.label(address(erc20Y), \"erc20Y\");\n        (, address vault1_,) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(erc20X), 0, 0);\n        (, address vault2_,) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"2\")), address(erc20Y), 0, 0);\n        vault1 = AsyncVault(vault1_);\n        vault2 = AsyncVault(vault2_);\n        vm.label(vault1_, \"vault1\");\n        vm.label(vault2_, \"vault2\");\n\n        erc20X.mint(self, amount1);\n        erc20Y.mint(self, amount2);\n\n        erc20X.approve(address(vault1_), amount1);\n        erc20Y.approve(address(vault2_), amount2);\n\n        centrifugeChain.updateMember(vault1.poolId().raw(), vault1.scId().raw(), self, type(uint64).max);\n        centrifugeChain.updateMember(vault2.poolId().raw(), vault2.scId().raw(), self, type(uint64).max);\n    }\n\n    function testReentrancyCheck(uint256 amount) public {\n        amount = uint128(bound(amount, 4, MAX_UINT128));\n        vm.assume(amount % 2 == 0);\n\n        MockReentrantERC20Wrapper1 wrapper = new MockReentrantERC20Wrapper1(address(erc20), address(vaultRouter));\n        (, address vault_,) =\n            deployVault(VaultKind.Async, 6, fullRestrictionsHook, bytes16(bytes(\"1\")), address(wrapper), 0, 0);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        address investor = makeAddr(\"investor\");\n\n        erc20.mint(investor, amount);\n\n        // Investor locks deposit request and enables permissionless lcaiming\n        vm.startPrank(investor);\n        erc20.approve(address(vaultRouter), amount);\n        vm.expectRevert(ReentrancyProtection.UnauthorizedSender.selector);\n        vaultRouter.enableLockDepositRequest(vault, amount);\n        vm.stopPrank();\n    }\n\n    function estimateGas() internal view returns (uint256) {\n        return gateway.estimate(OTHER_CHAIN_ID, PAYLOAD_FOR_GAS_ESTIMATION);\n    }\n}\n"
    },
    "test/vaults/mocks/MockCentrifugeChain.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {BytesLib} from \"src/misc/libraries/BytesLib.sol\";\nimport {D18, d18} from \"src/misc/types/D18.sol\";\n\nimport {MessageType, MessageLib, VaultUpdateKind} from \"src/common/libraries/MessageLib.sol\";\nimport {IAdapter} from \"src/common/interfaces/IAdapter.sol\";\nimport {MessageProofLib} from \"src/common/libraries/MessageProofLib.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {PoolManager} from \"src/vaults/PoolManager.sol\";\nimport {SyncRequestManager} from \"src/vaults/SyncRequestManager.sol\";\nimport {VaultDetails} from \"src/vaults/interfaces/IPoolManager.sol\";\nimport {IBaseVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\n\ninterface AdapterLike {\n    function execute(bytes memory _message) external;\n}\n\ncontract MockCentrifugeChain is Test {\n    using CastLib for *;\n    using MessageLib for *;\n\n    IAdapter[] public adapters;\n    PoolManager public poolManager;\n    SyncRequestManager public syncRequestManager;\n\n    constructor(IAdapter[] memory adapters_, PoolManager poolManager_, SyncRequestManager syncRequestManager_) {\n        for (uint256 i = 0; i < adapters_.length; i++) {\n            adapters.push(adapters_[i]);\n        }\n        poolManager = poolManager_;\n        syncRequestManager = syncRequestManager_;\n    }\n\n    function addPool(uint64 poolId) public {\n        execute(MessageLib.NotifyPool({poolId: poolId}).serialize());\n    }\n\n    function unlinkVault(uint64 poolId, bytes16 scId, address vault) public {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(IBaseVault(vault));\n\n        execute(\n            MessageLib.UpdateContract({\n                poolId: poolId,\n                scId: scId,\n                target: bytes32(bytes20(address(poolManager))),\n                payload: MessageLib.UpdateContractVaultUpdate({\n                    vaultOrFactory: bytes32(bytes20(vault)),\n                    assetId: vaultDetails.assetId.raw(),\n                    kind: uint8(VaultUpdateKind.Unlink)\n                }).serialize()\n            }).serialize()\n        );\n    }\n\n    function linkVault(uint64 poolId, bytes16 scId, address vault) public {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(IBaseVault(vault));\n\n        execute(\n            MessageLib.UpdateContract({\n                poolId: poolId,\n                scId: scId,\n                target: bytes32(bytes20(address(poolManager))),\n                payload: MessageLib.UpdateContractVaultUpdate({\n                    vaultOrFactory: bytes32(bytes20(vault)),\n                    assetId: vaultDetails.assetId.raw(),\n                    kind: uint8(VaultUpdateKind.Link)\n                }).serialize()\n            }).serialize()\n        );\n    }\n\n    function updateMaxReserve(uint64 poolId, bytes16 scId, address vault, uint128 maxReserve) public {\n        VaultDetails memory vaultDetails = poolManager.vaultDetails(IBaseVault(vault));\n\n        execute(\n            MessageLib.UpdateContract({\n                poolId: poolId,\n                scId: scId,\n                target: bytes32(bytes20(address(syncRequestManager))),\n                payload: MessageLib.UpdateContractSyncDepositMaxReserve({\n                    assetId: vaultDetails.assetId.raw(),\n                    maxReserve: maxReserve\n                }).serialize()\n            }).serialize()\n        );\n    }\n\n    /// @dev Simulates incoming NotifyShareClass message with prepended UpdateRestrictionMember message for pool escrow\n    function addShareClass(\n        uint64 poolId,\n        bytes16 scId,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals,\n        bytes32 salt,\n        address hook\n    ) public {\n        execute(\n            MessageLib.NotifyShareClass({\n                poolId: poolId,\n                scId: scId,\n                name: tokenName,\n                symbol: tokenSymbol.toBytes32(),\n                decimals: decimals,\n                salt: salt,\n                hook: bytes32(bytes20(hook))\n            }).serialize()\n        );\n\n        updateMemberPoolEscrow(poolId, scId);\n    }\n\n    /// @dev Updates escrow as member to enable minting, burning and transfers on deposit and redeem\n    ///\n    /// @dev Implicitly called by addShareClass\n    function updateMemberPoolEscrow(uint64 poolId, bytes16 scId) public {\n        address escrow = address(poolManager.poolEscrowFactory().escrow(PoolId.wrap(poolId)));\n        updateMember(poolId, scId, escrow, type(uint64).max);\n    }\n\n    /// @dev Simulates incoming NotifyShareClass message with prepended UpdateRestrictionMember message for pool escrow\n    function addShareClass(\n        uint64 poolId,\n        bytes16 scId,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimals,\n        address hook\n    ) public {\n        execute(\n            MessageLib.NotifyShareClass({\n                poolId: poolId,\n                scId: scId,\n                name: tokenName,\n                symbol: tokenSymbol.toBytes32(),\n                decimals: decimals,\n                salt: keccak256(abi.encodePacked(poolId, scId)),\n                hook: bytes32(bytes20(hook))\n            }).serialize()\n        );\n\n        updateMemberPoolEscrow(poolId, scId);\n    }\n\n    function updateMember(uint64 poolId, bytes16 scId, address user, uint64 validUntil) public {\n        execute(\n            MessageLib.UpdateRestriction({\n                poolId: poolId,\n                scId: scId,\n                payload: MessageLib.UpdateRestrictionMember(user.toBytes32(), validUntil).serialize()\n            }).serialize()\n        );\n    }\n\n    function updateShareMetadata(uint64 poolId, bytes16 scId, string memory tokenName, string memory tokenSymbol)\n        public\n    {\n        execute(\n            MessageLib.NotifyShareMetadata({\n                poolId: poolId,\n                scId: scId,\n                name: tokenName,\n                symbol: tokenSymbol.toBytes32()\n            }).serialize()\n        );\n    }\n\n    function updateShareHook(uint64 poolId, bytes16 scId, address hook) public {\n        execute(MessageLib.UpdateShareHook({poolId: poolId, scId: scId, hook: bytes32(bytes20(hook))}).serialize());\n    }\n\n    function updatePricePoolPerShare(uint64 poolId, bytes16 scId, uint128 price, uint64 computedAt) public {\n        execute(\n            MessageLib.NotifyPricePoolPerShare({poolId: poolId, scId: scId, price: price, timestamp: computedAt})\n                .serialize()\n        );\n    }\n\n    function updatePricePoolPerAsset(uint64 poolId, bytes16 scId, uint128 assetId, uint128 price, uint64 computedAt)\n        public\n    {\n        execute(\n            MessageLib.NotifyPricePoolPerAsset({\n                poolId: poolId,\n                scId: scId,\n                assetId: assetId,\n                price: price,\n                timestamp: computedAt\n            }).serialize()\n        );\n    }\n\n    function incomingTransferShares(uint64 poolId, bytes16 scId, address destinationAddress, uint128 amount) public {\n        execute(\n            MessageLib.TransferShares({\n                poolId: poolId,\n                scId: scId,\n                receiver: destinationAddress.toBytes32(),\n                amount: amount\n            }).serialize()\n        );\n    }\n\n    function incomingScheduleUpgrade(address target) public {\n        execute(MessageLib.ScheduleUpgrade({target: bytes32(bytes20(target))}).serialize());\n    }\n\n    function incomingCancelUpgrade(address target) public {\n        execute(MessageLib.CancelUpgrade({target: bytes32(bytes20(target))}).serialize());\n    }\n\n    function freeze(uint64 poolId, bytes16 scId, address user) public {\n        execute(\n            MessageLib.UpdateRestriction({\n                poolId: poolId,\n                scId: scId,\n                payload: MessageLib.UpdateRestrictionFreeze(user.toBytes32()).serialize()\n            }).serialize()\n        );\n    }\n\n    function unfreeze(uint64 poolId, bytes16 scId, address user) public {\n        execute(\n            MessageLib.UpdateRestriction({\n                poolId: poolId,\n                scId: scId,\n                payload: MessageLib.UpdateRestrictionUnfreeze(user.toBytes32()).serialize()\n            }).serialize()\n        );\n    }\n\n    function recoverTokens(address target, address token, uint256 tokenId, address to, uint256 amount) public {\n        execute(\n            MessageLib.RecoverTokens({\n                target: bytes32(bytes20(target)),\n                token: bytes32(bytes20(token)),\n                tokenId: tokenId,\n                to: bytes32(bytes20(to)),\n                amount: amount\n            }).serialize()\n        );\n    }\n\n    function isFulfilledCancelDepositRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 assets\n    ) public {\n        execute(\n            MessageLib.FulfilledCancelDepositRequest({\n                poolId: poolId,\n                scId: scId,\n                investor: investor,\n                assetId: assetId,\n                cancelledAmount: assets\n            }).serialize()\n        );\n    }\n\n    function isFulfilledCancelRedeemRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 shares\n    ) public {\n        execute(\n            MessageLib.FulfilledCancelRedeemRequest({\n                poolId: poolId,\n                scId: scId,\n                investor: investor,\n                assetId: assetId,\n                cancelledShares: shares\n            }).serialize()\n        );\n    }\n\n    /// @dev Simulates incoming FulfilledDepositRequest with prepended ApprovedDeposits message\n    function isFulfilledDepositRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 assets,\n        uint128 shares\n    ) public {\n        // NOTE: Currently, hardcoding pricePoolPerAsset to 1\n        isApprovedDeposits(poolId, scId, assetId, assets, d18(1, 1));\n        isIssuedShares(poolId, scId, shares, d18(1, 1));\n\n        execute(\n            MessageLib.FulfilledDepositRequest({\n                poolId: poolId,\n                scId: scId,\n                investor: investor,\n                assetId: assetId,\n                assetAmount: assets,\n                shareAmount: shares\n            }).serialize()\n        );\n    }\n\n    /// @dev Simulates incoming FulfilledRedeemRequest with prepended RevokedShares message\n    function isFulfilledRedeemRequest(\n        uint64 poolId,\n        bytes16 scId,\n        bytes32 investor,\n        uint128 assetId,\n        uint128 assets,\n        uint128 shares\n    ) public {\n        // NOTE: Currently hard coding pricePoolPerShare to 1\n        isRevokedShares(poolId, scId, assetId, assets, shares, d18(1, 1));\n        execute(\n            MessageLib.FulfilledRedeemRequest({\n                poolId: poolId,\n                scId: scId,\n                investor: investor,\n                assetId: assetId,\n                assetAmount: assets,\n                shareAmount: shares\n            }).serialize()\n        );\n    }\n\n    /// @dev Implicitly called by isFulfilledDepositRequest\n    function isApprovedDeposits(uint64 poolId, bytes16 scId, uint128 assetId, uint128 assets, D18 pricePoolPerAsset)\n        public\n    {\n        execute(\n            MessageLib.ApprovedDeposits({\n                poolId: poolId,\n                scId: scId,\n                assetId: assetId,\n                assetAmount: assets,\n                pricePoolPerAsset: pricePoolPerAsset.raw()\n            }).serialize()\n        );\n    }\n\n    /// @dev Impicitly called by isFulfilledDepositRequest\n    function isIssuedShares(uint64 poolId, bytes16 scId, uint128 shares, D18 pricePoolPerShare) public {\n        execute(\n            MessageLib.IssuedShares({\n                poolId: poolId,\n                scId: scId,\n                shareAmount: shares,\n                pricePoolPerShare: pricePoolPerShare.raw()\n            }).serialize()\n        );\n    }\n\n    /// @dev Implicitly called by isFulfilledRedeemRequest\n    function isRevokedShares(\n        uint64 poolId,\n        bytes16 scId,\n        uint128 assetId,\n        uint128 assets,\n        uint128 shareAmount,\n        D18 pricePoolPerShare\n    ) public {\n        execute(\n            MessageLib.RevokedShares({\n                poolId: poolId,\n                scId: scId,\n                assetId: assetId,\n                assetAmount: assets,\n                shareAmount: shareAmount,\n                pricePoolPerShare: pricePoolPerShare.raw()\n            }).serialize()\n        );\n    }\n\n    function execute(bytes memory message) public {\n        bytes memory proof = MessageProofLib.serializeMessageProof(keccak256(message));\n        for (uint256 i = 0; i < adapters.length; i++) {\n            AdapterLike(address(adapters[i])).execute(i == 0 ? message : proof);\n        }\n    }\n}\n"
    },
    "test/vaults/mocks/MockERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {IERC20Wrapper, IERC20Metadata} from \"src/misc/interfaces/IERC20.sol\";\nimport {Mock} from \"test/common/mocks/Mock.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockERC20Wrapper is ERC20, Mock, IERC20Wrapper {\n    address public underlying;\n    bool shouldDepositFail;\n    bool shouldWithdrawFail;\n\n    constructor(address underlying_) ERC20(IERC20Metadata(underlying_).decimals()) {\n        underlying = underlying_;\n    }\n\n    function depositFor(address account, uint256 value) external returns (bool) {\n        if (method_fail[\"depositFor\"]) return false;\n        require(\n            IERC20Metadata(underlying).transferFrom(msg.sender, address(this), value),\n            \"MockERC20Wrapper/failed-transfer\"\n        );\n\n        // Obviously unsafe, just for testing purposes\n        _setBalance(account, _balanceOf(account) + value);\n        totalSupply = totalSupply + value;\n        emit Transfer(address(0), account, value);\n\n        return true;\n    }\n\n    function withdrawTo(address account, uint256 value) external returns (bool) {\n        if (method_fail[\"withdrawTo\"]) return false;\n        _setBalance(msg.sender, _balanceOf(msg.sender) - value);\n        totalSupply = totalSupply - value;\n\n        IERC20Metadata(underlying).transfer(account, value);\n        return true;\n    }\n}\n"
    },
    "test/vaults/mocks/MockFullRestrictions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/common/mocks/Mock.sol\";\nimport \"src/hooks/FullRestrictions.sol\";\n\ncontract MockFullRestrictions is FullRestrictions, Mock {\n    constructor(address root_, address deployer) FullRestrictions(root_, deployer) {}\n\n    function onERC20Transfer(address from, address to, uint256 value, HookData calldata hookData)\n        public\n        override(FullRestrictions)\n        returns (bytes4)\n    {\n        require(checkERC20Transfer(from, to, value, hookData), TransferBlocked());\n\n        values_address[\"onERC20Transfer_from\"] = from;\n        values_address[\"onERC20Transfer_to\"] = to;\n        values_uint256[\"onERC20Transfer_value\"] = value;\n\n        return bytes4(keccak256(\"onERC20Transfer(address,address,uint256,(bytes16,bytes16))\"));\n    }\n}\n"
    },
    "test/vaults/mocks/MockHook.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/common/mocks/Mock.sol\";\n\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\n\ncontract MockHook is Mock {\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return interfaceId == type(IHook).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    function updateRestriction(address token, bytes memory update) external {}\n}\n"
    },
    "test/vaults/mocks/MockReentrantERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {IERC20Wrapper, IERC20Metadata} from \"src/misc/interfaces/IERC20.sol\";\nimport {IVaultRouter} from \"src/vaults/interfaces/IVaultRouter.sol\";\nimport {Mock} from \"test/common/mocks/Mock.sol\";\nimport \"forge-std/Test.sol\";\n\ncontract MockReentrantERC20Wrapper1 is ERC20, Mock, IERC20Wrapper {\n    address public underlying;\n    bool shouldDepositFail;\n    bool shouldWithdrawFail;\n\n    IVaultRouter public reentrancyTarget;\n\n    constructor(address underlying_, address reentrancyTarget_) ERC20(IERC20Metadata(underlying_).decimals()) {\n        underlying = underlying_;\n        reentrancyTarget = IVaultRouter(reentrancyTarget_);\n    }\n\n    function depositFor(address account, uint256 value) external returns (bool) {\n        reentrancyTarget.wrap(makeAddr(\"Vault\"), value, makeAddr(\"Receiver\"), account);\n        return true;\n    }\n\n    function withdrawTo(address, /* account */ uint256 /* value */ ) external pure returns (bool) {\n        return true;\n    }\n}\n\ncontract MockReentrantERC20Wrapper2 is ERC20, Mock, IERC20Wrapper {\n    address public underlying;\n    bool shouldDepositFail;\n    bool shouldWithdrawFail;\n\n    IVaultRouter public reentrancyTarget;\n\n    constructor(address underlying_, address reentrancyTarget_) ERC20(IERC20Metadata(underlying_).decimals()) {\n        underlying = underlying_;\n        reentrancyTarget = IVaultRouter(reentrancyTarget_);\n    }\n\n    function depositFor(address, /* account */ uint256 /* value */ ) external returns (bool) {\n        bytes[] memory calls = new bytes[](0);\n        reentrancyTarget.multicall(calls);\n        return true;\n    }\n\n    function withdrawTo(address, /* account */ uint256 /* value */ ) external pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "test/vaults/mocks/MockSafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {ISafe} from \"src/common/Guardian.sol\";\nimport {Mock} from \"test/common/mocks/Mock.sol\";\n\ncontract MockSafe is Mock, ISafe {\n    constructor(address[] memory owners, uint256 threshold) {\n        values_uint256[\"threshold\"] = threshold;\n        for (uint256 i = 0; i < owners.length; i++) {\n            addOwner(owners[i]);\n        }\n    }\n\n    function addOwner(address owner) public {\n        values_mapping_address_uint[\"owners\"][owner] = 1;\n    }\n\n    function removeOwner(address owner) public {\n        values_mapping_address_uint[\"owners\"][owner] = 0;\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return values_mapping_address_uint[\"owners\"][owner] == 1;\n    }\n\n    // Added to be ignored in coverage report\n    function test() public {}\n}\n"
    },
    "test/vaults/unit/AsyncVault.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"test/vaults/BaseTest.sol\";\n\nimport \"src/misc/interfaces/IERC7575.sol\";\nimport \"src/misc/interfaces/IERC7540.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {MathLib} from \"src/misc/libraries/MathLib.sol\";\n\nimport {IBaseVault, IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IBaseRequestManager} from \"src/vaults/interfaces/investments/IBaseRequestManager.sol\";\n\ncontract AsyncVaultTest is BaseTest {\n    // Deployment\n    function testDeployment(bytes16 scId, uint128 assetId, address nonWard) public {\n        vm.assume(nonWard != address(root) && nonWard != address(this) && nonWard != address(asyncRequestManager));\n        vm.assume(assetId > 0);\n\n        (uint64 poolId, address vault_,) = deployVault(VaultKind.Async, erc20.decimals(), scId);\n        AsyncVault vault = AsyncVault(vault_);\n\n        // values set correctly\n        assertEq(address(vault.manager()), address(asyncRequestManager));\n        assertEq(vault.asset(), address(erc20));\n        assertEq(vault.scId().raw(), scId);\n        IShareToken token = poolManager.shareToken(PoolId.wrap(poolId), ShareClassId.wrap(scId));\n        assertEq(address(vault.share()), address(token));\n\n        // permissions set correctly\n        assertEq(vault.wards(address(root)), 1);\n        assertEq(vault.wards(address(asyncRequestManager)), 1);\n        assertEq(vault.wards(nonWard), 0);\n    }\n\n    // --- Administration ---\n    function testFile() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        vault.file(\"manager\", self);\n\n        root.relyContract(vault_, self);\n        vault.file(\"manager\", self);\n\n        address random = makeAddr(\"random\");\n        vault.file(\"manager\", random);\n        assertEq(address(vault.manager()), random);\n\n        vault.file(\"asyncRedeemManager\", random);\n        assertEq(address(vault.asyncRedeemManager()), random);\n\n        vm.expectRevert(IBaseVault.FileUnrecognizedParam.selector);\n        vault.file(\"random\", self);\n    }\n\n    // --- uint128 type checks ---\n    /// @dev Make sure all function calls would fail when overflow uint128\n    /// @dev requestRedeem is not checked because the share class token supply is already capped at uint128\n    function testAssertUint128(uint256 amount) public {\n        vm.assume(amount > MAX_UINT128); // amount has to overflow UINT128\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n\n        vm.expectRevert(MathLib.Uint128_Overflow.selector);\n        vault.convertToShares(amount);\n\n        vm.expectRevert(MathLib.Uint128_Overflow.selector);\n        vault.convertToAssets(amount);\n\n        vm.expectRevert(IBaseRequestManager.ExceedsMaxDeposit.selector);\n        vault.deposit(amount, randomUser, self);\n\n        vm.expectRevert(MathLib.Uint128_Overflow.selector);\n        vault.mint(amount, randomUser);\n\n        vm.expectRevert(MathLib.Uint128_Overflow.selector);\n        vault.withdraw(amount, randomUser, self);\n\n        vm.expectRevert(IAsyncRequestManager.ExceedsMaxRedeem.selector);\n        vault.redeem(amount, randomUser, self);\n\n        erc20.mint(address(this), amount);\n        vm.expectRevert(MathLib.Uint128_Overflow.selector);\n        vault.requestDeposit(amount, self, self);\n    }\n\n    // --- erc165 checks ---\n    function testERC165Support(bytes4 unsupportedInterfaceId) public {\n        bytes4 erc165 = 0x01ffc9a7;\n        bytes4 erc7575Vault = 0x2f0a18c5;\n        bytes4 asyncVaultOperator = 0xe3bc4e65;\n        bytes4 asyncVaultDeposit = 0xce3bbe50;\n        bytes4 asyncVaultRedeem = 0x620ee8e4;\n        bytes4 asyncVaultCancelDeposit = 0x8bf840e3;\n        bytes4 asyncVaultCancelRedeem = 0xe76cffc7;\n        bytes4 erc7741 = 0xa9e50872;\n        bytes4 erc7714 = 0x78d77ecb;\n\n        vm.assume(\n            unsupportedInterfaceId != erc165 && unsupportedInterfaceId != erc7575Vault\n                && unsupportedInterfaceId != asyncVaultOperator && unsupportedInterfaceId != asyncVaultDeposit\n                && unsupportedInterfaceId != asyncVaultRedeem && unsupportedInterfaceId != asyncVaultCancelDeposit\n                && unsupportedInterfaceId != asyncVaultCancelRedeem && unsupportedInterfaceId != erc7741\n                && unsupportedInterfaceId != erc7714\n        );\n\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n\n        assertEq(type(IERC165).interfaceId, erc165);\n        assertEq(type(IERC7575).interfaceId, erc7575Vault);\n        assertEq(type(IERC7540Operator).interfaceId, asyncVaultOperator);\n        assertEq(type(IERC7540Deposit).interfaceId, asyncVaultDeposit);\n        assertEq(type(IERC7540Redeem).interfaceId, asyncVaultRedeem);\n        assertEq(type(IERC7887Deposit).interfaceId, asyncVaultCancelDeposit);\n        assertEq(type(IERC7887Redeem).interfaceId, asyncVaultCancelRedeem);\n        assertEq(type(IERC7741).interfaceId, erc7741);\n        assertEq(type(IERC7714).interfaceId, erc7714);\n\n        assertEq(vault.supportsInterface(erc165), true);\n        assertEq(vault.supportsInterface(erc7575Vault), true);\n        assertEq(vault.supportsInterface(asyncVaultOperator), true);\n        assertEq(vault.supportsInterface(asyncVaultDeposit), true);\n        assertEq(vault.supportsInterface(asyncVaultRedeem), true);\n        assertEq(vault.supportsInterface(asyncVaultCancelDeposit), true);\n        assertEq(vault.supportsInterface(asyncVaultCancelRedeem), true);\n        assertEq(vault.supportsInterface(erc7741), true);\n        assertEq(vault.supportsInterface(erc7714), true);\n\n        assertEq(vault.supportsInterface(unsupportedInterfaceId), false);\n    }\n\n    // --- preview checks ---\n    function testPreviewReverts(uint256 amount) public {\n        vm.assume(amount > MAX_UINT128); // amount has to overflow UINT128\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n\n        vm.expectRevert(bytes(\"\"));\n        vault.previewDeposit(amount);\n\n        vm.expectRevert(bytes(\"\"));\n        vault.previewRedeem(amount);\n\n        vm.expectRevert(bytes(\"\"));\n        vault.previewMint(amount);\n\n        vm.expectRevert(bytes(\"\"));\n        vault.previewWithdraw(amount);\n    }\n}\n"
    },
    "test/vaults/unit/Escrow.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\nimport {MockERC6909} from \"test/misc/mocks/MockERC6909.sol\";\n\nimport {ERC20} from \"src/misc/ERC20.sol\";\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {Escrow, PoolEscrow} from \"src/vaults/Escrow.sol\";\nimport {IEscrow, IPoolEscrow} from \"src/vaults/interfaces/IEscrow.sol\";\n\ncontract EscrowTestBase is Test {\n    address spender = makeAddr(\"spender\");\n    address randomUser = makeAddr(\"randomUser\");\n    Escrow escrow = new Escrow(address(this));\n    ERC20 erc20 = new ERC20(6);\n    MockERC6909 erc6909 = new MockERC6909();\n\n    function _mint(address escrow_, uint256 tokenId, uint256 amount) internal {\n        if (tokenId == 0) {\n            erc20.mint(escrow_, amount);\n        } else {\n            erc6909.mint(escrow_, tokenId, amount);\n        }\n    }\n\n    function _asset(uint256 tokenId) internal view returns (address) {\n        return tokenId == 0 ? address(erc20) : address(erc6909);\n    }\n}\n\ncontract EscrowTestERC20 is EscrowTestBase {}\n\ncontract EscrowTestERC6909 is EscrowTestBase {}\n\ncontract PoolEscrowTestBase is EscrowTestBase {\n    function _testDeposit(PoolId poolId, ShareClassId scId, uint256 tokenId) internal {\n        address asset = _asset(tokenId);\n        PoolEscrow escrow = new PoolEscrow(poolId, address(this));\n\n        vm.expectEmit();\n        emit IPoolEscrow.Deposit(asset, tokenId, poolId, scId, 300);\n        escrow.deposit(scId, asset, tokenId, 300);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 300, \"holdings should be 300 after deposit\");\n\n        vm.expectEmit();\n        emit IPoolEscrow.Deposit(asset, tokenId, poolId, scId, 200);\n        escrow.deposit(scId, asset, tokenId, 200);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 500, \"holdings should be 500 after deposit\");\n    }\n\n    function _testReserveIncrease(PoolId poolId, ShareClassId scId, uint256 tokenId) internal {\n        address asset = _asset(tokenId);\n        PoolEscrow escrow = new PoolEscrow(poolId, address(this));\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        escrow.reserveIncrease(scId, asset, tokenId, 100);\n\n        vm.expectEmit();\n        emit IPoolEscrow.IncreaseReserve(asset, tokenId, poolId, scId, 100, 100);\n        escrow.reserveIncrease(scId, asset, tokenId, 100);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"Still zero, nothing is in holdings\");\n\n        _mint(address(escrow), tokenId, 300);\n        escrow.deposit(scId, asset, tokenId, 100);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"100 - 100 = 0\");\n\n        escrow.deposit(scId, asset, tokenId, 200);\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 200, \"300 - 100 = 200\");\n    }\n\n    function _testReserveDecrease(PoolId poolId, ShareClassId scId, uint256 tokenId) internal {\n        address asset = _asset(tokenId);\n        PoolEscrow escrow = new PoolEscrow(poolId, address(this));\n\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        escrow.reserveIncrease(scId, asset, tokenId, 100);\n\n        escrow.reserveIncrease(scId, asset, tokenId, 100);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"Still zero, nothing is in holdings\");\n\n        _mint(address(escrow), tokenId, 300);\n        escrow.deposit(scId, asset, tokenId, 100);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"100 - 100 = 0\");\n\n        escrow.deposit(scId, asset, tokenId, 200);\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 200, \"300 - 100 = 200\");\n\n        vm.expectRevert(IPoolEscrow.InsufficientReservedAmount.selector);\n        escrow.reserveDecrease(scId, asset, tokenId, 200);\n\n        vm.expectEmit();\n        emit IPoolEscrow.DecreaseReserve(asset, tokenId, poolId, scId, 100, 0);\n        escrow.reserveDecrease(scId, asset, tokenId, 100);\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 300, \"300 - 0 = 300\");\n    }\n\n    function _testWithdraw(PoolId poolId, ShareClassId scId, uint256 tokenId) internal {\n        address asset = _asset(tokenId);\n        PoolEscrow escrow = new PoolEscrow(poolId, address(this));\n\n        _mint(address(escrow), tokenId, 1000);\n        escrow.deposit(scId, asset, tokenId, 1000);\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 1000, \"initial holdings should be 1000\");\n\n        escrow.reserveIncrease(scId, asset, tokenId, 500);\n\n        vm.expectRevert(abi.encodeWithSelector(IEscrow.InsufficientBalance.selector, asset, tokenId, 600, 500));\n        escrow.withdraw(scId, asset, tokenId, 600);\n\n        vm.expectEmit();\n        emit IPoolEscrow.Withdraw(asset, tokenId, poolId, scId, 500);\n        escrow.withdraw(scId, asset, tokenId, 500);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0);\n    }\n\n    function _testAvailableBalanceOf(PoolId poolId, ShareClassId scId, uint256 tokenId) internal {\n        address asset = _asset(tokenId);\n        PoolEscrow escrow = new PoolEscrow(poolId, address(this));\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"Default available balance should be zero\");\n\n        _mint(address(escrow), tokenId, 500);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"Available balance needs deposit first.\");\n\n        escrow.deposit(scId, asset, tokenId, 500);\n\n        escrow.reserveIncrease(scId, asset, tokenId, 200);\n\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 300, \"Should be 300 after reserve increase\");\n\n        escrow.reserveIncrease(scId, asset, tokenId, 300);\n        assertEq(escrow.availableBalanceOf(scId, asset, tokenId), 0, \"Should be zero if pendingWithdraw >= holdings\");\n    }\n}\n\ncontract PoolEscrowTestERC20 is PoolEscrowTestBase {\n    uint256 tokenId = 0;\n\n    function testDeposit(PoolId poolId, ShareClassId scId) public {\n        _testDeposit(poolId, scId, tokenId);\n    }\n\n    function testReserveIncrease(PoolId poolId, ShareClassId scId) public {\n        _testReserveIncrease(poolId, scId, tokenId);\n    }\n\n    function testReserveDecrease(PoolId poolId, ShareClassId scId) public {\n        _testReserveDecrease(poolId, scId, tokenId);\n    }\n\n    function testWithdraw(PoolId poolId, ShareClassId scId) public {\n        _testWithdraw(poolId, scId, tokenId);\n    }\n\n    function testAvailableBalanceOf(PoolId poolId, ShareClassId scId) public {\n        _testAvailableBalanceOf(poolId, scId, tokenId);\n    }\n}\n\ncontract PoolEscrowTestERC6909 is PoolEscrowTestBase {\n    function testDeposit(PoolId poolId, ShareClassId scId, uint8 tokenId_) public {\n        uint256 tokenId = uint256(bound(tokenId_, 2, 18));\n\n        _testDeposit(poolId, scId, tokenId);\n\n        assertEq(erc6909.balanceOf(address(escrow), tokenId), 0, \"Escrow should not hold any tokens after noting\");\n    }\n\n    function testReserveIncrease(PoolId poolId, ShareClassId scId, uint8 tokenId_) public {\n        uint256 tokenId = uint256(bound(tokenId_, 2, 18));\n\n        _testReserveIncrease(poolId, scId, tokenId);\n    }\n\n    function testReserveDecrease(PoolId poolId, ShareClassId scId, uint8 tokenId_) public {\n        uint256 tokenId = uint256(bound(tokenId_, 2, 18));\n\n        _testReserveDecrease(poolId, scId, tokenId);\n    }\n\n    function testWithdraw(PoolId poolId, ShareClassId scId, uint8 tokenId_) public {\n        uint256 tokenId = uint256(bound(tokenId_, 2, 18));\n\n        _testWithdraw(poolId, scId, tokenId);\n    }\n\n    function testAvailableBalanceOf(PoolId poolId, ShareClassId scId, uint8 tokenId_) public {\n        uint256 tokenId = uint256(bound(tokenId_, 2, 18));\n\n        _testAvailableBalanceOf(poolId, scId, tokenId);\n    }\n}\n"
    },
    "test/vaults/unit/VaultRouter.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MockERC6909} from \"test/misc/mocks/MockERC6909.sol\";\nimport {MockERC20Wrapper} from \"test/vaults/mocks/MockERC20Wrapper.sol\";\nimport \"test/vaults/BaseTest.sol\";\n\nimport \"src/misc/interfaces/IERC20.sol\";\nimport \"src/misc/interfaces/IERC7575.sol\";\nimport \"src/misc/interfaces/IERC7540.sol\";\nimport {CastLib} from \"src/misc/libraries/CastLib.sol\";\nimport {SafeTransferLib} from \"src/misc/libraries/SafeTransferLib.sol\";\n\nimport {MessageLib} from \"src/common/libraries/MessageLib.sol\";\nimport {IGateway} from \"src/common/interfaces/IGateway.sol\";\n\nimport {VaultRouter} from \"src/vaults/VaultRouter.sol\";\nimport {IVaultRouter} from \"src/vaults/interfaces/IVaultRouter.sol\";\nimport {IPoolManager} from \"src/vaults/interfaces/IPoolManager.sol\";\n\nimport {IAsyncRequestManager} from \"src/vaults/interfaces/investments/IAsyncRequestManager.sol\";\nimport {IAsyncVault} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {SyncDepositVault} from \"src/vaults/SyncDepositVault.sol\";\n\ninterface Authlike {\n    function rely(address) external;\n}\n\ncontract ERC20WrapperFake {\n    address public underlying;\n\n    constructor(address underlying_) {\n        underlying = underlying_;\n    }\n}\n\ncontract MaliciousVault {\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return interfaceId == type(IERC7540Deposit).interfaceId;\n    }\n}\n\ncontract NonAsyncVault {\n    function supportsInterface(bytes4) public pure returns (bool) {\n        return false;\n    }\n}\n\ncontract VaultRouterTest is BaseTest {\n    using CastLib for *;\n    using MessageLib for *;\n\n    uint16 constant CHAIN_ID = 1;\n    uint256 constant GAS_BUFFER = 10 gwei;\n    bytes PAYLOAD_FOR_GAS_ESTIMATION = MessageLib.NotifyPool(1).serialize();\n\n    function testInitialization() public {\n        // redeploying within test to increase coverage\n        new VaultRouter(address(routerEscrow), gateway, poolManager, messageDispatcher, address(this));\n\n        assertEq(address(vaultRouter.escrow()), address(routerEscrow));\n        assertEq(address(vaultRouter.gateway()), address(gateway));\n        assertEq(address(vaultRouter.poolManager()), address(poolManager));\n    }\n\n    function testGetVault() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        assertEq(vaultRouter.getVault(vault.poolId(), vault.scId(), address(erc20)), vault_);\n    }\n\n    function testRequestDeposit() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n        uint256 amount = 100 * 10 ** 18;\n        erc20.mint(self, amount);\n        erc20.approve(address(vault_), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        uint256 gas = estimateGas();\n\n        vm.expectRevert(IAsyncVault.InvalidOwner.selector);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        vaultRouter.enable(vault);\n\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        vaultRouter.requestDeposit{value: gas - 1}(vault, amount, self, self);\n\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n    }\n\n    function testRouterSyncDeposit() public {\n        (uint64 poolId, address vault_,) = deploySimpleVault(VaultKind.SyncDepositAsyncRedeem);\n        vm.label(vault_, \"vault\");\n        SyncDepositVault vault = SyncDepositVault(vault_);\n        uint256 amount = 100 * 10 ** 18;\n        erc20.mint(self, amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        uint256 gas = estimateGas();\n\n        erc20.approve(address(vault_), amount);\n        vm.expectRevert(SafeTransferLib.SafeTransferFromFailed.selector);\n        vaultRouter.deposit{value: gas}(vault, amount, self, self);\n\n        erc20.approve(address(vaultRouter), amount);\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        vaultRouter.deposit{value: gas - 1}(vault, amount, self, self);\n\n        erc20.approve(address(vaultRouter), amount);\n        vaultRouter.deposit{value: gas}(vault, amount, self, self);\n        assertEq(erc20.balanceOf(address(balanceSheet.poolEscrowProvider().escrow(PoolId.wrap(poolId)))), amount);\n    }\n\n    function testLockDepositRequests() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        uint256 amount = 100 * 10 ** 18;\n        assertEq(erc20.balanceOf(address(routerEscrow)), 0);\n\n        erc20.mint(self, amount);\n        erc20.approve(address(vaultRouter), amount);\n\n        IAsyncVault maliciousVault = IAsyncVault(address(new MaliciousVault()));\n        vm.expectRevert(IPoolManager.UnknownVault.selector);\n        vaultRouter.lockDepositRequest(maliciousVault, amount, self, self);\n\n        IAsyncVault nonAsyncVault = IAsyncVault(address(new NonAsyncVault()));\n        vm.expectRevert(IVaultRouter.NonAsyncVault.selector);\n        vaultRouter.lockDepositRequest(nonAsyncVault, amount, self, self);\n\n        vaultRouter.lockDepositRequest(vault, amount, self, self);\n\n        assertEq(erc20.balanceOf(address(routerEscrow)), amount);\n    }\n\n    function testUnlockDepositRequests() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        uint256 amount = 100 * 10 ** 18;\n\n        erc20.mint(self, amount);\n        erc20.approve(address(vaultRouter), amount);\n\n        vm.expectRevert(IVaultRouter.NoLockedBalance.selector);\n        vaultRouter.unlockDepositRequest(vault, self);\n\n        vaultRouter.lockDepositRequest(vault, amount, self, self);\n        assertEq(erc20.balanceOf(address(routerEscrow)), amount);\n        assertEq(erc20.balanceOf(self), 0);\n        vaultRouter.unlockDepositRequest(vault, self);\n        assertEq(erc20.balanceOf(address(routerEscrow)), 0);\n        assertEq(erc20.balanceOf(self), amount);\n    }\n\n    function testCancelDepositRequest() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n\n        uint256 amount = 100 * 10 ** 18;\n        assertEq(erc20.balanceOf(address(routerEscrow)), 0);\n\n        erc20.mint(self, amount);\n        erc20.approve(address(vaultRouter), amount);\n\n        vaultRouter.enable(vault);\n        vaultRouter.lockDepositRequest(vault, amount, self, self);\n        assertEq(erc20.balanceOf(address(routerEscrow)), amount);\n        assertEq(vault.pendingCancelDepositRequest(0, self), false);\n\n        uint256 fuel = estimateGas();\n        vm.deal(address(this), 10 ether);\n\n        vm.expectRevert(IAsyncRequestManager.NoPendingRequest.selector);\n        vaultRouter.cancelDepositRequest{value: fuel}(vault);\n\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        vaultRouter.executeLockedDepositRequest{value: fuel}(vault, self);\n        assertEq(vault.pendingDepositRequest(0, self), amount);\n\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        vaultRouter.cancelDepositRequest{value: 0}(vault);\n\n        vaultRouter.cancelDepositRequest{value: fuel}(vault);\n        assertTrue(vault.pendingCancelDepositRequest(0, self));\n    }\n\n    function testClaimCancelDepositRequest() public {\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n\n        uint256 amount = 100 * 10 ** 18;\n\n        erc20.mint(self, amount);\n        erc20.approve(address(vault_), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n\n        uint256 gas = estimateGas() + GAS_BUFFER;\n        vaultRouter.enable(vault);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n\n        vaultRouter.cancelDepositRequest{value: gas}(vault);\n        assertEq(vault.pendingCancelDepositRequest(0, self), true);\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n        centrifugeChain.isFulfilledCancelDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), self.toBytes32(), assetId, uint128(amount)\n        );\n        assertEq(vault.claimableCancelDepositRequest(0, self), amount);\n\n        address nonMember = makeAddr(\"nonMember\");\n        vm.prank(nonMember);\n        vm.expectRevert(IVaultRouter.InvalidSender.selector);\n        vaultRouter.claimCancelDepositRequest(vault, nonMember, self);\n\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vaultRouter.claimCancelDepositRequest(vault, nonMember, self);\n\n        vaultRouter.claimCancelDepositRequest(vault, self, self);\n        assertEq(erc20.balanceOf(address(globalEscrow)), 0);\n        assertEq(erc20.balanceOf(self), amount);\n    }\n\n    function testRequestRedeem() external {\n        // Deposit first\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n        uint256 amount = 100 * 10 ** 18;\n        erc20.mint(self, amount);\n        erc20.approve(address(vault_), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        uint256 gas = estimateGas();\n        vaultRouter.enable(vault);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        IERC20 share = IERC20(address(vault.share()));\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, uint128(amount), uint128(amount)\n        );\n        vault.deposit(amount, self, self);\n        assertEq(share.balanceOf(address(self)), amount);\n\n        // Then redeem\n        share.approve(address(vaultRouter), amount);\n\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        vaultRouter.requestRedeem{value: gas - 1}(vault, amount, self, self);\n\n        vaultRouter.requestRedeem{value: gas}(vault, amount, self, self);\n        assertEq(share.balanceOf(address(self)), 0);\n    }\n\n    function testCancelRedeemRequest() public {\n        // Deposit first\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n        uint256 amount = 100 * 10 ** 18;\n        erc20.mint(self, amount);\n        erc20.approve(address(vault_), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        uint256 gas = estimateGas();\n        vaultRouter.enable(vault);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        IERC20 share = IERC20(address(vault.share()));\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, uint128(amount), uint128(amount)\n        );\n        vault.deposit(amount, self, self);\n        assertEq(share.balanceOf(address(self)), amount);\n\n        // Then redeem\n        share.approve(address(vaultRouter), amount);\n        vaultRouter.requestRedeem{value: gas}(vault, amount, self, self);\n        assertEq(share.balanceOf(address(self)), 0);\n\n        vm.deal(address(this), 10 ether);\n\n        vm.expectRevert(IGateway.NotEnoughTransactionGas.selector);\n        vaultRouter.cancelRedeemRequest{value: gas - 1}(vault);\n\n        vaultRouter.cancelRedeemRequest{value: gas}(vault);\n        assertEq(vault.pendingCancelRedeemRequest(0, self), true);\n    }\n\n    function testClaimCancelRedeemRequest() public {\n        // Deposit first\n        (, address vault_, uint128 assetId) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n        uint256 amount = 100 * 10 ** 18;\n        erc20.mint(self, amount);\n        erc20.approve(address(vault_), amount);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n        uint256 gas = estimateGas() + GAS_BUFFER;\n        vaultRouter.enable(vault);\n        vaultRouter.requestDeposit{value: gas}(vault, amount, self, self);\n        IERC20 share = IERC20(address(vault.share()));\n        centrifugeChain.isFulfilledDepositRequest(\n            vault.poolId().raw(), vault.scId().raw(), bytes32(bytes20(self)), assetId, uint128(amount), uint128(amount)\n        );\n        vault.deposit(amount, self, self);\n        assertEq(share.balanceOf(address(self)), amount);\n\n        // Then redeem\n        share.approve(vault_, amount);\n        share.approve(address(vaultRouter), amount);\n        vaultRouter.requestRedeem{value: gas}(vault, amount, self, self);\n        assertEq(share.balanceOf(address(self)), 0);\n\n        vaultRouter.cancelRedeemRequest{value: gas}(vault);\n        assertEq(vault.pendingCancelRedeemRequest(0, self), true);\n\n        centrifugeChain.isFulfilledCancelRedeemRequest(\n            vault.poolId().raw(), vault.scId().raw(), self.toBytes32(), assetId, uint128(amount)\n        );\n\n        address sender = makeAddr(\"maliciousUser\");\n        vm.prank(sender);\n        vm.expectRevert(IVaultRouter.InvalidSender.selector);\n        vaultRouter.claimCancelRedeemRequest(vault, sender, self);\n\n        vaultRouter.claimCancelRedeemRequest(vault, self, self);\n        assertEq(share.balanceOf(address(self)), amount);\n    }\n\n    function testPermit() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n\n        bytes32 PERMIT_TYPEHASH =\n            keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n        uint256 privateKey = 0xBEEF;\n        address owner = vm.addr(privateKey);\n        vm.label(owner, \"owner\");\n        vm.label(address(vaultRouter), \"spender\");\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n            privateKey,\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    erc20.DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, address(vaultRouter), 1e18, 0, block.timestamp))\n                )\n            )\n        );\n\n        vm.prank(owner);\n        vaultRouter.permit(address(erc20), address(vaultRouter), 1e18, block.timestamp, v, r, s);\n\n        assertEq(erc20.allowance(owner, address(vaultRouter)), 1e18);\n        assertEq(erc20.nonces(owner), 1);\n    }\n\n    function testEnableAndDisable() public {\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        AsyncVault vault = AsyncVault(vault_);\n        vm.label(vault_, \"vault\");\n\n        assertFalse(AsyncVault(vault_).isOperator(self, address(vaultRouter)));\n        assertEq(vaultRouter.isEnabled(vault, self), false);\n        vaultRouter.enable(vault);\n        assertTrue(AsyncVault(vault_).isOperator(self, address(vaultRouter)));\n        assertEq(vaultRouter.isEnabled(vault, self), true);\n        vaultRouter.disable(vault);\n        assertFalse(AsyncVault(vault_).isOperator(self, address(vaultRouter)));\n        assertEq(vaultRouter.isEnabled(vault, self), false);\n    }\n\n    function testWrap() public {\n        uint256 amount = 150 * 10 ** 18;\n        uint256 balance = 100 * 10 ** 18;\n        address receiver = makeAddr(\"receiver\");\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n\n        vm.expectRevert(IVaultRouter.InvalidOwner.selector);\n        vaultRouter.wrap(address(wrapper), amount, receiver, makeAddr(\"ownerIsNeitherCallerNorRouter\"));\n\n        vm.expectRevert(IVaultRouter.ZeroBalance.selector);\n        vaultRouter.wrap(address(wrapper), amount, receiver, self);\n\n        erc20.mint(self, balance);\n        erc20.approve(address(vaultRouter), amount);\n        wrapper.setFail(\"depositFor\", true);\n        vm.expectRevert(IVaultRouter.WrapFailed.selector);\n        vaultRouter.wrap(address(wrapper), amount, receiver, self);\n\n        wrapper.setFail(\"depositFor\", false);\n        vaultRouter.wrap(address(wrapper), amount, receiver, self);\n        assertEq(wrapper.balanceOf(receiver), balance);\n        assertEq(erc20.balanceOf(self), 0);\n\n        erc20.mint(address(vaultRouter), balance);\n        vaultRouter.wrap(address(wrapper), amount, receiver, address(vaultRouter));\n        assertEq(wrapper.balanceOf(receiver), 200 * 10 ** 18);\n        assertEq(erc20.balanceOf(address(vaultRouter)), 0);\n    }\n\n    function testUnwrap() public {\n        uint256 amount = 150 * 10 ** 18;\n        uint256 balance = 100 * 10 ** 18;\n        MockERC20Wrapper wrapper = new MockERC20Wrapper(address(erc20));\n        erc20.mint(self, balance);\n        erc20.approve(address(vaultRouter), amount);\n\n        vm.expectRevert(IVaultRouter.ZeroBalance.selector);\n        vaultRouter.unwrap(address(wrapper), amount, self);\n\n        vaultRouter.wrap(address(wrapper), amount, address(vaultRouter), self);\n        wrapper.setFail(\"withdrawTo\", true);\n        vm.expectRevert(IVaultRouter.UnwrapFailed.selector);\n        vaultRouter.unwrap(address(wrapper), amount, self);\n        wrapper.setFail(\"withdrawTo\", false);\n\n        assertEq(wrapper.balanceOf(address(vaultRouter)), balance);\n        assertEq(erc20.balanceOf(self), 0);\n        vaultRouter.unwrap(address(wrapper), amount, self);\n        assertEq(wrapper.balanceOf(address(vaultRouter)), 0);\n        assertEq(erc20.balanceOf(self), balance);\n    }\n\n    function testEstimate() public view {\n        bytes memory message = MessageLib.NotifyPool(1).serialize();\n        uint256 estimated = vaultRouter.estimate(CHAIN_ID, message);\n        uint256 gatewayEstimated = gateway.estimate(CHAIN_ID, message);\n        assertEq(estimated, gatewayEstimated);\n    }\n\n    function testIfUserIsPermittedToExecuteRequests() public {\n        uint256 amount = 100 * 10 ** 18;\n        (, address vault_,) = deploySimpleVault(VaultKind.Async);\n        vm.label(vault_, \"vault\");\n        AsyncVault vault = AsyncVault(vault_);\n\n        vm.deal(self, 1 ether);\n        erc20.mint(self, amount);\n        erc20.approve(address(vaultRouter), amount);\n\n        bool canUserExecute = vaultRouter.hasPermissions(vault, self);\n        assertFalse(canUserExecute);\n\n        vaultRouter.lockDepositRequest(vault, amount, self, self);\n        assertEq(erc20.balanceOf(address(routerEscrow)), amount);\n\n        uint256 gasLimit = vaultRouter.estimate(CHAIN_ID, PAYLOAD_FOR_GAS_ESTIMATION);\n\n        vm.expectRevert(IAsyncRequestManager.TransferNotAllowed.selector);\n        vaultRouter.executeLockedDepositRequest{value: gasLimit}(vault, self);\n        centrifugeChain.updateMember(vault.poolId().raw(), vault.scId().raw(), self, type(uint64).max);\n\n        canUserExecute = vaultRouter.hasPermissions(vault, self);\n        assertTrue(canUserExecute);\n\n        vaultRouter.executeLockedDepositRequest{value: gasLimit}(vault, self);\n        assertEq(erc20.balanceOf(address(routerEscrow)), 0);\n        assertEq(erc20.balanceOf(address(globalEscrow)), amount);\n    }\n\n    function estimateGas() internal view returns (uint256) {\n        return gateway.estimate(CHAIN_ID, PAYLOAD_FOR_GAS_ESTIMATION);\n    }\n}\n"
    },
    "test/vaults/unit/factories/PoolEscrowFactory.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\n\nimport {ShareClassId} from \"src/common/types/ShareClassId.sol\";\nimport {PoolId} from \"src/common/types/PoolId.sol\";\n\nimport {IPoolEscrowProvider, IPoolEscrowFactory} from \"src/vaults/interfaces/factories/IPoolEscrowFactory.sol\";\nimport {PoolEscrow} from \"src/vaults/Escrow.sol\";\nimport {PoolEscrowFactory} from \"src/vaults/factories/PoolEscrowFactory.sol\";\n\ncontract PoolEscrowFactoryTest is Test {\n    PoolEscrowFactory factory;\n\n    address deployer = address(this);\n    address root = makeAddr(\"root\");\n    address poolManager = makeAddr(\"poolManager\");\n    address gateway = makeAddr(\"gateway\");\n    address balanceSheet = makeAddr(\"balanceSheet\");\n    address asyncRequestManager = makeAddr(\"asyncRequestManager\");\n    address randomUser = makeAddr(\"randomUser\");\n\n    function setUp() public {\n        factory = new PoolEscrowFactory(root, deployer);\n        factory.file(\"poolManager\", poolManager);\n        factory.file(\"gateway\", gateway);\n        factory.file(\"balanceSheet\", balanceSheet);\n        factory.file(\"asyncRequestManager\", asyncRequestManager);\n    }\n\n    function testDeployEscrowAtDeterministicAddress(PoolId poolId) public {\n        address expectedEscrow = address(factory.escrow(poolId));\n        address actual = address(factory.newEscrow(poolId));\n\n        assertEq(expectedEscrow, actual, \"Escrow address mismatch\");\n    }\n\n    function testDeployEscrowTwiceReverts(PoolId poolId) public {\n        factory.newEscrow(poolId);\n        vm.expectRevert();\n        factory.newEscrow(poolId);\n    }\n\n    function testEscrowHasCorrectPermissions(PoolId poolId, address nonWard) public {\n        vm.assume(\n            nonWard != root && nonWard != gateway && nonWard != poolManager && nonWard != balanceSheet\n                && nonWard != asyncRequestManager\n        );\n        address escrowAddr = address(factory.newEscrow(poolId));\n\n        PoolEscrow escrow = PoolEscrow(payable(escrowAddr));\n\n        assertEq(escrow.wards(root), 1, \"root not authorized\");\n        assertEq(escrow.wards(gateway), 1, \"gateway not authorized\");\n        assertEq(escrow.wards(poolManager), 1, \"poolManager not authorized\");\n        assertEq(escrow.wards(balanceSheet), 1, \"balanceSheet not authorized\");\n        assertEq(escrow.wards(asyncRequestManager), 1, \"asyncRequestManager not authorized\");\n\n        assertEq(escrow.wards(address(factory)), 0, \"factory still authorized\");\n        assertEq(escrow.wards(nonWard), 0, \"unexpected authorization\");\n    }\n\n    function testFileSetsPoolManager() public {\n        factory.file(\"poolManager\", randomUser);\n        assertEq(factory.poolManager(), randomUser);\n    }\n\n    function testFileSetsBalanceSheet() public {\n        factory.file(\"balanceSheet\", randomUser);\n        assertEq(factory.balanceSheet(), randomUser);\n    }\n\n    function testFileSetsAsyncRequestManager() public {\n        factory.file(\"asyncRequestManager\", randomUser);\n        assertEq(factory.asyncRequestManager(), randomUser);\n    }\n\n    function testFileWithUnknownParamReverts() public {\n        vm.expectRevert(IPoolEscrowFactory.FileUnrecognizedParam.selector);\n        factory.file(\"unknown\", randomUser);\n    }\n\n    function testFileUnauthorizedReverts() public {\n        vm.prank(randomUser);\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        factory.file(\"poolManager\", randomUser);\n    }\n}\n"
    },
    "test/vaults/unit/factories/TokenFactory.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {Root} from \"src/common/Root.sol\";\n\nimport {TokenFactory} from \"src/vaults/factories/TokenFactory.sol\";\nimport {ShareToken} from \"src/vaults/token/ShareToken.sol\";\nimport {Escrow} from \"src/vaults/Escrow.sol\";\nimport {VaultKind} from \"src/vaults/interfaces/IBaseVaults.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\nimport {BaseTest} from \"test/vaults/BaseTest.sol\";\nimport \"forge-std/Test.sol\";\n\ninterface PoolManagerLike {\n    function getShare(uint64 poolId, bytes16 scId) external view returns (address);\n}\n\ncontract FactoryTest is Test {\n    uint256 mainnetFork;\n    uint256 polygonFork;\n    address root;\n\n    function setUp() public {\n        if (vm.envOr(\"FORK_TESTS\", false)) {\n            mainnetFork = vm.createFork(vm.rpcUrl(\"ethereum-mainnet\"));\n            polygonFork = vm.createFork(vm.rpcUrl(\"polygon-mainnet\"));\n        }\n\n        root = address(new Root(48 hours, address(this)));\n    }\n\n    function testTokenFactoryIsDeterministicAcrossChains(bytes16 scId) public {\n        if (vm.envOr(\"FORK_TESTS\", false)) {\n            vm.setEnv(\"DEPLOYMENT_SALT\", \"0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563\");\n            vm.selectFork(mainnetFork);\n            BaseTest testSetup1 = new BaseTest{salt: keccak256(abi.encode(vm.envString(\"DEPLOYMENT_SALT\")))}();\n            testSetup1.setUp();\n            testSetup1.deployVault(\n                VaultKind.Async,\n                18,\n                testSetup1.fullRestrictionsHook(),\n                bytes16(bytes(\"1\")),\n                address(testSetup1.erc20()),\n                0,\n                0\n            );\n            address token1 =\n                PoolManagerLike(address(testSetup1.poolManager())).getShare(testSetup1.POOL_A().raw(), scId);\n            address root1 = address(testSetup1.root());\n\n            vm.selectFork(polygonFork);\n            BaseTest testSetup2 = new BaseTest{salt: keccak256(abi.encode(vm.envString(\"DEPLOYMENT_SALT\")))}();\n            testSetup2.setUp();\n            testSetup2.deployVault(\n                VaultKind.Async,\n                18,\n                testSetup2.fullRestrictionsHook(),\n                bytes16(bytes(\"1\")),\n                address(testSetup2.erc20()),\n                0,\n                0\n            );\n            address token2 =\n                PoolManagerLike(address(testSetup2.poolManager())).getShare(testSetup2.POOL_A().raw(), scId);\n            address root2 = address(testSetup2.root());\n\n            assertEq(address(root1), address(root2));\n            assertEq(token1, token2);\n        }\n    }\n\n    function testTokenFactoryShouldBeDeterministic(bytes32 salt) public {\n        address predictedAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            salt,\n                            keccak256(\n                                abi.encodePacked(\n                                    type(TokenFactory).creationCode, abi.encode(root), abi.encode(address(this))\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n        );\n        TokenFactory tokenFactory = new TokenFactory{salt: salt}(root, address(this));\n        assertEq(address(tokenFactory), predictedAddress);\n    }\n\n    function testShareShouldBeDeterministic(\n        address asyncRequestManager,\n        address poolManager,\n        string memory name,\n        string memory symbol,\n        bytes32 factorySalt,\n        bytes32 tokenSalt,\n        uint8 decimals\n    ) public {\n        decimals = uint8(bound(decimals, 0, 18));\n        TokenFactory tokenFactory = new TokenFactory{salt: factorySalt}(root, address(this));\n\n        address predictedAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(tokenFactory),\n                            tokenSalt,\n                            keccak256(abi.encodePacked(type(ShareToken).creationCode, abi.encode(decimals)))\n                        )\n                    )\n                )\n            )\n        );\n\n        address[] memory tokenWards = new address[](2);\n        tokenWards[0] = address(asyncRequestManager);\n        tokenWards[1] = address(poolManager);\n\n        IShareToken token = tokenFactory.newToken(name, symbol, decimals, tokenSalt, tokenWards);\n\n        assertEq(address(token), predictedAddress);\n        assertEq(tokenFactory.getAddress(decimals, tokenSalt), address(token));\n    }\n\n    function testDeployingDeterministicAddressTwiceReverts(\n        bytes32 salt,\n        address asyncRequestManager,\n        address poolManager,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public {\n        decimals = uint8(bound(decimals, 0, 18));\n        address predictedAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            salt,\n                            keccak256(\n                                abi.encodePacked(\n                                    type(TokenFactory).creationCode, abi.encode(root), abi.encode(address(this))\n                                )\n                            )\n                        )\n                    )\n                )\n            )\n        );\n\n        address[] memory tokenWards = new address[](2);\n        tokenWards[0] = address(asyncRequestManager);\n        tokenWards[1] = address(poolManager);\n\n        TokenFactory tokenFactory = new TokenFactory{salt: salt}(root, address(this));\n        assertEq(address(tokenFactory), predictedAddress);\n\n        tokenFactory.newToken(name, symbol, decimals, bytes32(0), tokenWards);\n        vm.expectRevert();\n        tokenFactory.newToken(name, symbol, decimals, bytes32(0), tokenWards);\n    }\n\n    function _stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n}\n"
    },
    "test/vaults/unit/token/RestrictedTransfers.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport \"forge-std/Test.sol\";\n\nimport {MockRoot} from \"test/common/mocks/MockRoot.sol\";\n\nimport {IERC165} from \"src/misc/interfaces/IERC7575.sol\";\n\nimport {ShareToken} from \"src/vaults/token/ShareToken.sol\";\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\n\nimport {FullRestrictions} from \"src/hooks/FullRestrictions.sol\";\nimport {IMemberlist} from \"src/hooks/interfaces/IMemberlist.sol\";\nimport {IFreezable} from \"src/hooks/interfaces/IFreezable.sol\";\n\ncontract FullRestrictionsTest is Test {\n    MockRoot root;\n    ShareToken token;\n    FullRestrictions fullRestrictionsHook;\n\n    function setUp() public {\n        root = new MockRoot();\n        token = new ShareToken(18);\n        fullRestrictionsHook = new FullRestrictions(address(root), address(this));\n        token.file(\"hook\", address(fullRestrictionsHook));\n    }\n\n    function testHandleInvalidMessage() public {\n        vm.expectRevert(IHook.InvalidUpdate.selector);\n        fullRestrictionsHook.updateRestriction(address(token), abi.encodePacked(uint8(0)));\n    }\n\n    function testAddMember(uint64 validUntil) public {\n        vm.assume(validUntil >= block.timestamp);\n\n        vm.expectRevert(IMemberlist.InvalidValidUntil.selector);\n        fullRestrictionsHook.updateMember(address(token), address(this), uint64(block.timestamp - 1));\n\n        fullRestrictionsHook.updateMember(address(token), address(this), validUntil);\n        (bool _isMember, uint64 _validUntil) = fullRestrictionsHook.isMember(address(token), address(this));\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n    }\n\n    function testIsMember(uint64 validUntil) public {\n        vm.assume(validUntil >= block.timestamp);\n\n        fullRestrictionsHook.updateMember(address(token), address(this), validUntil);\n        (bool _isMember, uint64 _validUntil) = fullRestrictionsHook.isMember(address(token), address(this));\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n    }\n\n    function testFreeze() public {\n        fullRestrictionsHook.freeze(address(token), address(this));\n        assertEq(fullRestrictionsHook.isFrozen(address(token), address(this)), true);\n    }\n\n    function testFreezingZeroAddress() public {\n        vm.expectRevert(IFreezable.CannotFreezeZeroAddress.selector);\n        fullRestrictionsHook.freeze(address(token), address(0));\n        assertEq(fullRestrictionsHook.isFrozen(address(token), address(0)), false);\n    }\n\n    function testAddMemberAndFreeze(uint64 validUntil) public {\n        vm.assume(validUntil >= block.timestamp);\n\n        fullRestrictionsHook.updateMember(address(token), address(this), validUntil);\n        (bool _isMember, uint64 _validUntil) = fullRestrictionsHook.isMember(address(token), address(this));\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n        assertEq(fullRestrictionsHook.isFrozen(address(token), address(this)), false);\n\n        fullRestrictionsHook.freeze(address(token), address(this));\n        (_isMember, _validUntil) = fullRestrictionsHook.isMember(address(token), address(this));\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n        assertEq(fullRestrictionsHook.isFrozen(address(token), address(this)), true);\n    }\n\n    // --- erc165 checks ---\n    function testERC165Support(bytes4 unsupportedInterfaceId) public view {\n        bytes4 erc165 = 0x01ffc9a7;\n        bytes4 hook = 0xad4e9d84;\n\n        vm.assume(unsupportedInterfaceId != erc165 && unsupportedInterfaceId != hook);\n\n        assertEq(type(IERC165).interfaceId, erc165);\n        assertEq(type(IHook).interfaceId, hook);\n\n        assertEq(fullRestrictionsHook.supportsInterface(erc165), true);\n        assertEq(fullRestrictionsHook.supportsInterface(hook), true);\n\n        assertEq(fullRestrictionsHook.supportsInterface(unsupportedInterfaceId), false);\n    }\n}\n"
    },
    "test/vaults/unit/token/ShareToken.t.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {MockRoot} from \"test/common/mocks/MockRoot.sol\";\nimport \"forge-std/Test.sol\";\n\nimport {IAuth} from \"src/misc/interfaces/IAuth.sol\";\nimport {IERC20} from \"src/misc/interfaces/IERC20.sol\";\nimport {ERC20} from \"src/misc/ERC20.sol\";\n\nimport \"src/misc/interfaces/IERC7575.sol\";\nimport \"src/misc/interfaces/IERC7540.sol\";\nimport {ShareToken} from \"src/vaults/token/ShareToken.sol\";\n\nimport {MockFullRestrictions} from \"test/vaults/mocks/MockFullRestrictions.sol\";\nimport {IHook} from \"src/common/interfaces/IHook.sol\";\nimport {IShareToken} from \"src/vaults/interfaces/token/IShareToken.sol\";\n\ninterface ERC20Like {\n    function balanceOf(address) external view returns (uint256);\n}\n\ncontract ShareTokenTest is Test {\n    ShareToken token;\n    MockFullRestrictions fullRestrictionsHook;\n\n    address self;\n    address escrow = makeAddr(\"escrow\");\n    address targetUser = makeAddr(\"targetUser\");\n    address randomUser = makeAddr(\"random\");\n    uint64 validUntil = uint64(block.timestamp + 7 days);\n\n    function setUp() public {\n        self = address(this);\n        token = new ShareToken(18);\n        token.file(\"name\", \"Some Token\");\n        token.file(\"symbol\", \"ST\");\n\n        fullRestrictionsHook = new MockFullRestrictions(address(new MockRoot()), address(this));\n        token.file(\"hook\", address(fullRestrictionsHook));\n    }\n\n    // --- Admnistration ---\n    function testFile(address asset, address vault) public {\n        address hook = makeAddr(\"hook\");\n\n        // fail: unrecognized param\n        vm.expectRevert(ERC20.FileUnrecognizedParam.selector);\n        token.file(\"random\", hook);\n\n        // success\n        token.file(\"hook\", hook);\n        assertEq(address(token.hook()), hook);\n\n        token.updateVault(asset, vault);\n        assertEq(address(token.vault(asset)), vault);\n\n        // remove self from wards\n        token.deny(self);\n\n        // auth fail\n        vm.expectRevert(IShareToken.NotAuthorizedOrHook.selector);\n        token.file(\"hook\", hook);\n\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        token.updateVault(asset, vault);\n    }\n\n    // --- erc165 checks ---\n    function testERC165Support(bytes4 unsupportedInterfaceId) public view {\n        bytes4 erc165 = 0x01ffc9a7;\n        bytes4 erc7575Share = 0xf815c03d;\n\n        vm.assume(unsupportedInterfaceId != erc165 && unsupportedInterfaceId != erc7575Share);\n\n        assertEq(type(IERC165).interfaceId, erc165);\n        assertEq(type(IERC7575Share).interfaceId, erc7575Share);\n\n        assertEq(token.supportsInterface(erc165), true);\n        assertEq(token.supportsInterface(erc7575Share), true);\n\n        assertEq(token.supportsInterface(unsupportedInterfaceId), false);\n    }\n\n    // --- erc1404 checks ---\n    function testERC1404Support() public view {\n        assertEq(token.messageForTransferRestriction(0), \"transfer-allowed\");\n        assertEq(token.messageForTransferRestriction(1), \"transfer-blocked\");\n    }\n\n    // --- FullRestrictions ---\n    // transferFrom\n    /// forge-config: default.isolate = true\n    function testTransferFrom() public {\n        _testTransferFrom(1, true);\n    }\n\n    // --- FullRestrictions ---\n    // transferFrom\n    /// forge-config: default.isolate = true\n    function testTransferFromFuzz(uint256 amount) public {\n        _testTransferFrom(amount, false);\n    }\n\n    function _testTransferFrom(uint256 amount, bool snap) internal {\n        amount = bound(amount, 0, type(uint128).max / 2);\n\n        fullRestrictionsHook.updateMember(address(token), self, uint64(validUntil));\n        token.mint(self, amount * 2);\n\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transferFrom(self, targetUser, amount);\n        assertEq(token.balanceOf(targetUser), 0);\n\n        fullRestrictionsHook.updateMember(address(token), targetUser, uint64(validUntil));\n        (bool _isMember, uint64 _validUntil) = fullRestrictionsHook.isMember(address(token), targetUser);\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n\n        fullRestrictionsHook.freeze(address(token), self);\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transferFrom(self, targetUser, amount);\n        assertEq(token.balanceOf(targetUser), 0);\n\n        fullRestrictionsHook.unfreeze(address(token), self);\n        fullRestrictionsHook.freeze(address(token), targetUser);\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transferFrom(self, targetUser, amount);\n        assertEq(token.balanceOf(targetUser), 0);\n\n        fullRestrictionsHook.unfreeze(address(token), targetUser);\n        if (snap) {\n            vm.startSnapshotGas(\"ShareToken\", \"transferFrom\");\n        }\n        token.transferFrom(self, targetUser, amount);\n        if (snap) {\n            vm.stopSnapshotGas();\n        }\n        assertEq(token.balanceOf(targetUser), amount);\n        afterTransferAssumptions(self, targetUser, amount);\n\n        vm.warp(validUntil + 1);\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transferFrom(self, targetUser, amount);\n    }\n\n    function testTransferFromTokensWithApproval(uint256 amount) public {\n        amount = bound(amount, 1, type(uint128).max);\n        address sender = makeAddr(\"sender\");\n        fullRestrictionsHook.updateMember(address(token), sender, uint64(validUntil));\n        token.mint(sender, amount);\n\n        fullRestrictionsHook.updateMember(address(token), targetUser, uint64(validUntil));\n\n        vm.expectRevert(IERC20.InsufficientAllowance.selector);\n        token.transferFrom(sender, targetUser, amount);\n\n        vm.prank(sender);\n        token.approve(self, amount);\n        token.transferFrom(sender, targetUser, amount);\n        assertEq(token.balanceOf(targetUser), amount);\n        assertEq(token.balanceOf(sender), 0);\n    }\n\n    // transfer\n    function testTransfer(uint256 amount) public {\n        amount = bound(amount, 0, type(uint128).max / 2);\n\n        fullRestrictionsHook.updateMember(address(token), self, uint64(validUntil));\n        token.mint(self, amount * 2);\n\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transfer(targetUser, amount);\n        assertEq(token.balanceOf(targetUser), 0);\n\n        fullRestrictionsHook.updateMember(address(token), targetUser, uint64(validUntil));\n        (bool _isMember, uint64 _validUntil) = fullRestrictionsHook.isMember(address(token), targetUser);\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n\n        fullRestrictionsHook.freeze(address(token), self);\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transfer(targetUser, amount);\n        assertEq(token.balanceOf(targetUser), 0);\n\n        fullRestrictionsHook.unfreeze(address(token), self);\n        token.transfer(targetUser, amount);\n        assertEq(token.balanceOf(targetUser), amount);\n        afterTransferAssumptions(self, targetUser, amount);\n\n        vm.warp(validUntil + 1);\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.transfer(targetUser, amount);\n    }\n\n    // auth transfer\n    function testAuthTransferFrom(uint256 amount) public {\n        amount = bound(amount, 0, type(uint128).max);\n        address sourceUser = makeAddr(\"sourceUser\");\n        fullRestrictionsHook.updateMember(address(token), sourceUser, uint64(validUntil));\n        token.mint(sourceUser, amount);\n\n        vm.prank(address(2));\n        vm.expectRevert(IAuth.NotAuthorized.selector);\n        token.authTransferFrom(sourceUser, sourceUser, self, amount);\n        assertEq(token.balanceOf(sourceUser), amount);\n        assertEq(token.balanceOf(self), 0);\n\n        token.authTransferFrom(sourceUser, sourceUser, self, amount);\n        assertEq(token.balanceOf(sourceUser), 0);\n        assertEq(token.balanceOf(self), amount);\n    }\n\n    // mint\n    function testMintTokensToMemberWorks(uint256 amount) public {\n        amount = bound(amount, 0, type(uint128).max / 2);\n\n        // mint fails -> self not a member\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.mint(targetUser, amount);\n\n        fullRestrictionsHook.updateMember(address(token), targetUser, uint64(validUntil));\n        (bool _isMember, uint64 _validUntil) = fullRestrictionsHook.isMember(address(token), targetUser);\n        assertTrue(_isMember);\n        assertEq(_validUntil, validUntil);\n\n        token.mint(targetUser, amount);\n        assertEq(token.balanceOf(targetUser), amount);\n        afterTransferAssumptions(address(0), targetUser, amount);\n\n        vm.warp(validUntil + 1);\n\n        vm.expectRevert(IHook.TransferBlocked.selector);\n        token.mint(targetUser, amount);\n    }\n\n    function afterTransferAssumptions(address from, address to, uint256 value) internal view {\n        assertEq(fullRestrictionsHook.values_address(\"onERC20Transfer_from\"), from);\n        assertEq(fullRestrictionsHook.values_address(\"onERC20Transfer_to\"), to);\n        assertEq(fullRestrictionsHook.values_uint256(\"onERC20Transfer_value\"), value);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/",
      "@chimera/=lib/chimera/src/",
      "chimera/=lib/chimera/src/",
      "ds-test/=lib/chimera/lib/forge-std/lib/ds-test/src/"
    ],
    "optimizer": { "enabled": true, "runs": 1 },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "none",
      "appendCBOR": true
    },
    "outputSelection": {
      "lib/forge-std/src/Base.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/Script.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdAssertions.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdChains.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdCheats.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdError.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdInvariant.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdJson.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdMath.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdStorage.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdStyle.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdToml.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/StdUtils.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/Test.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/Vm.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/console.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/console2.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/interfaces/IERC165.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/interfaces/IERC20.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/interfaces/IERC721.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/interfaces/IMulticall3.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/mocks/MockERC20.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/mocks/MockERC721.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "lib/forge-std/src/safeconsole.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/CommonDeployer.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/FullDeployer.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/HubDeployer.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/VaultsDeployer.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/adapters/Axelar.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/adapters/Localhost.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/adapters/Wormhole.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "script/utils/JsonRegistry.s.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/GasService.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/Gateway.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/Guardian.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/MessageDispatcher.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/MessageProcessor.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/Root.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/TokenRecoverer.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/adapters/AxelarAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/adapters/WormholeAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IAxelarAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IGasService.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IGateway.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IGatewayHandlers.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IGatewaySenders.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IGuardian.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IGuardianActions.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IHook.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IMessageDispatcher.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IMessageHandler.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IMessageProcessor.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IMessageProperties.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IMessageSender.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IRoot.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/ITokenRecoverer.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/interfaces/IWormholeAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/libraries/MessageLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/libraries/MessageProofLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/libraries/PricingLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/types/AccountId.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/types/AssetId.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/types/PoolId.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/common/types/ShareClassId.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hooks/FreezeOnly.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hooks/FullRestrictions.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hooks/RedemptionRestrictions.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hooks/interfaces/IFreezable.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hooks/interfaces/IMemberlist.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/Accounting.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/Holdings.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/Hub.sol": { "*": ["abi", "evm.methodIdentifiers", "metadata"] },
      "src/hub/HubRegistry.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/ShareClassManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/interfaces/IAccounting.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/interfaces/IHoldings.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/interfaces/IHub.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/interfaces/IHubRegistry.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/hub/interfaces/IShareClassManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/Auth.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/BaseValuation.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/ERC20.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/IdentityValuation.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/Multicall.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/Recoverable.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/ReentrancyProtection.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IAuth.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IBaseValuation.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IERC20.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IERC6909.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IERC7540.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IERC7575.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IERC7726.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IIdentityValuation.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IMulticall.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/interfaces/IRecoverable.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/ArrayLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/BitmapLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/BytesLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/CastLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/EIP712Lib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/MathLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/SafeTransferLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/SignatureLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/StringLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/TransientArrayLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/TransientBytesLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/libraries/TransientStorageLib.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/misc/types/D18.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/AsyncRequestManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/AsyncVault.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/BalanceSheet.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/BaseRequestManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/BaseVaults.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/Escrow.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/PoolManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/SyncDepositVault.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/SyncRequestManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/VaultRouter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/factories/AsyncVaultFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/factories/PoolEscrowFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/factories/SyncDepositVaultFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/factories/TokenFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/IBalanceSheet.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/IBaseVaults.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/IEscrow.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/IPoolManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/IUpdateContract.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/IVaultRouter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/factories/IPoolEscrowFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/factories/ITokenFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/factories/IVaultFactory.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/IAsyncDepositManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/IAsyncRedeemManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/IAsyncRequestManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/IBaseRequestManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/IDepositManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/IRedeemManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/ISyncDepositManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/investments/ISyncRequestManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/interfaces/token/IShareToken.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/legacy/LegacyVaultAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/legacy/interfaces/IInvestmentManager.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/legacy/interfaces/ILegacyVault.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/legacy/interfaces/ILegacyVaultAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "src/vaults/token/ShareToken.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/mocks/Mock.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/mocks/MockAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/mocks/MockGasService.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/mocks/MockRoot.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/types/AccountId.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/types/AssetId.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/types/PoolId.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/types/ShareClassId.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/AxelarAdapter.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/GasService.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/Gateway.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/Guardian.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/TokenRecoverer.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/WormholeAdapter.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/libraries/MessageLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/common/unit/libraries/MessageProofLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hooks/integration/FreelyTransferable.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/integration/BaseTest.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/integration/BatchingAndPayment.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/integration/Cases.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/mocks/MockVaults.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/unit/Accounting.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/unit/Holdings.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/unit/Hub.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/unit/HubRegistry.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/hub/unit/ShareClassManager.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/integration/EndToEnd.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/integration/adapters/LocalAdapter.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/mocks/MockERC6909.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/mocks/MockValuation.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/BaseValuation.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/EIP712Lib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/ERC20.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/IdentityValuation.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/Multicall.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/Recoverable.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/SignatureLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/ArrayLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/BytesLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/CastLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/D18.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/MathLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/PricingLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/SafeTransferLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/StringLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/TransientArrayLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/TransientBytesLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/misc/unit/libraries/TransientStorageLib.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/BaseTest.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/Admin.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/AssetShareConversion.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/AsyncRequestManager.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/BalanceSheet.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/Burn.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/Deposit.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/DepositRedeem.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/Mint.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/Operator.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/PoolManager.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/Redeem.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/SyncDeposit.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/SyncRequestManager.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/integration/VaultRouter.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/mocks/MockCentrifugeChain.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/mocks/MockERC20Wrapper.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/mocks/MockFullRestrictions.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/mocks/MockHook.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/mocks/MockReentrantERC20Wrapper.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/mocks/MockSafe.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/AsyncVault.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/Escrow.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/VaultRouter.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/factories/PoolEscrowFactory.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/factories/TokenFactory.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/token/RestrictedTransfers.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      },
      "test/vaults/unit/token/ShareToken.t.sol": {
        "*": ["abi", "evm.methodIdentifiers", "metadata"]
      }
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "libraries": {}
  }
}
